{
  "daily": [
    {
      "id": "2025-06-04-auto-generated",
      "title": "팀 프로젝트 3일차, 프로젝트 구조 파악과 새로운 시작 🚀",
      "date": "2025-06-04",
      "category": "daily",
      "tags": [
        "Git",
        "CSS",
        "HTML",
        "프로젝트",
        "개발"
      ],
      "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=400&h=200&fit=crop",
      "description": "2025-06-04의 학습 내용 정리",
      "excerpt": "팀 프로젝트 3일차. 오늘은 실제 프로젝트 저장소를 클론해서 구조를 파악하고, 새로운 작업 환경을 세팅하는 날이었다. GitHub의 develop 브랜치에서 컴포넌트 구조를 확인하...",
      "content": "# 팀 프로젝트 3일차, 프로젝트 구조 파악과 새로운 시작 🚀\r\n\r\n팀 프로젝트 3일차. 오늘은 실제 프로젝트 저장소를 클론해서 구조를 파악하고, 새로운 작업 환경을 세팅하는 날이었다. GitHub의 develop 브랜치에서 컴포넌트 구조를 확인하면서 팀이 어떻게 작업을 진행하고 있는지 직접 볼 수 있었다.\r\n\r\n## 🎯 오늘의 주요 작업\r\n\r\n### 📁 프로젝트 저장소 클론 및 구조 파악\r\n- **저장소 클론**: `https://github.com/FRONTENDBOOTCAMP-14th/project-team-2.git`\r\n- **develop 브랜치**: 팀의 메인 작업 브랜치 확인\r\n- **프로젝트 구조**: Vite 기반 프로젝트, 컴포넌트 기반 구조\r\n\r\n```\r\nproject-team-2/\r\n├── src/\r\n│   ├── components/        # 컴포넌트들\r\n│   │   ├── organisms/     # 헤더, 푸터 등\r\n│   │   ├── molecules/     # 카드, 로고 등\r\n│   │   ├── atoms/         # 기본 요소들\r\n│   │   └── styles/        # 컴포넌트 스타일\r\n│   ├── pages/             # 페이지들\r\n│   │   ├── main/\r\n│   │   ├── login/\r\n│   │   ├── cart/\r\n│   │   └── product-list/\r\n│   └── common/            # 공통 파일들\r\n├── index.html             # 메인 인덱스 페이지\r\n└── package.json           # 프로젝트 설정\r\n```\r\n\r\n### 🔍 현재 프로젝트 현황 파악\r\n- **완성된 페이지들**: 메인, 로그인/회원가입, 장바구니\r\n- **컴포넌트 시스템**: 아토믹 디자인 패턴 적용\r\n- **인덱스 페이지**: 모든 컴포넌트와 페이지 링크 제공\r\n\r\n### 📋 새로운 작업 계획\r\n- **목표**: `html > component/index/` 작업공간 생성\r\n- **스타일**: `css > component/style/` 작업공간 구성\r\n- **브랜치**: 새로운 feature 브랜치 생성 예정\r\n\r\n## 🤔 오늘의 회고\r\n\r\n### 잘된 점\r\n1. **프로젝트 구조 이해**: 팀의 코드 구조와 컨벤션 파악\r\n2. **Git 환경 설정**: 원격 저장소 클론 및 브랜치 확인\r\n3. **아토믹 디자인**: 체계적인 컴포넌트 구조 확인\r\n4. **인덱스 페이지**: 모든 컴포넌트를 한눈에 볼 수 있는 구조\r\n\r\n### 배운 점\r\n1. **Vite 프로젝트**: 모던 빌드 도구 사용법\r\n2. **컴포넌트 분리**: organisms > molecules > atoms 구조\r\n3. **팀 협업**: feature 브랜치별 작업 분담\r\n4. **프로젝트 관리**: 체계적인 폴더 구조의 중요성\r\n\r\n### 내일 할 일\r\n1. **새 브랜치 생성**: feature/index-component 브랜치\r\n2. **작업공간 설정**: HTML/CSS 폴더 구조 생성\r\n3. **컴포넌트 개발**: 인덱스 관련 컴포넌트 작업 시작\r\n4. **팀 동기화**: 다른 팀원들과 진행상황 공유\r\n\r\n## 📊 오늘의 데이터\r\n\r\n```\r\nGit 작업:\r\n├── 저장소 클론: ✅ 완료\r\n├── 브랜치 확인: develop ✅\r\n├── 구조 파악: src/ 폴더 구조 ✅\r\n└── 환경 설정: 로컬 개발환경 ✅\r\n\r\n팀 프로젝트 현황:\r\n├── 완성 페이지: 3/5개 (60%)\r\n├── 진행 페이지: 2/5개 (40%)\r\n├── 컴포넌트: 다수 완성\r\n└── 인덱스 페이지: 네비게이션 완료\r\n```\r\n\r\n## 💻 기술적 발견\r\n\r\n### Vite 프로젝트 구조\r\n```json\r\n// package.json 일부\r\n{\r\n  \"name\": \"project-team-2\",\r\n  \"scripts\": {\r\n    \"dev\": \"vite\",\r\n    \"build\": \"vite build\",\r\n    \"preview\": \"vite preview\"\r\n  }\r\n}\r\n```\r\n\r\n### 컴포넌트 아키텍처\r\n- **Organisms**: header.html, footer.html (큰 단위)\r\n- **Molecules**: main-card.html, header-logo.html (중간 단위)  \r\n- **Atoms**: button/, input/ (작은 단위)\r\n\r\n### 인덱스 페이지 역할\r\n```html\r\n<!-- 모든 컴포넌트와 페이지 링크 제공 -->\r\n<h2>컴포넌트</h2>\r\n<ul>\r\n  <li><a href=\"./src/components/organisms/header.html\">헤더</a></li>\r\n  <li><a href=\"./src/components/organisms/footer.html\">푸터</a></li>\r\n</ul>\r\n\r\n<h2>페이지</h2>\r\n<ul>\r\n  <li><a href=\"./src/pages/main/main.html\">메인</a></li>\r\n  <li><a href=\"./src/pages/login/desktop-login/login.html\">로그인</a></li>\r\n</ul>\r\n```\r\n\r\n## 🚀 내일 계획\r\n\r\n### 우선순위 작업\r\n1. **브랜치 생성**: `git checkout -b feature/index-component`\r\n2. **폴더 구조**: 요구사항에 맞는 디렉토리 생성\r\n3. **컴포넌트 개발**: 인덱스 관련 기능 구현\r\n4. **스타일링**: CSS 컴포넌트 스타일 작업\r\n\r\n### 협업 계획\r\n- **팀 미팅**: 진행상황 공유 및 이슈 논의\r\n- **코드 리뷰**: PR 작성 및 팀원 피드백 요청\r\n- **문서화**: 개발한 컴포넌트 Wiki 업데이트\r\n\r\n## 💡 오늘의 인사이트\r\n\r\n실제 팀 프로젝트 저장소를 보니 정말 체계적으로 구성되어 있었다. 특히 아토믹 디자인 패턴을 적용한 컴포넌트 구조가 인상적이었고, 인덱스 페이지에서 모든 컴포넌트를 한눈에 볼 수 있게 한 것도 좋은 아이디어라고 생각했다.\r\n\r\nVite를 사용한 것도 모던한 개발 환경을 구축하려는 팀의 의지가 보였고, Git 브랜치 전략도 feature별로 잘 나누어져 있어서 협업하기 좋은 환경이 갖춰져 있다는 걸 느꼈다.\r\n\r\n내일부터는 실제 코드 작성에 들어가는데, 팀의 컨벤션을 잘 따라서 일관성 있는 코드를 작성해야겠다. 특히 컴포넌트 구조와 네이밍 규칙을 정확히 파악해서 혼란이 없도록 주의해야겠다.\r\n\r\n---\r\n\r\n드디어 실제 팀 프로젝트 코드를 보면서 어떻게 협업하는지 감을 잡았다. 내일부터 본격적인 개발 시작! 💪 "
    },
    {
      "id": "2025-06-03-auto-generated",
      "title": "팀 프로젝트 2일차, 문서화와 협업의 중요성을 깨닫다 📝",
      "date": "2025-06-03",
      "category": "daily",
      "tags": [
        "Git",
        "학습",
        "프로젝트",
        "개발"
      ],
      "image": "https://images.unsplash.com/photo-1516321318423-f06f85e504b3?w=400&h=200&fit=crop",
      "description": "2025-06-03의 학습 내용 정리",
      "excerpt": "팀 프로젝트 2일차가 끝났다. 오늘은 개발보다는 문서화와 프로젝트 체계 정리에 집중했다. GitHub Wiki를 구축하면서 체계적인 문서화가 얼마나 중요한지 실감했고, 팀 협업에서...",
      "content": "# 팀 프로젝트 2일차, 문서화와 협업의 중요성을 깨닫다 📝\r\n\r\n팀 프로젝트 2일차가 끝났다. 오늘은 개발보다는 문서화와 프로젝트 체계 정리에 집중했다. GitHub Wiki를 구축하면서 체계적인 문서화가 얼마나 중요한지 실감했고, 팀 협업에서 소통의 중요성도 다시 한번 느꼈다.\r\n\r\n## 🎯 오늘의 주요 작업\r\n\r\n### 📚 GitHub Wiki 구축 완료\r\n- **6개 페이지 구성**: Home, 스프린트, 컨벤션, 폴더 구조, 회의, 회고\r\n- **기존 노션 내용 이전**: 흩어져 있던 정보들을 체계적으로 정리\r\n- **팀 히스토리 정리**: 5월 26일부터 현재까지 모든 회의록과 진행사항 통합\r\n\r\n```markdown\r\n# Wiki 페이지 구성\r\n1. Home - 프로젝트 개요 및 팀 구성\r\n2. 스프린트 - 주차별 진행 계획 및 현황\r\n3. 컨벤션 - Git & 코딩 컨벤션 정리\r\n4. 폴더 구조 - 프로젝트 파일 구조 및 관리 규칙\r\n5. 회의 - 전체 회의록 통합 정리\r\n6. 회고 - 팀/개인 목표 및 회고 모음\r\n```\r\n\r\n### 💻 팀 개발 현황 점검\r\n- **완료된 페이지**: 메인(정우진), 장바구니(김민지), 로그인/회원가입(최도형)\r\n- **진행중 페이지**: 제품상세(김상훈), 제품리스트(이성은)\r\n- **전체 진행률**: 약 60% → 목표했던 \"모든 페이지 완성\"에 근접\r\n\r\n### 🔧 협업 도구 활용\r\n- **디스코드**: 실시간 소통으로 즉각적 문제 해결\r\n- **화면공유**: 멘토링 세션 3회 진행\r\n- **PR 리뷰**: 실시간 피드백과 코드 개선\r\n\r\n## 🤔 오늘의 회고\r\n\r\n### 잘된 점\r\n1. **체계적 문서화**: Wiki 구축으로 프로젝트 투명성 확보\r\n2. **팀 소통**: 디스코드를 통한 활발한 실시간 협업\r\n3. **지식 공유**: 접근성, Git 사용법 등 서로 학습 내용 공유\r\n4. **멘토링 문화**: \"질문 폭탄 환영\" 분위기로 심리적 안전감 형성\r\n\r\n### 아쉬운 점\r\n1. **일부 페이지 미완성**: 제품상세, 제품리스트 완성 지연\r\n2. **브랜치 관리 실수**: develop 브랜치 직접 작업 등 실수 발생\r\n3. **작업 손실**: 이성은님 작업 내용 손실로 시간 낭비\r\n4. **진도 차이**: 팀원별 작업 속도 차이\r\n\r\n### 개선할 점\r\n1. **백업 습관화**: 정기적 커밋/푸시로 작업 손실 방지\r\n2. **Git 교육**: 브랜치 관리 및 협업 도구 숙련도 향상\r\n3. **진도 관리**: 데일리 체크인으로 개별 진행 상황 점검\r\n\r\n## 📊 오늘의 데이터\r\n\r\n```\r\n목표 달성률:\r\n├── 페이지 완성: 3/5 (60%) ✅\r\n├── Wiki 구축: 6/6 (100%) ✅\r\n├── 문서 정리: 100% 완료 ✅\r\n└── 팀 소통: 매우 활발 ✅\r\n\r\n소통 현황:\r\n├── 디스코드 메시지: 100+ 건\r\n├── PR 제출: 5+ 건\r\n├── 코드 리뷰: 실시간 피드백\r\n└── 멘토링 세션: 화면공유 3회\r\n\r\n작업 분배:\r\n├── 정우진: 메인 완료 + Wiki 구축 + 팀 멘토링\r\n├── 김민지: 장바구니 완료 + 접근성 개선 작업\r\n├── 최도형: 로그인/회원가입 완료\r\n├── 김상훈: 제품상세 90% 진행중\r\n└── 이성은: 제품리스트 80% 진행중 (작업 손실 복구)\r\n```\r\n\r\n## 🚀 내일(6/4) 계획\r\n\r\n### 우선순위 목표\r\n1. **김상훈, 이성은**: 담당 페이지 100% 완성\r\n2. **정우진**: 인덱스 페이지 구현 및 전체 연결\r\n3. **김민지**: 접근성 개선 및 JS 파일 분리 완료\r\n4. **최도형**: 추가 기능 구현 및 반응형 점검\r\n\r\n### 액션 아이템\r\n- [ ] 모든 페이지 완성 확인\r\n- [ ] Header/Footer 통합 작업 시작\r\n- [ ] 반응형 디자인 전체 점검\r\n- [ ] 접근성 개선사항 전 페이지 적용\r\n- [ ] Git 사용법 추가 교육 세션\r\n\r\n## 💡 오늘의 학습\r\n\r\n### 협업에서 배운 것들\r\n- **문서화의 중요성**: 체계적인 Wiki가 팀 전체의 생산성을 높임\r\n- **실시간 소통의 효과**: 디스코드를 통한 즉각적 문제 해결\r\n- **멘토링의 가치**: 서로 가르치고 배우는 과정의 중요성\r\n- **Git 협업**: 브랜치 관리와 충돌 해결 경험\r\n\r\n### 느낀 점\r\n오늘 Wiki를 구축하면서 프로젝트가 정말 '프로젝트'다워졌다는 생각이 들었다. 문서화는 단순히 기록이 아니라 팀의 방향성을 맞추고 투명성을 확보하는 중요한 도구라는 걸 깨달았다. \r\n\r\n또한 \"질문하는 것을 두려워하지 말고, 프롬프트는 매우 중요합니다!\"라는 정우진 팀장의 조언이 팀 문화를 긍정적으로 바꾸는 걸 보면서, 좋은 리더십이 팀에 미치는 영향을 실감했다.\r\n\r\n## 📈 프로젝트 누적 현황\r\n\r\n```\r\n총 진행 기간: 8일 (5/27 ~ 6/3)\r\n완성된 페이지: 3/5개 (60%)\r\nWiki 페이지: 6개 완성\r\n회의록: 5회 작성\r\nPR 누적: 20+ 건\r\n학습 키워드: Git, 접근성, 반응형, 컴포넌트, 협업\r\n\r\n팀 만족도: ⭐⭐⭐⭐⭐ (5/5)\r\n프로젝트 몰입도: ⭐⭐⭐⭐⭐ (5/5)\r\n성장 체감도: ⭐⭐⭐⭐⭐ (5/5)\r\n```\r\n\r\n---\r\n\r\n개발 실력도 중요하지만, 결국 프로젝트는 사람들과 함께 만들어가는 것이라는 걸 다시 한번 깨닫는 하루였다. 내일은 모든 페이지 완성을 목표로 달려보자! 🏃‍♂️ "
    },
    {
      "id": "2025-06-02-auto-generated",
      "title": "이벤트 위임과 CSS 애니메이션으로 한 단계 업그레이드! ⚡",
      "date": "2025-06-02",
      "category": "daily",
      "tags": [
        "667eea",
        "764ba2",
        "667eea",
        "764ba2",
        "666",
        "todo",
        "e1e8ed",
        "todo",
        "667eea",
        "add",
        "667eea",
        "764ba2",
        "add",
        "add",
        "add",
        "999",
        "667eea",
        "666",
        "e1e8ed",
        "667eea",
        "667eea",
        "764ba2",
        "todo",
        "667eea",
        "28a745",
        "999",
        "17a2b8",
        "138496",
        "dc3545",
        "c82333",
        "999",
        "dc3545",
        "c82333",
        "ffc107",
        "333",
        "e0a800",
        "dc3545",
        "ffc107",
        "999"
      ],
      "image": "https://images.unsplash.com/photo-1488590528505-98d2b5aba04b?w=400&h=200&fit=crop",
      "description": "2025-06-02의 학습 내용 정리",
      "excerpt": "어제 DOM 조작과 기본 이벤트 처리를 배웠는데, 오늘은 더 고급 기법들을 배워봤다! 이벤트 위임(Event Delegation)이라는 개념과 CSS 애니메이션을 JavaScrip...",
      "content": "# 이벤트 위임과 CSS 애니메이션으로 한 단계 업그레이드! ⚡\r\n\r\n어제 DOM 조작과 기본 이벤트 처리를 배웠는데, 오늘은 더 고급 기법들을 배워봤다! 이벤트 위임(Event Delegation)이라는 개념과 CSS 애니메이션을 JavaScript로 제어하는 방법을 익혔다. 특히 이벤트 위임을 배우고 나니, 어제 만든 할일 앱의 코드를 훨씬 더 효율적으로 개선할 수 있었다! 🎉\r\n\r\n## 🎯 오늘의 핵심 학습: 이벤트 위임과 애니메이션\r\n\r\n### 이벤트 위임이란?\r\n\r\n```javascript\r\n// 이벤트 위임 전: 각 요소마다 이벤트 리스너 추가 (비효율적)\r\nfunction addEventListenersOldWay() {\r\n  const buttons = document.querySelectorAll('.delete-btn');\r\n  \r\n  buttons.forEach(button => {\r\n    button.addEventListener('click', function(e) {\r\n      console.log('삭제 버튼 클릭:', e.target);\r\n    });\r\n  });\r\n  \r\n  // 문제: 새로 추가된 버튼에는 이벤트가 없음!\r\n  // 매번 새 버튼을 추가할 때마다 이벤트를 다시 등록해야 함\r\n}\r\n\r\n// 이벤트 위임 후: 부모 요소에 하나의 리스너만 추가 (효율적!)\r\nfunction addEventListenersNewWay() {\r\n  const todoList = document.getElementById('todo-list');\r\n  \r\n  todoList.addEventListener('click', function(e) {\r\n    // 어떤 요소가 클릭되었는지 확인\r\n    if (e.target.classList.contains('delete-btn')) {\r\n      console.log('삭제 버튼 클릭:', e.target);\r\n      const todoId = e.target.dataset.id;\r\n      deleteTodo(todoId);\r\n    }\r\n    \r\n    if (e.target.classList.contains('todo-checkbox')) {\r\n      console.log('체크박스 클릭:', e.target);\r\n      const todoId = e.target.dataset.id;\r\n      toggleTodo(todoId);\r\n    }\r\n    \r\n    if (e.target.classList.contains('edit-btn')) {\r\n      console.log('수정 버튼 클릭:', e.target);\r\n      const todoId = e.target.dataset.id;\r\n      editTodo(todoId);\r\n    }\r\n  });\r\n  \r\n  // 장점: 새로 추가되는 요소들도 자동으로 이벤트가 작동함!\r\n}\r\n\r\n// 더 깔끔한 이벤트 위임 패턴\r\nclass EventDelegator {\r\n  constructor(parentElement) {\r\n    this.parent = parentElement;\r\n    this.handlers = new Map();\r\n    this.init();\r\n  }\r\n  \r\n  init() {\r\n    this.parent.addEventListener('click', (e) => {\r\n      this.handleClick(e);\r\n    });\r\n    \r\n    this.parent.addEventListener('change', (e) => {\r\n      this.handleChange(e);\r\n    });\r\n    \r\n    this.parent.addEventListener('input', (e) => {\r\n      this.handleInput(e);\r\n    });\r\n  }\r\n  \r\n  // 클릭 이벤트 위임\r\n  handleClick(e) {\r\n    for (let [selector, handler] of this.handlers) {\r\n      if (e.target.matches(selector)) {\r\n        handler(e);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  \r\n  // 체인지 이벤트 위임\r\n  handleChange(e) {\r\n    const changeHandlers = this.handlers.get('change') || [];\r\n    changeHandlers.forEach(handler => {\r\n      if (e.target.matches(handler.selector)) {\r\n        handler.callback(e);\r\n      }\r\n    });\r\n  }\r\n  \r\n  // 입력 이벤트 위임\r\n  handleInput(e) {\r\n    const inputHandlers = this.handlers.get('input') || [];\r\n    inputHandlers.forEach(handler => {\r\n      if (e.target.matches(handler.selector)) {\r\n        handler.callback(e);\r\n      }\r\n    });\r\n  }\r\n  \r\n  // 이벤트 핸들러 등록\r\n  on(selector, handler) {\r\n    this.handlers.set(selector, handler);\r\n  }\r\n}\r\n\r\n// 사용 예제\r\nconst delegator = new EventDelegator(document.getElementById('app'));\r\n\r\ndelegator.on('.delete-btn', (e) => {\r\n  console.log('삭제 버튼 클릭됨!', e.target.dataset.id);\r\n});\r\n\r\ndelegator.on('.edit-btn', (e) => {\r\n  console.log('수정 버튼 클릭됨!', e.target.dataset.id);\r\n});\r\n```\r\n\r\n### CSS 애니메이션을 JavaScript로 제어하기\r\n\r\n```javascript\r\n// 1. CSS 클래스로 애니메이션 트리거하기\r\nfunction animateElement(element, animationClass, duration = 1000) {\r\n  return new Promise((resolve) => {\r\n    // 애니메이션 클래스 추가\r\n    element.classList.add(animationClass);\r\n    \r\n    // 지정된 시간 후 클래스 제거하고 완료 신호\r\n    setTimeout(() => {\r\n      element.classList.remove(animationClass);\r\n      resolve();\r\n    }, duration);\r\n  });\r\n}\r\n\r\n// CSS 정의 (스타일시트에 추가)\r\nconst animationCSS = `\r\n  @keyframes fadeIn {\r\n    from { opacity: 0; transform: translateY(-20px); }\r\n    to { opacity: 1; transform: translateY(0); }\r\n  }\r\n  \r\n  @keyframes fadeOut {\r\n    from { opacity: 1; transform: scale(1); }\r\n    to { opacity: 0; transform: scale(0.8); }\r\n  }\r\n  \r\n  @keyframes slideIn {\r\n    from { transform: translateX(-100%); }\r\n    to { transform: translateX(0); }\r\n  }\r\n  \r\n  @keyframes bounce {\r\n    0%, 20%, 50%, 80%, 100% { transform: translateY(0); }\r\n    40% { transform: translateY(-30px); }\r\n    60% { transform: translateY(-15px); }\r\n  }\r\n  \r\n  @keyframes shake {\r\n    0%, 100% { transform: translateX(0); }\r\n    10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }\r\n    20%, 40%, 60%, 80% { transform: translateX(10px); }\r\n  }\r\n  \r\n  .fade-in {\r\n    animation: fadeIn 0.5s ease-out;\r\n  }\r\n  \r\n  .fade-out {\r\n    animation: fadeOut 0.3s ease-in;\r\n  }\r\n  \r\n  .slide-in {\r\n    animation: slideIn 0.4s ease-out;\r\n  }\r\n  \r\n  .bounce {\r\n    animation: bounce 0.6s ease-out;\r\n  }\r\n  \r\n  .shake {\r\n    animation: shake 0.5s ease-in-out;\r\n  }\r\n  \r\n  .pulse {\r\n    animation: pulse 1s infinite;\r\n  }\r\n  \r\n  @keyframes pulse {\r\n    0% { transform: scale(1); }\r\n    50% { transform: scale(1.05); }\r\n    100% { transform: scale(1); }\r\n  }\r\n`;\r\n\r\n// 스타일 적용\r\nconst styleSheet = document.createElement('style');\r\nstyleSheet.textContent = animationCSS;\r\ndocument.head.appendChild(styleSheet);\r\n\r\n// 2. 애니메이션 유틸리티 클래스\r\nclass AnimationUtils {\r\n  static async fadeIn(element, duration = 500) {\r\n    element.style.transition = `opacity ${duration}ms ease-out`;\r\n    element.style.opacity = '0';\r\n    \r\n    // DOM에 변경사항 적용 대기\r\n    await new Promise(resolve => requestAnimationFrame(resolve));\r\n    \r\n    element.style.opacity = '1';\r\n    \r\n    return new Promise(resolve => {\r\n      setTimeout(resolve, duration);\r\n    });\r\n  }\r\n  \r\n  static async fadeOut(element, duration = 300) {\r\n    element.style.transition = `opacity ${duration}ms ease-in`;\r\n    element.style.opacity = '1';\r\n    \r\n    await new Promise(resolve => requestAnimationFrame(resolve));\r\n    \r\n    element.style.opacity = '0';\r\n    \r\n    return new Promise(resolve => {\r\n      setTimeout(() => {\r\n        element.style.display = 'none';\r\n        resolve();\r\n      }, duration);\r\n    });\r\n  }\r\n  \r\n  static async slideDown(element, duration = 400) {\r\n    const height = element.scrollHeight;\r\n    element.style.transition = `height ${duration}ms ease-out`;\r\n    element.style.height = '0px';\r\n    element.style.overflow = 'hidden';\r\n    \r\n    await new Promise(resolve => requestAnimationFrame(resolve));\r\n    \r\n    element.style.height = height + 'px';\r\n    \r\n    return new Promise(resolve => {\r\n      setTimeout(() => {\r\n        element.style.height = '';\r\n        element.style.overflow = '';\r\n        resolve();\r\n      }, duration);\r\n    });\r\n  }\r\n  \r\n  static async slideUp(element, duration = 400) {\r\n    const height = element.scrollHeight;\r\n    element.style.transition = `height ${duration}ms ease-in`;\r\n    element.style.height = height + 'px';\r\n    element.style.overflow = 'hidden';\r\n    \r\n    await new Promise(resolve => requestAnimationFrame(resolve));\r\n    \r\n    element.style.height = '0px';\r\n    \r\n    return new Promise(resolve => {\r\n      setTimeout(() => {\r\n        element.style.display = 'none';\r\n        resolve();\r\n      }, duration);\r\n    });\r\n  }\r\n  \r\n  // 탄성 효과\r\n  static bounce(element) {\r\n    element.classList.add('bounce');\r\n    setTimeout(() => {\r\n      element.classList.remove('bounce');\r\n    }, 600);\r\n  }\r\n  \r\n  // 흔들기 효과\r\n  static shake(element) {\r\n    element.classList.add('shake');\r\n    setTimeout(() => {\r\n      element.classList.remove('shake');\r\n    }, 500);\r\n  }\r\n  \r\n  // 맥박 효과 시작/중지\r\n  static startPulse(element) {\r\n    element.classList.add('pulse');\r\n  }\r\n  \r\n  static stopPulse(element) {\r\n    element.classList.remove('pulse');\r\n  }\r\n}\r\n```\r\n\r\n## 🛠️ 실습 프로젝트: 개선된 애니메이션 할일 앱\r\n\r\n이벤트 위임과 애니메이션을 적용해서 할일 앱을 업그레이드했다!\r\n\r\n```javascript\r\n// 개선된 할일 관리 앱\r\nclass AnimatedTodoApp {\r\n  constructor() {\r\n    this.todos = [];\r\n    this.todoId = 1;\r\n    this.currentFilter = 'all';\r\n    this.init();\r\n  }\r\n  \r\n  init() {\r\n    this.createHTML();\r\n    this.setupEventDelegation();\r\n    this.loadFromStorage();\r\n  }\r\n  \r\n  createHTML() {\r\n    document.body.innerHTML = `\r\n      <div class=\"animated-todo-app\">\r\n        <header class=\"app-header\">\r\n          <h1>✨ 애니메이션 할일 관리</h1>\r\n          <div class=\"date-display\">${new Date().toLocaleDateString('ko-KR')}</div>\r\n        </header>\r\n        \r\n        <div class=\"input-section\">\r\n          <div class=\"input-wrapper\">\r\n            <input \r\n              type=\"text\" \r\n              id=\"todo-input\" \r\n              placeholder=\"할일을 입력하세요... ✍️\"\r\n              maxlength=\"100\"\r\n            >\r\n            <button id=\"add-btn\">\r\n              <span>추가</span>\r\n              <div class=\"btn-effect\"></div>\r\n            </button>\r\n          </div>\r\n          <div class=\"input-counter\">\r\n            <span id=\"char-count\">0</span>/100\r\n          </div>\r\n        </div>\r\n        \r\n        <div class=\"stats-section\">\r\n          <div class=\"stat-card\">\r\n            <div class=\"stat-number\" id=\"total-count\">0</div>\r\n            <div class=\"stat-label\">전체</div>\r\n          </div>\r\n          <div class=\"stat-card\">\r\n            <div class=\"stat-number\" id=\"completed-count\">0</div>\r\n            <div class=\"stat-label\">완료</div>\r\n          </div>\r\n          <div class=\"stat-card\">\r\n            <div class=\"stat-number\" id=\"remaining-count\">0</div>\r\n            <div class=\"stat-label\">남은 할일</div>\r\n          </div>\r\n        </div>\r\n        \r\n        <div class=\"filter-section\">\r\n          <button class=\"filter-btn active\" data-filter=\"all\">\r\n            전체 <span class=\"filter-count\" id=\"all-count\">0</span>\r\n          </button>\r\n          <button class=\"filter-btn\" data-filter=\"active\">\r\n            진행중 <span class=\"filter-count\" id=\"active-count\">0</span>\r\n          </button>\r\n          <button class=\"filter-btn\" data-filter=\"completed\">\r\n            완료 <span class=\"filter-count\" id=\"completed-filter-count\">0</span>\r\n          </button>\r\n        </div>\r\n        \r\n        <div class=\"todo-container\">\r\n          <ul id=\"todo-list\"></ul>\r\n          <div class=\"empty-state\" id=\"empty-state\">\r\n            <div class=\"empty-icon\">📝</div>\r\n            <div class=\"empty-text\">할일을 추가해보세요!</div>\r\n          </div>\r\n        </div>\r\n        \r\n        <div class=\"actions-section\">\r\n          <button id=\"clear-completed\" class=\"action-btn danger\">\r\n            🗑️ 완료된 항목 삭제\r\n          </button>\r\n          <button id=\"clear-all\" class=\"action-btn warning\">\r\n            🔄 모두 삭제\r\n          </button>\r\n        </div>\r\n      </div>\r\n    `;\r\n    \r\n    this.addAdvancedStyles();\r\n  }\r\n  \r\n  addAdvancedStyles() {\r\n    const style = document.createElement('style');\r\n    style.textContent = `\r\n      * {\r\n        box-sizing: border-box;\r\n      }\r\n      \r\n      body {\r\n        margin: 0;\r\n        padding: 20px;\r\n        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n        min-height: 100vh;\r\n        font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;\r\n      }\r\n      \r\n      .animated-todo-app {\r\n        max-width: 700px;\r\n        margin: 0 auto;\r\n        background: rgba(255, 255, 255, 0.95);\r\n        border-radius: 20px;\r\n        padding: 30px;\r\n        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);\r\n        backdrop-filter: blur(10px);\r\n      }\r\n      \r\n      .app-header {\r\n        text-align: center;\r\n        margin-bottom: 30px;\r\n      }\r\n      \r\n      .app-header h1 {\r\n        margin: 0 0 10px 0;\r\n        font-size: 2.5em;\r\n        background: linear-gradient(45deg, #667eea, #764ba2);\r\n        -webkit-background-clip: text;\r\n        -webkit-text-fill-color: transparent;\r\n        background-clip: text;\r\n      }\r\n      \r\n      .date-display {\r\n        color: #666;\r\n        font-size: 1.1em;\r\n      }\r\n      \r\n      .input-section {\r\n        margin-bottom: 30px;\r\n      }\r\n      \r\n      .input-wrapper {\r\n        display: flex;\r\n        gap: 15px;\r\n        margin-bottom: 10px;\r\n      }\r\n      \r\n      #todo-input {\r\n        flex: 1;\r\n        padding: 15px 20px;\r\n        border: 2px solid #e1e8ed;\r\n        border-radius: 15px;\r\n        font-size: 16px;\r\n        background: white;\r\n        transition: all 0.3s ease;\r\n      }\r\n      \r\n      #todo-input:focus {\r\n        outline: none;\r\n        border-color: #667eea;\r\n        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);\r\n        transform: translateY(-2px);\r\n      }\r\n      \r\n      #add-btn {\r\n        position: relative;\r\n        padding: 15px 30px;\r\n        background: linear-gradient(45deg, #667eea, #764ba2);\r\n        color: white;\r\n        border: none;\r\n        border-radius: 15px;\r\n        cursor: pointer;\r\n        font-size: 16px;\r\n        font-weight: 600;\r\n        overflow: hidden;\r\n        transition: all 0.3s ease;\r\n      }\r\n      \r\n      #add-btn:hover {\r\n        transform: translateY(-2px);\r\n        box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);\r\n      }\r\n      \r\n      #add-btn:active {\r\n        transform: translateY(0);\r\n      }\r\n      \r\n      .btn-effect {\r\n        position: absolute;\r\n        top: 50%;\r\n        left: 50%;\r\n        width: 0;\r\n        height: 0;\r\n        background: rgba(255, 255, 255, 0.3);\r\n        border-radius: 50%;\r\n        transform: translate(-50%, -50%);\r\n        transition: all 0.5s ease;\r\n      }\r\n      \r\n      #add-btn:active .btn-effect {\r\n        width: 200px;\r\n        height: 200px;\r\n      }\r\n      \r\n      .input-counter {\r\n        text-align: right;\r\n        color: #999;\r\n        font-size: 0.9em;\r\n      }\r\n      \r\n      .stats-section {\r\n        display: grid;\r\n        grid-template-columns: repeat(3, 1fr);\r\n        gap: 15px;\r\n        margin-bottom: 25px;\r\n      }\r\n      \r\n      .stat-card {\r\n        background: white;\r\n        padding: 20px;\r\n        border-radius: 15px;\r\n        text-align: center;\r\n        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);\r\n        transition: all 0.3s ease;\r\n      }\r\n      \r\n      .stat-card:hover {\r\n        transform: translateY(-5px);\r\n        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);\r\n      }\r\n      \r\n      .stat-number {\r\n        font-size: 2em;\r\n        font-weight: bold;\r\n        color: #667eea;\r\n        margin-bottom: 5px;\r\n      }\r\n      \r\n      .stat-label {\r\n        color: #666;\r\n        font-size: 0.9em;\r\n      }\r\n      \r\n      .filter-section {\r\n        display: flex;\r\n        gap: 10px;\r\n        margin-bottom: 25px;\r\n      }\r\n      \r\n      .filter-btn {\r\n        flex: 1;\r\n        padding: 12px 20px;\r\n        background: white;\r\n        border: 2px solid #e1e8ed;\r\n        border-radius: 12px;\r\n        cursor: pointer;\r\n        transition: all 0.3s ease;\r\n        font-size: 14px;\r\n        display: flex;\r\n        justify-content: space-between;\r\n        align-items: center;\r\n      }\r\n      \r\n      .filter-btn:hover {\r\n        border-color: #667eea;\r\n        transform: translateY(-2px);\r\n      }\r\n      \r\n      .filter-btn.active {\r\n        background: linear-gradient(45deg, #667eea, #764ba2);\r\n        color: white;\r\n        border-color: transparent;\r\n      }\r\n      \r\n      .filter-count {\r\n        background: rgba(255, 255, 255, 0.2);\r\n        padding: 2px 8px;\r\n        border-radius: 10px;\r\n        font-size: 12px;\r\n      }\r\n      \r\n      .filter-btn.active .filter-count {\r\n        background: rgba(255, 255, 255, 0.3);\r\n      }\r\n      \r\n      .todo-container {\r\n        position: relative;\r\n        min-height: 200px;\r\n      }\r\n      \r\n      #todo-list {\r\n        list-style: none;\r\n        padding: 0;\r\n        margin: 0;\r\n      }\r\n      \r\n      .todo-item {\r\n        display: flex;\r\n        align-items: center;\r\n        padding: 20px;\r\n        margin-bottom: 15px;\r\n        background: white;\r\n        border-radius: 15px;\r\n        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);\r\n        border-left: 5px solid #667eea;\r\n        transition: all 0.3s ease;\r\n        animation: slideInFromRight 0.5s ease-out;\r\n      }\r\n      \r\n      @keyframes slideInFromRight {\r\n        from {\r\n          opacity: 0;\r\n          transform: translateX(50px);\r\n        }\r\n        to {\r\n          opacity: 1;\r\n          transform: translateX(0);\r\n        }\r\n      }\r\n      \r\n      .todo-item:hover {\r\n        transform: translateX(5px);\r\n        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);\r\n      }\r\n      \r\n      .todo-item.completed {\r\n        opacity: 0.7;\r\n        border-left-color: #28a745;\r\n      }\r\n      \r\n      .todo-item.completed .todo-text {\r\n        text-decoration: line-through;\r\n        color: #999;\r\n      }\r\n      \r\n      .todo-item.removing {\r\n        animation: slideOutToLeft 0.3s ease-in forwards;\r\n      }\r\n      \r\n      @keyframes slideOutToLeft {\r\n        to {\r\n          opacity: 0;\r\n          transform: translateX(-100%);\r\n        }\r\n      }\r\n      \r\n      .todo-checkbox {\r\n        margin-right: 20px;\r\n        width: 20px;\r\n        height: 20px;\r\n        cursor: pointer;\r\n      }\r\n      \r\n      .todo-text {\r\n        flex: 1;\r\n        font-size: 16px;\r\n        word-break: break-word;\r\n      }\r\n      \r\n      .todo-actions {\r\n        display: flex;\r\n        gap: 10px;\r\n      }\r\n      \r\n      .todo-btn {\r\n        padding: 8px 12px;\r\n        border: none;\r\n        border-radius: 8px;\r\n        cursor: pointer;\r\n        font-size: 12px;\r\n        transition: all 0.3s ease;\r\n      }\r\n      \r\n      .edit-btn {\r\n        background: #17a2b8;\r\n        color: white;\r\n      }\r\n      \r\n      .edit-btn:hover {\r\n        background: #138496;\r\n        transform: scale(1.05);\r\n      }\r\n      \r\n      .delete-btn {\r\n        background: #dc3545;\r\n        color: white;\r\n      }\r\n      \r\n      .delete-btn:hover {\r\n        background: #c82333;\r\n        transform: scale(1.05);\r\n      }\r\n      \r\n      .empty-state {\r\n        position: absolute;\r\n        top: 50%;\r\n        left: 50%;\r\n        transform: translate(-50%, -50%);\r\n        text-align: center;\r\n        color: #999;\r\n        display: none;\r\n      }\r\n      \r\n      .empty-state.show {\r\n        display: block;\r\n        animation: fadeIn 0.5s ease-out;\r\n      }\r\n      \r\n      .empty-icon {\r\n        font-size: 4em;\r\n        margin-bottom: 20px;\r\n      }\r\n      \r\n      .empty-text {\r\n        font-size: 1.2em;\r\n      }\r\n      \r\n      .actions-section {\r\n        display: flex;\r\n        gap: 15px;\r\n        margin-top: 30px;\r\n      }\r\n      \r\n      .action-btn {\r\n        flex: 1;\r\n        padding: 15px;\r\n        border: none;\r\n        border-radius: 12px;\r\n        cursor: pointer;\r\n        font-size: 14px;\r\n        font-weight: 600;\r\n        transition: all 0.3s ease;\r\n      }\r\n      \r\n      .action-btn.danger {\r\n        background: #dc3545;\r\n        color: white;\r\n      }\r\n      \r\n      .action-btn.danger:hover {\r\n        background: #c82333;\r\n        transform: translateY(-2px);\r\n      }\r\n      \r\n      .action-btn.warning {\r\n        background: #ffc107;\r\n        color: #333;\r\n      }\r\n      \r\n      .action-btn.warning:hover {\r\n        background: #e0a800;\r\n        transform: translateY(-2px);\r\n      }\r\n      \r\n      @keyframes fadeIn {\r\n        from { opacity: 0; }\r\n        to { opacity: 1; }\r\n      }\r\n      \r\n      @keyframes bounce {\r\n        0%, 20%, 50%, 80%, 100% { transform: translateY(0); }\r\n        40% { transform: translateY(-10px); }\r\n        60% { transform: translateY(-5px); }\r\n      }\r\n      \r\n      .bounce {\r\n        animation: bounce 0.6s ease-out;\r\n      }\r\n      \r\n      @keyframes shake {\r\n        0%, 100% { transform: translateX(0); }\r\n        10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }\r\n        20%, 40%, 60%, 80% { transform: translateX(5px); }\r\n      }\r\n      \r\n      .shake {\r\n        animation: shake 0.5s ease-in-out;\r\n      }\r\n    `;\r\n    document.head.appendChild(style);\r\n  }\r\n  \r\n  setupEventDelegation() {\r\n    const app = document.querySelector('.animated-todo-app');\r\n    \r\n    // 이벤트 위임으로 모든 클릭 이벤트 처리\r\n    app.addEventListener('click', (e) => {\r\n      if (e.target.id === 'add-btn') {\r\n        this.addTodo();\r\n      } else if (e.target.classList.contains('filter-btn')) {\r\n        this.setFilter(e.target.dataset.filter, e.target);\r\n      } else if (e.target.classList.contains('delete-btn')) {\r\n        this.deleteTodo(parseInt(e.target.dataset.id));\r\n      } else if (e.target.classList.contains('edit-btn')) {\r\n        this.editTodo(parseInt(e.target.dataset.id));\r\n      } else if (e.target.id === 'clear-completed') {\r\n        this.clearCompleted();\r\n      } else if (e.target.id === 'clear-all') {\r\n        this.clearAll();\r\n      }\r\n    });\r\n    \r\n    // 체크박스 변경 이벤트\r\n    app.addEventListener('change', (e) => {\r\n      if (e.target.classList.contains('todo-checkbox')) {\r\n        this.toggleTodo(parseInt(e.target.dataset.id));\r\n      }\r\n    });\r\n    \r\n    // 입력 필드 이벤트\r\n    const todoInput = document.getElementById('todo-input');\r\n    todoInput.addEventListener('input', (e) => {\r\n      this.updateCharCount(e.target.value.length);\r\n    });\r\n    \r\n    todoInput.addEventListener('keypress', (e) => {\r\n      if (e.key === 'Enter') {\r\n        this.addTodo();\r\n      }\r\n    });\r\n  }\r\n  \r\n  async addTodo() {\r\n    const input = document.getElementById('todo-input');\r\n    const text = input.value.trim();\r\n    \r\n    if (text === '') {\r\n      AnimationUtils.shake(input);\r\n      return;\r\n    }\r\n    \r\n    const todo = {\r\n      id: this.todoId++,\r\n      text: text,\r\n      completed: false,\r\n      createdAt: new Date().toLocaleString()\r\n    };\r\n    \r\n    this.todos.push(todo);\r\n    input.value = '';\r\n    this.updateCharCount(0);\r\n    \r\n    // 성공 애니메이션\r\n    const addBtn = document.getElementById('add-btn');\r\n    AnimationUtils.bounce(addBtn);\r\n    \r\n    await this.renderTodos();\r\n    this.updateStats();\r\n    this.saveToStorage();\r\n  }\r\n  \r\n  async deleteTodo(id) {\r\n    const todoElement = document.querySelector(`[data-id=\"${id}\"]`).closest('.todo-item');\r\n    \r\n    // 삭제 애니메이션\r\n    todoElement.classList.add('removing');\r\n    \r\n    // 애니메이션 완료 후 실제 삭제\r\n    setTimeout(() => {\r\n      this.todos = this.todos.filter(t => t.id !== id);\r\n      this.renderTodos();\r\n      this.updateStats();\r\n      this.saveToStorage();\r\n    }, 300);\r\n  }\r\n  \r\n  toggleTodo(id) {\r\n    const todo = this.todos.find(t => t.id === id);\r\n    if (todo) {\r\n      todo.completed = !todo.completed;\r\n      \r\n      // 완료 애니메이션\r\n      const todoElement = document.querySelector(`[data-id=\"${id}\"]`).closest('.todo-item');\r\n      if (todo.completed) {\r\n        AnimationUtils.bounce(todoElement);\r\n      }\r\n      \r\n      this.renderTodos();\r\n      this.updateStats();\r\n      this.saveToStorage();\r\n    }\r\n  }\r\n  \r\n  async renderTodos() {\r\n    const todoList = document.getElementById('todo-list');\r\n    const emptyState = document.getElementById('empty-state');\r\n    \r\n    const filteredTodos = this.getFilteredTodos();\r\n    \r\n    if (filteredTodos.length === 0) {\r\n      todoList.innerHTML = '';\r\n      emptyState.classList.add('show');\r\n      return;\r\n    } else {\r\n      emptyState.classList.remove('show');\r\n    }\r\n    \r\n    todoList.innerHTML = filteredTodos.map(todo => `\r\n      <li class=\"todo-item ${todo.completed ? 'completed' : ''}\">\r\n        <input \r\n          type=\"checkbox\" \r\n          class=\"todo-checkbox\" \r\n          ${todo.completed ? 'checked' : ''}\r\n          data-id=\"${todo.id}\"\r\n        >\r\n        <span class=\"todo-text\">${todo.text}</span>\r\n        <div class=\"todo-actions\">\r\n          <button class=\"todo-btn edit-btn\" data-id=\"${todo.id}\">수정</button>\r\n          <button class=\"todo-btn delete-btn\" data-id=\"${todo.id}\">삭제</button>\r\n        </div>\r\n      </li>\r\n    `).join('');\r\n  }\r\n  \r\n  getFilteredTodos() {\r\n    switch(this.currentFilter) {\r\n      case 'active':\r\n        return this.todos.filter(t => !t.completed);\r\n      case 'completed':\r\n        return this.todos.filter(t => t.completed);\r\n      default:\r\n        return this.todos;\r\n    }\r\n  }\r\n  \r\n  setFilter(filter, buttonElement) {\r\n    this.currentFilter = filter;\r\n    \r\n    // 필터 버튼 활성화 상태 변경\r\n    document.querySelectorAll('.filter-btn').forEach(btn => {\r\n      btn.classList.remove('active');\r\n    });\r\n    buttonElement.classList.add('active');\r\n    \r\n    this.renderTodos();\r\n  }\r\n  \r\n  updateStats() {\r\n    const total = this.todos.length;\r\n    const completed = this.todos.filter(t => t.completed).length;\r\n    const remaining = total - completed;\r\n    \r\n    // 애니메이션과 함께 숫자 업데이트\r\n    this.animateCounter('total-count', total);\r\n    this.animateCounter('completed-count', completed);\r\n    this.animateCounter('remaining-count', remaining);\r\n    \r\n    // 필터 카운트 업데이트\r\n    document.getElementById('all-count').textContent = total;\r\n    document.getElementById('active-count').textContent = remaining;\r\n    document.getElementById('completed-filter-count').textContent = completed;\r\n  }\r\n  \r\n  animateCounter(elementId, targetValue) {\r\n    const element = document.getElementById(elementId);\r\n    const currentValue = parseInt(element.textContent) || 0;\r\n    const difference = targetValue - currentValue;\r\n    const increment = difference > 0 ? 1 : -1;\r\n    const steps = Math.abs(difference);\r\n    \r\n    if (steps === 0) return;\r\n    \r\n    let step = 0;\r\n    const timer = setInterval(() => {\r\n      step++;\r\n      const newValue = currentValue + (increment * step);\r\n      element.textContent = newValue;\r\n      \r\n      if (step >= steps) {\r\n        clearInterval(timer);\r\n        // 변경 완료 시 살짝 강조 효과\r\n        element.style.transform = 'scale(1.1)';\r\n        setTimeout(() => {\r\n          element.style.transform = 'scale(1)';\r\n        }, 200);\r\n      }\r\n    }, 50);\r\n  }\r\n  \r\n  updateCharCount(length) {\r\n    const charCount = document.getElementById('char-count');\r\n    charCount.textContent = length;\r\n    \r\n    // 글자 수에 따른 색상 변경\r\n    if (length > 80) {\r\n      charCount.style.color = '#dc3545';\r\n    } else if (length > 60) {\r\n      charCount.style.color = '#ffc107';\r\n    } else {\r\n      charCount.style.color = '#999';\r\n    }\r\n  }\r\n  \r\n  clearCompleted() {\r\n    const completedCount = this.todos.filter(t => t.completed).length;\r\n    if (completedCount === 0) {\r\n      const button = document.getElementById('clear-completed');\r\n      AnimationUtils.shake(button);\r\n      return;\r\n    }\r\n    \r\n    this.todos = this.todos.filter(t => !t.completed);\r\n    this.renderTodos();\r\n    this.updateStats();\r\n    this.saveToStorage();\r\n  }\r\n  \r\n  clearAll() {\r\n    if (this.todos.length === 0) {\r\n      const button = document.getElementById('clear-all');\r\n      AnimationUtils.shake(button);\r\n      return;\r\n    }\r\n    \r\n    if (confirm('정말 모든 할일을 삭제하시겠습니까?')) {\r\n      this.todos = [];\r\n      this.renderTodos();\r\n      this.updateStats();\r\n      this.saveToStorage();\r\n    }\r\n  }\r\n  \r\n  saveToStorage() {\r\n    localStorage.setItem('animatedTodos', JSON.stringify(this.todos));\r\n    localStorage.setItem('animatedTodoId', this.todoId.toString());\r\n  }\r\n  \r\n  loadFromStorage() {\r\n    const savedTodos = localStorage.getItem('animatedTodos');\r\n    const savedId = localStorage.getItem('animatedTodoId');\r\n    \r\n    if (savedTodos) {\r\n      this.todos = JSON.parse(savedTodos);\r\n    }\r\n    \r\n    if (savedId) {\r\n      this.todoId = parseInt(savedId);\r\n    }\r\n    \r\n    this.renderTodos();\r\n    this.updateStats();\r\n  }\r\n}\r\n\r\n// 앱 실행\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  const app = new AnimatedTodoApp();\r\n  console.log('애니메이션 할일 앱이 실행되었습니다! ✨');\r\n});\r\n```\r\n\r\n## 🎯 오늘 배운 핵심 개념들\r\n\r\n### 1. 이벤트 위임의 장점\r\n- **성능 향상**: 하나의 리스너로 여러 요소 처리\r\n- **동적 요소 지원**: 새로 추가된 요소에도 자동 적용\r\n- **메모리 효율성**: 이벤트 리스너 수 최소화\r\n- **코드 간소화**: 중앙집중식 이벤트 관리\r\n\r\n### 2. 애니메이션 제어 기법\r\n- **CSS 클래스 토글**: 간단하고 효과적\r\n- **JavaScript 애니메이션**: 더 정밀한 제어 가능\r\n- **Promise 기반**: 애니메이션 완료 시점 감지\r\n- **성능 최적화**: `requestAnimationFrame` 활용\r\n\r\n### 3. 사용자 경험 개선\r\n- **즉각적인 피드백**: 버튼 클릭, 입력 등에 즉시 반응\r\n- **시각적 계층**: 중요도에 따른 애니메이션 차별화\r\n- **일관성**: 모든 인터랙션에 통일된 애니메이션 패턴\r\n\r\n## 💭 오늘의 깨달음\r\n\r\n이벤트 위임을 배우고 나니 어제 작성했던 코드가 얼마나 비효율적이었는지 깨달았다! 각 버튼마다 일일이 이벤트 리스너를 달았는데, 부모 요소 하나에만 달면 모든 자식 요소의 이벤트를 처리할 수 있다니... 이게 바로 프로그래밍의 매력이구나! 🤯\r\n\r\n그리고 애니메이션을 추가하니까 앱이 완전히 다른 느낌이 되었다. 단순히 기능만 있는 것이 아니라, 사용자가 실제로 쓰고 싶어지는 앱이 된 것 같다. 버튼을 클릭할 때마다 살짝 튀어오르고, 할일을 완료하면 체크 애니메이션이 나오고, 삭제할 때는 부드럽게 사라지는 모습을 보니 정말 신기했다! ✨\r\n\r\n내일은 Fetch API를 배워서 실제 서버와 데이터를 주고받는 방법을 익혀볼 예정이다. 점점 진짜 웹 개발자가 되어가는 기분이다! 🚀\r\n\r\n---\r\n\r\n**\"사용자 경험의 마법은 바로 이런 작은 디테일에서 나온다!\"** 🎨💫 "
    },
    {
      "id": "2025-06-01-auto-generated",
      "title": "6월의 시작, DOM 조작으로 살아 숨쉬는 웹페이지 만들기! 🚀",
      "date": "2025-06-01",
      "category": "daily",
      "tags": [
        "container",
        "main",
        "profile",
        "007bff",
        "click",
        "hover",
        "f0f0f0",
        "name",
        "char",
        "login",
        "username",
        "password",
        "333",
        "todo",
        "ddd",
        "todo",
        "007bff",
        "007bff",
        "0056b3",
        "f8f9fa",
        "6c757d",
        "007bff",
        "todo",
        "f8f9fa",
        "007bff",
        "28a745",
        "dc3545",
        "6c757d"
      ],
      "image": "https://images.unsplash.com/photo-1484417894907-623942c8ee29?w=400&h=200&fit=crop",
      "description": "2025-06-01의 학습 내용 정리",
      "excerpt": "드디어 6월이 시작되었다! 5월에 JavaScript 기초를 탄탄히 다졌으니, 이제 본격적으로 웹페이지를 살아있게 만드는 방법을 배워보자. 오늘은 DOM(Document Objec...",
      "content": "# 6월의 시작, DOM 조작으로 살아 숨쉬는 웹페이지 만들기! 🚀\r\n\r\n드디어 6월이 시작되었다! 5월에 JavaScript 기초를 탄탄히 다졌으니, 이제 본격적으로 웹페이지를 살아있게 만드는 방법을 배워보자. 오늘은 DOM(Document Object Model) 조작과 이벤트 처리에 대해 깊이 있게 공부했다. 정말 신기했던 것은 JavaScript로 HTML 요소들을 마음대로 조작할 수 있다는 것이었다!\r\n\r\n## 🎯 오늘의 핵심 학습: DOM 조작 마스터하기\r\n\r\n### DOM이란 무엇인가?\r\n\r\n```javascript\r\n// DOM은 웹페이지를 구조화해서 JavaScript가 접근할 수 있게 해주는 인터페이스!\r\n// HTML 문서의 모든 요소를 객체로 만들어서 조작할 수 있게 해준다\r\n\r\nconsole.log('DOM 트리 구조 이해하기');\r\nconsole.log('document -> html -> head/body -> 각종 태그들');\r\n\r\n// 전체 문서 객체\r\nconsole.log(document);\r\n\r\n// 문서의 루트 요소 (html 태그)\r\nconsole.log(document.documentElement);\r\n\r\n// body 요소\r\nconsole.log(document.body);\r\n\r\n// 제목 요소\r\nconsole.log(document.title);\r\n```\r\n\r\n### 요소 선택하는 다양한 방법들\r\n\r\n```javascript\r\n// 1. ID로 선택하기\r\nconst mainTitle = document.getElementById('main-title');\r\nconsole.log('ID로 선택한 요소:', mainTitle);\r\n\r\n// 2. 클래스로 선택하기\r\nconst buttons = document.getElementsByClassName('btn');\r\nconsole.log('클래스로 선택한 요소들:', buttons); // HTMLCollection 반환\r\n\r\n// 3. 태그명으로 선택하기\r\nconst allParagraphs = document.getElementsByTagName('p');\r\nconsole.log('모든 p 태그:', allParagraphs);\r\n\r\n// 4. CSS 선택자 사용하기 (가장 강력하고 유연함!)\r\nconst firstButton = document.querySelector('.btn');\r\nconst allButtons = document.querySelectorAll('.btn');\r\n\r\nconsole.log('첫 번째 버튼:', firstButton);\r\nconsole.log('모든 버튼들:', allButtons); // NodeList 반환\r\n\r\n// 복잡한 선택자도 가능!\r\nconst specificElement = document.querySelector('#container .content > p:first-child');\r\nconsole.log('복잡한 선택자로 찾은 요소:', specificElement);\r\n\r\n// 실습용 HTML 구조를 상상해보자\r\n/*\r\n<div id=\"container\">\r\n  <h1 id=\"main-title\">제목</h1>\r\n  <div class=\"content\">\r\n    <p>첫 번째 문단</p>\r\n    <p>두 번째 문단</p>\r\n    <button class=\"btn primary\">버튼 1</button>\r\n    <button class=\"btn secondary\">버튼 2</button>\r\n  </div>\r\n</div>\r\n*/\r\n```\r\n\r\n### 요소 내용과 속성 조작하기\r\n\r\n```javascript\r\n// HTML 요소의 내용 변경하기\r\nconst titleElement = document.querySelector('#main-title');\r\n\r\n// 텍스트만 변경\r\ntitleElement.textContent = '새로운 제목입니다!';\r\n\r\n// HTML 태그까지 포함해서 변경\r\ntitleElement.innerHTML = '<span style=\"color: blue;\">파란색 제목</span>';\r\n\r\n// 속성 조작하기\r\nconst imageElement = document.querySelector('#profile-image');\r\n\r\n// 속성 가져오기\r\nconst currentSrc = imageElement.getAttribute('src');\r\nconsole.log('현재 이미지 경로:', currentSrc);\r\n\r\n// 속성 설정하기\r\nimageElement.setAttribute('src', '/images/new-profile.jpg');\r\nimageElement.setAttribute('alt', '새로운 프로필 이미지');\r\n\r\n// 속성 제거하기\r\nimageElement.removeAttribute('title');\r\n\r\n// data 속성 사용하기 (HTML5의 강력한 기능!)\r\nconst userCard = document.querySelector('.user-card');\r\nuserCard.dataset.userId = '12345';\r\nuserCard.dataset.userName = 'stylechoi';\r\n\r\nconsole.log('사용자 ID:', userCard.dataset.userId);\r\nconsole.log('사용자 이름:', userCard.dataset.userName);\r\n\r\n// 클래스 조작하기\r\nconst button = document.querySelector('.btn');\r\n\r\n// 클래스 추가\r\nbutton.classList.add('active', 'highlighted');\r\n\r\n// 클래스 제거\r\nbutton.classList.remove('secondary');\r\n\r\n// 클래스 토글 (있으면 제거, 없으면 추가)\r\nbutton.classList.toggle('pressed');\r\n\r\n// 클래스 확인\r\nif (button.classList.contains('active')) {\r\n  console.log('버튼이 활성화 상태입니다!');\r\n}\r\n\r\n// 스타일 직접 변경하기\r\nbutton.style.backgroundColor = '#007bff';\r\nbutton.style.color = 'white';\r\nbutton.style.border = 'none';\r\nbutton.style.borderRadius = '5px';\r\nbutton.style.padding = '10px 20px';\r\nbutton.style.cursor = 'pointer';\r\n```\r\n\r\n### 이벤트 처리의 세계\r\n\r\n```javascript\r\n// 1. 기본적인 이벤트 리스너\r\nconst clickButton = document.querySelector('#click-me');\r\n\r\nclickButton.addEventListener('click', function() {\r\n  console.log('버튼이 클릭되었습니다!');\r\n  alert('안녕하세요! 😊');\r\n});\r\n\r\n// 2. 화살표 함수로 더 간결하게\r\nconst hoverButton = document.querySelector('#hover-me');\r\n\r\nhoverButton.addEventListener('mouseenter', () => {\r\n  hoverButton.style.backgroundColor = '#f0f0f0';\r\n  hoverButton.textContent = '마우스가 올라왔어요!';\r\n});\r\n\r\nhoverButton.addEventListener('mouseleave', () => {\r\n  hoverButton.style.backgroundColor = '';\r\n  hoverButton.textContent = '마우스를 올려보세요';\r\n});\r\n\r\n// 3. 이벤트 객체 활용하기\r\nconst inputField = document.querySelector('#name-input');\r\n\r\ninputField.addEventListener('input', (event) => {\r\n  console.log('입력된 값:', event.target.value);\r\n  console.log('이벤트 타입:', event.type);\r\n  \r\n  // 실시간으로 글자 수 표시\r\n  const charCount = event.target.value.length;\r\n  const counterElement = document.querySelector('#char-counter');\r\n  counterElement.textContent = `${charCount}/100`;\r\n});\r\n\r\n// 4. 폼 이벤트 처리\r\nconst loginForm = document.querySelector('#login-form');\r\n\r\nloginForm.addEventListener('submit', (event) => {\r\n  event.preventDefault(); // 기본 제출 동작 방지\r\n  \r\n  const username = document.querySelector('#username').value;\r\n  const password = document.querySelector('#password').value;\r\n  \r\n  if (username.trim() === '' || password.trim() === '') {\r\n    alert('아이디와 비밀번호를 모두 입력해주세요!');\r\n    return;\r\n  }\r\n  \r\n  console.log('로그인 시도:', { username, password });\r\n  alert(`${username}님, 환영합니다!`);\r\n});\r\n\r\n// 5. 키보드 이벤트\r\ndocument.addEventListener('keydown', (event) => {\r\n  console.log('누른 키:', event.key);\r\n  console.log('키 코드:', event.code);\r\n  \r\n  // 특정 키 조합 감지\r\n  if (event.ctrlKey && event.key === 's') {\r\n    event.preventDefault();\r\n    console.log('저장 단축키가 눌렸습니다!');\r\n    alert('저장되었습니다! (가상)');\r\n  }\r\n  \r\n  // ESC 키로 모달 닫기\r\n  if (event.key === 'Escape') {\r\n    const modal = document.querySelector('.modal');\r\n    if (modal) {\r\n      modal.style.display = 'none';\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n## 🛠️ 실습 프로젝트: 동적 할일 관리 앱\r\n\r\n오늘 배운 DOM 조작과 이벤트 처리를 활용해서 실제로 사용할 수 있는 할일 관리 앱을 만들어봤다!\r\n\r\n```javascript\r\n// 할일 관리 앱 클래스\r\nclass TodoApp {\r\n  constructor() {\r\n    this.todos = [];\r\n    this.todoId = 1;\r\n    this.init();\r\n  }\r\n  \r\n  init() {\r\n    this.createHTML();\r\n    this.bindEvents();\r\n    this.loadFromStorage();\r\n  }\r\n  \r\n  createHTML() {\r\n    document.body.innerHTML = `\r\n      <div class=\"todo-app\">\r\n        <h1>📝 나의 할일 관리</h1>\r\n        \r\n        <div class=\"input-section\">\r\n          <input \r\n            type=\"text\" \r\n            id=\"todo-input\" \r\n            placeholder=\"할일을 입력하세요...\"\r\n            maxlength=\"100\"\r\n          >\r\n          <button id=\"add-btn\">추가</button>\r\n        </div>\r\n        \r\n        <div class=\"stats\">\r\n          <span id=\"total-count\">전체: 0</span>\r\n          <span id=\"completed-count\">완료: 0</span>\r\n          <span id=\"remaining-count\">남은 할일: 0</span>\r\n        </div>\r\n        \r\n        <div class=\"filter-section\">\r\n          <button class=\"filter-btn active\" data-filter=\"all\">전체</button>\r\n          <button class=\"filter-btn\" data-filter=\"active\">진행중</button>\r\n          <button class=\"filter-btn\" data-filter=\"completed\">완료</button>\r\n        </div>\r\n        \r\n        <ul id=\"todo-list\"></ul>\r\n        \r\n        <div class=\"actions\">\r\n          <button id=\"clear-completed\">완료된 항목 삭제</button>\r\n          <button id=\"clear-all\">모두 삭제</button>\r\n        </div>\r\n      </div>\r\n    `;\r\n    \r\n    this.addStyles();\r\n  }\r\n  \r\n  addStyles() {\r\n    const style = document.createElement('style');\r\n    style.textContent = `\r\n      .todo-app {\r\n        max-width: 600px;\r\n        margin: 20px auto;\r\n        padding: 20px;\r\n        font-family: 'Arial', sans-serif;\r\n        background: white;\r\n        border-radius: 10px;\r\n        box-shadow: 0 2px 10px rgba(0,0,0,0.1);\r\n      }\r\n      \r\n      h1 {\r\n        text-align: center;\r\n        color: #333;\r\n        margin-bottom: 30px;\r\n      }\r\n      \r\n      .input-section {\r\n        display: flex;\r\n        gap: 10px;\r\n        margin-bottom: 20px;\r\n      }\r\n      \r\n      #todo-input {\r\n        flex: 1;\r\n        padding: 12px;\r\n        border: 2px solid #ddd;\r\n        border-radius: 5px;\r\n        font-size: 16px;\r\n      }\r\n      \r\n      #todo-input:focus {\r\n        outline: none;\r\n        border-color: #007bff;\r\n      }\r\n      \r\n      button {\r\n        padding: 12px 20px;\r\n        background: #007bff;\r\n        color: white;\r\n        border: none;\r\n        border-radius: 5px;\r\n        cursor: pointer;\r\n        font-size: 14px;\r\n      }\r\n      \r\n      button:hover {\r\n        background: #0056b3;\r\n      }\r\n      \r\n      .stats {\r\n        display: flex;\r\n        justify-content: space-around;\r\n        margin: 20px 0;\r\n        padding: 15px;\r\n        background: #f8f9fa;\r\n        border-radius: 5px;\r\n      }\r\n      \r\n      .filter-section {\r\n        display: flex;\r\n        gap: 10px;\r\n        margin-bottom: 20px;\r\n      }\r\n      \r\n      .filter-btn {\r\n        background: #6c757d;\r\n        padding: 8px 16px;\r\n      }\r\n      \r\n      .filter-btn.active {\r\n        background: #007bff;\r\n      }\r\n      \r\n      #todo-list {\r\n        list-style: none;\r\n        padding: 0;\r\n        margin: 0;\r\n      }\r\n      \r\n      .todo-item {\r\n        display: flex;\r\n        align-items: center;\r\n        padding: 15px;\r\n        margin-bottom: 10px;\r\n        background: #f8f9fa;\r\n        border-radius: 5px;\r\n        border-left: 4px solid #007bff;\r\n      }\r\n      \r\n      .todo-item.completed {\r\n        opacity: 0.6;\r\n        border-left-color: #28a745;\r\n      }\r\n      \r\n      .todo-item.completed .todo-text {\r\n        text-decoration: line-through;\r\n      }\r\n      \r\n      .todo-checkbox {\r\n        margin-right: 15px;\r\n        transform: scale(1.2);\r\n      }\r\n      \r\n      .todo-text {\r\n        flex: 1;\r\n        font-size: 16px;\r\n      }\r\n      \r\n      .delete-btn {\r\n        background: #dc3545;\r\n        padding: 5px 10px;\r\n        font-size: 12px;\r\n      }\r\n      \r\n      .actions {\r\n        display: flex;\r\n        gap: 10px;\r\n        margin-top: 20px;\r\n      }\r\n      \r\n      .actions button {\r\n        background: #6c757d;\r\n        flex: 1;\r\n      }\r\n    `;\r\n    document.head.appendChild(style);\r\n  }\r\n  \r\n  bindEvents() {\r\n    // 할일 추가\r\n    const addBtn = document.getElementById('add-btn');\r\n    const todoInput = document.getElementById('todo-input');\r\n    \r\n    addBtn.addEventListener('click', () => this.addTodo());\r\n    todoInput.addEventListener('keypress', (e) => {\r\n      if (e.key === 'Enter') this.addTodo();\r\n    });\r\n    \r\n    // 필터 버튼들\r\n    const filterBtns = document.querySelectorAll('.filter-btn');\r\n    filterBtns.forEach(btn => {\r\n      btn.addEventListener('click', (e) => {\r\n        filterBtns.forEach(b => b.classList.remove('active'));\r\n        e.target.classList.add('active');\r\n        this.filterTodos(e.target.dataset.filter);\r\n      });\r\n    });\r\n    \r\n    // 전체 삭제 버튼들\r\n    document.getElementById('clear-completed').addEventListener('click', () => {\r\n      this.clearCompleted();\r\n    });\r\n    \r\n    document.getElementById('clear-all').addEventListener('click', () => {\r\n      if (confirm('모든 할일을 삭제하시겠습니까?')) {\r\n        this.clearAll();\r\n      }\r\n    });\r\n  }\r\n  \r\n  addTodo() {\r\n    const input = document.getElementById('todo-input');\r\n    const text = input.value.trim();\r\n    \r\n    if (text === '') {\r\n      alert('할일을 입력해주세요!');\r\n      return;\r\n    }\r\n    \r\n    const todo = {\r\n      id: this.todoId++,\r\n      text: text,\r\n      completed: false,\r\n      createdAt: new Date().toLocaleString()\r\n    };\r\n    \r\n    this.todos.push(todo);\r\n    input.value = '';\r\n    \r\n    this.renderTodos();\r\n    this.updateStats();\r\n    this.saveToStorage();\r\n    \r\n    console.log('새 할일 추가:', todo);\r\n  }\r\n  \r\n  renderTodos() {\r\n    const todoList = document.getElementById('todo-list');\r\n    todoList.innerHTML = '';\r\n    \r\n    this.todos.forEach(todo => {\r\n      const li = document.createElement('li');\r\n      li.className = `todo-item ${todo.completed ? 'completed' : ''}`;\r\n      li.innerHTML = `\r\n        <input \r\n          type=\"checkbox\" \r\n          class=\"todo-checkbox\" \r\n          ${todo.completed ? 'checked' : ''}\r\n          data-id=\"${todo.id}\"\r\n        >\r\n        <span class=\"todo-text\">${todo.text}</span>\r\n        <button class=\"delete-btn\" data-id=\"${todo.id}\">삭제</button>\r\n      `;\r\n      \r\n      todoList.appendChild(li);\r\n    });\r\n    \r\n    // 체크박스 이벤트\r\n    const checkboxes = document.querySelectorAll('.todo-checkbox');\r\n    checkboxes.forEach(checkbox => {\r\n      checkbox.addEventListener('change', (e) => {\r\n        this.toggleTodo(parseInt(e.target.dataset.id));\r\n      });\r\n    });\r\n    \r\n    // 삭제 버튼 이벤트\r\n    const deleteBtns = document.querySelectorAll('.delete-btn');\r\n    deleteBtns.forEach(btn => {\r\n      btn.addEventListener('click', (e) => {\r\n        this.deleteTodo(parseInt(e.target.dataset.id));\r\n      });\r\n    });\r\n  }\r\n  \r\n  toggleTodo(id) {\r\n    const todo = this.todos.find(t => t.id === id);\r\n    if (todo) {\r\n      todo.completed = !todo.completed;\r\n      this.renderTodos();\r\n      this.updateStats();\r\n      this.saveToStorage();\r\n      \r\n      console.log('할일 상태 변경:', todo);\r\n    }\r\n  }\r\n  \r\n  deleteTodo(id) {\r\n    this.todos = this.todos.filter(t => t.id !== id);\r\n    this.renderTodos();\r\n    this.updateStats();\r\n    this.saveToStorage();\r\n    \r\n    console.log('할일 삭제됨, ID:', id);\r\n  }\r\n  \r\n  updateStats() {\r\n    const total = this.todos.length;\r\n    const completed = this.todos.filter(t => t.completed).length;\r\n    const remaining = total - completed;\r\n    \r\n    document.getElementById('total-count').textContent = `전체: ${total}`;\r\n    document.getElementById('completed-count').textContent = `완료: ${completed}`;\r\n    document.getElementById('remaining-count').textContent = `남은 할일: ${remaining}`;\r\n  }\r\n  \r\n  filterTodos(filter) {\r\n    const items = document.querySelectorAll('.todo-item');\r\n    \r\n    items.forEach(item => {\r\n      const checkbox = item.querySelector('.todo-checkbox');\r\n      const isCompleted = checkbox.checked;\r\n      \r\n      switch(filter) {\r\n        case 'active':\r\n          item.style.display = isCompleted ? 'none' : 'flex';\r\n          break;\r\n        case 'completed':\r\n          item.style.display = isCompleted ? 'flex' : 'none';\r\n          break;\r\n        default:\r\n          item.style.display = 'flex';\r\n      }\r\n    });\r\n  }\r\n  \r\n  clearCompleted() {\r\n    this.todos = this.todos.filter(t => !t.completed);\r\n    this.renderTodos();\r\n    this.updateStats();\r\n    this.saveToStorage();\r\n    \r\n    console.log('완료된 할일들이 삭제되었습니다.');\r\n  }\r\n  \r\n  clearAll() {\r\n    this.todos = [];\r\n    this.renderTodos();\r\n    this.updateStats();\r\n    this.saveToStorage();\r\n    \r\n    console.log('모든 할일이 삭제되었습니다.');\r\n  }\r\n  \r\n  saveToStorage() {\r\n    localStorage.setItem('todos', JSON.stringify(this.todos));\r\n    localStorage.setItem('todoId', this.todoId.toString());\r\n  }\r\n  \r\n  loadFromStorage() {\r\n    const savedTodos = localStorage.getItem('todos');\r\n    const savedId = localStorage.getItem('todoId');\r\n    \r\n    if (savedTodos) {\r\n      this.todos = JSON.parse(savedTodos);\r\n    }\r\n    \r\n    if (savedId) {\r\n      this.todoId = parseInt(savedId);\r\n    }\r\n    \r\n    this.renderTodos();\r\n    this.updateStats();\r\n  }\r\n}\r\n\r\n// 앱 실행\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  const app = new TodoApp();\r\n  console.log('할일 관리 앱이 실행되었습니다! 🎉');\r\n});\r\n```\r\n\r\n## 🎯 오늘 배운 핵심 개념들\r\n\r\n### 1. DOM 조작의 4가지 핵심\r\n- **선택하기**: `querySelector`, `getElementById` 등\r\n- **내용 변경**: `textContent`, `innerHTML`\r\n- **속성 조작**: `setAttribute`, `classList`\r\n- **스타일 변경**: `style` 속성\r\n\r\n### 2. 이벤트 처리의 핵심\r\n- **이벤트 리스너**: `addEventListener`\r\n- **이벤트 객체**: `event.target`, `event.preventDefault()`\r\n- **다양한 이벤트**: `click`, `input`, `submit`, `keydown` 등\r\n\r\n### 3. 실전 활용 팁\r\n- **데이터 저장**: `localStorage` 활용\r\n- **사용자 경험**: 실시간 피드백, 확인 다이얼로그\r\n- **코드 구조**: 클래스로 체계적 관리\r\n\r\n## 💭 오늘의 깨달음\r\n\r\nDOM 조작을 배우니까 JavaScript가 단순한 프로그래밍 언어가 아니라, 웹페이지를 살아있게 만드는 마법 같은 도구라는 것을 깨달았다! 클릭 한 번으로 내용이 바뀌고, 타이핑할 때마다 실시간으로 반응하고, 사용자의 모든 행동에 응답할 수 있다는 게 정말 신기했다.\r\n\r\n특히 할일 관리 앱을 만들면서 느낀 것은, DOM 조작과 이벤트 처리가 결합되면 정말 무궁무진한 가능성이 열린다는 것이다. 사용자가 버튼을 클릭하면 즉시 반응하고, 데이터가 실시간으로 업데이트되는 모습을 보니 내가 진짜 웹 개발자가 된 기분이었다! 🎉\r\n\r\n내일은 더 복잡한 이벤트 처리와 애니메이션 효과에 대해 배워볼 예정이다. 점점 더 재미있어지고 있다!\r\n\r\n---\r\n\r\n**\"웹페이지에 생명을 불어넣는 첫 번째 단계를 성공적으로 마쳤다!\"** ✨🚀 \r\n\r\n## 🔗 추가 학습 리소스\r\n\r\n### 참고한 학습 자료\r\n- [MDN Web Docs - DOM 조작](https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model)\r\n- [JavaScript.info - DOM 요소 다루기](https://ko.javascript.info/dom-navigation)\r\n- [웹 접근성을 고려한 이벤트 처리](https://webaim.org/techniques/javascript/)\r\n\r\n### 다음 학습 예정 주제\r\n1. **이벤트 위임(Event Delegation)** - 효율적인 이벤트 관리\r\n2. **CSS 애니메이션과 JavaScript** - 동적 시각 효과\r\n3. **웹 API 활용** - Geolocation, Local Storage 심화\r\n4. **성능 최적화** - 디바운싱, 스로틀링 기법\r\n\r\n### 실습 프로젝트 아이디어\r\n- 📝 고급 할일 관리 앱 (드래그 앤 드롭, 카테고리별 분류)\r\n- 🎮 간단한 게임 (메모리 카드 게임, 퀴즈 앱)\r\n- 🌤️ 날씨 정보 앱 (API 연동)\r\n- 📊 데이터 시각화 도구\r\n\r\n---\r\n\r\n*2025년 6월 1일, DOM 조작의 세계에 첫 발을 내딛다 🚀* "
    },
    {
      "id": "2025-05-31-auto-generated",
      "title": "5월의 마지막 날, JavaScript 객체와 배열 마스터하기",
      "date": "2025-05-31",
      "category": "daily",
      "tags": [
        "블로그",
        "JavaScript",
        "React",
        "CSS",
        "Node.js",
        "Java",
        "학습",
        "프로젝트",
        "개발"
      ],
      "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=400&h=200&fit=crop",
      "description": "2025-05-31의 학습 내용 정리",
      "excerpt": "벌써 5월의 마지막 날이다! 이번 달은 정말 많은 일들이 있었다. 블로그를 만들고, JavaScript 공부를 본격적으로 시작하고, 매일 커밋하는 습관을 들이려고 노력했다. 29일...",
      "content": "# 5월의 마지막 날, JavaScript 객체와 배열 마스터하기\r\n\r\n벌써 5월의 마지막 날이다! 이번 달은 정말 많은 일들이 있었다. 블로그를 만들고, JavaScript 공부를 본격적으로 시작하고, 매일 커밋하는 습관을 들이려고 노력했다. 29일에 커밋 빵꾸가 났지만, 그 이후로는 더욱 열심히 해서 어느 정도 만회한 것 같다. 오늘은 JavaScript 객체와 배열에 대해 깊이 있게 공부했는데, 정말 재미있었다!\r\n\r\n## 📅 5월 한 달 돌아보기\r\n\r\n```javascript\r\n// 5월 한 달 요약\r\nconst mayReview = {\r\n  startDate: '2025-05-01',\r\n  endDate: '2025-05-31',\r\n  achievements: [\r\n    '개인 블로그 구축 완료',\r\n    'JavaScript 기초 문법 마스터',\r\n    '함수와 스코프 개념 이해',\r\n    '객체와 배열 심화 학습',\r\n    '매일 코딩 습관 형성 (29일 제외 😅)'\r\n  ],\r\n  challenges: [\r\n    '커밋 연속성 유지의 어려움',\r\n    '복잡한 개념 이해에 시간 소요',\r\n    '실습과 이론의 균형 맞추기'\r\n  ],\r\n  growth: {\r\n    technical: '상당한 발전',\r\n    consistency: '개선 필요',\r\n    motivation: '매우 높음'\r\n  }\r\n};\r\n\r\nconsole.log('5월 성과:', mayReview.achievements.length, '개 달성!');\r\n```\r\n\r\n## 🎯 오늘의 학습: JavaScript 객체와 배열 심화\r\n\r\n오늘은 JavaScript의 핵심인 객체와 배열에 대해 정말 깊이 있게 공부했다. 단순히 문법만 아는 것이 아니라, 실제로 어떻게 활용할 수 있는지까지 배워서 너무 만족스럽다!\r\n\r\n### 객체 생성과 조작 패턴\r\n\r\n```javascript\r\n// 1. 객체 리터럴 방식\r\nconst student = {\r\n  name: '최도형',\r\n  age: 25,\r\n  major: 'Computer Science',\r\n  grades: {\r\n    javascript: 95,\r\n    react: 88,\r\n    nodejs: 92\r\n  },\r\n  \r\n  // 메서드 정의\r\n  getAverageGrade() {\r\n    const grades = Object.values(this.grades);\r\n    const sum = grades.reduce((total, grade) => total + grade, 0);\r\n    return Math.round(sum / grades.length);\r\n  },\r\n  \r\n  addGrade(subject, score) {\r\n    this.grades[subject] = score;\r\n    console.log(`${subject} 점수 ${score}점이 추가되었습니다.`);\r\n  }\r\n};\r\n\r\n// 2. 생성자 함수 방식\r\nfunction Person(name, age, occupation) {\r\n  this.name = name;\r\n  this.age = age;\r\n  this.occupation = occupation;\r\n  this.hobbies = [];\r\n  \r\n  this.addHobby = function(hobby) {\r\n    this.hobbies.push(hobby);\r\n    return this;  // 메서드 체이닝을 위한 this 반환\r\n  };\r\n  \r\n  this.introduce = function() {\r\n    return `안녕하세요! 저는 ${this.name}이고, ${this.occupation}입니다.`;\r\n  };\r\n}\r\n\r\n// 3. Object.create() 방식\r\nconst personPrototype = {\r\n  introduce() {\r\n    return `Hello, I'm ${this.name}`;\r\n  },\r\n  \r\n  setAge(age) {\r\n    this.age = age;\r\n    return this;\r\n  }\r\n};\r\n\r\nconst developer = Object.create(personPrototype);\r\ndeveloper.name = '도형';\r\ndeveloper.skills = ['JavaScript', 'React', 'Node.js'];\r\n\r\n// 사용 예제\r\nconsole.log(student.getAverageGrade()); // 92\r\nstudent.addGrade('css', 90);\r\n\r\nconst person1 = new Person('김철수', 30, '개발자');\r\nperson1.addHobby('독서').addHobby('영화감상');\r\nconsole.log(person1.introduce());\r\nconsole.log(person1.hobbies); // ['독서', '영화감상']\r\n```\r\n\r\n### 배열 고급 메서드 마스터\r\n\r\n```javascript\r\n// 실습용 데이터\r\nconst products = [\r\n  { id: 1, name: '노트북', price: 1200000, category: 'electronics', inStock: true },\r\n  { id: 2, name: '마우스', price: 50000, category: 'electronics', inStock: true },\r\n  { id: 3, name: '키보드', price: 150000, category: 'electronics', inStock: false },\r\n  { id: 4, name: '책상', price: 300000, category: 'furniture', inStock: true },\r\n  { id: 5, name: '의자', price: 200000, category: 'furniture', inStock: true },\r\n  { id: 6, name: '모니터', price: 400000, category: 'electronics', inStock: true }\r\n];\r\n\r\n// 1. filter() - 조건에 맞는 요소들 필터링\r\nconst electronicsInStock = products.filter(product => \r\n  product.category === 'electronics' && product.inStock\r\n);\r\n\r\nconst expensiveProducts = products.filter(product => product.price > 200000);\r\n\r\nconsole.log('재고 있는 전자제품:', electronicsInStock);\r\nconsole.log('20만원 이상 제품:', expensiveProducts);\r\n\r\n// 2. map() - 배열 요소 변환\r\nconst productNames = products.map(product => product.name);\r\nconst discountedPrices = products.map(product => ({\r\n  ...product,\r\n  discountedPrice: product.price * 0.9,\r\n  originalPrice: product.price\r\n}));\r\n\r\nconsole.log('제품명 목록:', productNames);\r\nconsole.log('할인가 적용:', discountedPrices);\r\n\r\n// 3. reduce() - 배열을 하나의 값으로 축약\r\nconst totalValue = products.reduce((sum, product) => sum + product.price, 0);\r\n\r\nconst categoryCount = products.reduce((acc, product) => {\r\n  acc[product.category] = (acc[product.category] || 0) + 1;\r\n  return acc;\r\n}, {});\r\n\r\nconst mostExpensive = products.reduce((max, product) => \r\n  product.price > max.price ? product : max\r\n);\r\n\r\nconsole.log('총 상품 가치:', totalValue.toLocaleString() + '원');\r\nconsole.log('카테고리별 개수:', categoryCount);\r\nconsole.log('가장 비싼 제품:', mostExpensive.name);\r\n\r\n// 4. 메서드 체이닝으로 복합 연산\r\nconst result = products\r\n  .filter(product => product.inStock)           // 재고 있는 것만\r\n  .filter(product => product.price < 500000)    // 50만원 미만\r\n  .map(product => ({                            // 필요한 정보만 추출\r\n    name: product.name,\r\n    price: product.price,\r\n    formattedPrice: product.price.toLocaleString() + '원'\r\n  }))\r\n  .sort((a, b) => a.price - b.price);          // 가격순 정렬\r\n\r\nconsole.log('구매 가능한 제품 (가격순):', result);\r\n```\r\n\r\n### 구조 분해 할당과 스프레드 연산자\r\n\r\n```javascript\r\n// 객체 구조 분해 할당\r\nconst userInfo = {\r\n  id: 1,\r\n  username: 'stylechoi',\r\n  email: 'choi@example.com',\r\n  profile: {\r\n    firstName: '도형',\r\n    lastName: '최',\r\n    age: 25\r\n  },\r\n  preferences: {\r\n    theme: 'dark',\r\n    language: 'ko'\r\n  }\r\n};\r\n\r\n// 기본 구조 분해\r\nconst { username, email } = userInfo;\r\nconsole.log(username, email); // stylechoi choi@example.com\r\n\r\n// 중첩 객체 구조 분해\r\nconst { profile: { firstName, lastName }, preferences: { theme } } = userInfo;\r\nconsole.log(`${firstName} ${lastName}, 테마: ${theme}`); // 도형 최, 테마: dark\r\n\r\n// 기본값과 별칭 사용\r\nconst { id, role = 'user', username: name } = userInfo;\r\nconsole.log(`ID: ${id}, 역할: ${role}, 이름: ${name}`);\r\n\r\n// 배열 구조 분해 할당\r\nconst colors = ['red', 'green', 'blue', 'yellow', 'purple'];\r\nconst [primary, secondary, ...others] = colors;\r\nconsole.log(primary, secondary, others); // red green ['blue', 'yellow', 'purple']\r\n\r\n// 함수 매개변수에서 구조 분해\r\nfunction createUser({ name, age, email, role = 'user' }) {\r\n  return {\r\n    id: Date.now(),\r\n    name,\r\n    age,\r\n    email,\r\n    role,\r\n    createdAt: new Date().toISOString()\r\n  };\r\n}\r\n\r\nconst newUser = createUser({\r\n  name: '김개발',\r\n  age: 28,\r\n  email: 'kim@dev.com'\r\n});\r\n\r\nconsole.log('새 사용자:', newUser);\r\n\r\n// 스프레드 연산자 활용\r\nconst baseConfig = {\r\n  apiUrl: 'https://api.example.com',\r\n  timeout: 5000,\r\n  retries: 3\r\n};\r\n\r\nconst developmentConfig = {\r\n  ...baseConfig,\r\n  apiUrl: 'https://dev-api.example.com',\r\n  debug: true\r\n};\r\n\r\nconst productionConfig = {\r\n  ...baseConfig,\r\n  timeout: 10000,\r\n  cache: true\r\n};\r\n\r\nconsole.log('개발 환경:', developmentConfig);\r\nconsole.log('운영 환경:', productionConfig);\r\n\r\n// 배열 스프레드\r\nconst fruits = ['apple', 'banana'];\r\nconst vegetables = ['carrot', 'lettuce'];\r\nconst food = [...fruits, 'orange', ...vegetables, 'tomato'];\r\n\r\nconsole.log('음식 목록:', food);\r\n```\r\n\r\n## 🛠️ 실습 프로젝트: 학생 성적 관리 시스템\r\n\r\n오늘 배운 내용들을 종합해서 학생 성적 관리 시스템을 만들어봤다:\r\n\r\n```javascript\r\n// 학생 성적 관리 시스템\r\nclass GradeManager {\r\n  constructor() {\r\n    this.students = [];\r\n    this.subjects = ['수학', '영어', '과학', '국어', '사회'];\r\n  }\r\n  \r\n  // 학생 추가\r\n  addStudent(name, studentId) {\r\n    const student = {\r\n      id: studentId,\r\n      name: name,\r\n      grades: {},\r\n      average: 0,\r\n      rank: 0\r\n    };\r\n    \r\n    this.students.push(student);\r\n    console.log(`학생 ${name}(${studentId})이 추가되었습니다.`);\r\n    return student;\r\n  }\r\n  \r\n  // 성적 입력\r\n  addGrade(studentId, subject, score) {\r\n    const student = this.students.find(s => s.id === studentId);\r\n    if (!student) {\r\n      console.log('학생을 찾을 수 없습니다.');\r\n      return;\r\n    }\r\n    \r\n    if (!this.subjects.includes(subject)) {\r\n      console.log('유효하지 않은 과목입니다.');\r\n      return;\r\n    }\r\n    \r\n    if (score < 0 || score > 100) {\r\n      console.log('점수는 0-100 사이여야 합니다.');\r\n      return;\r\n    }\r\n    \r\n    student.grades[subject] = score;\r\n    this.calculateAverage(student);\r\n    console.log(`${student.name}의 ${subject} 점수 ${score}점이 입력되었습니다.`);\r\n  }\r\n  \r\n  // 평균 계산\r\n  calculateAverage(student) {\r\n    const grades = Object.values(student.grades);\r\n    if (grades.length === 0) {\r\n      student.average = 0;\r\n      return;\r\n    }\r\n    \r\n    const sum = grades.reduce((total, grade) => total + grade, 0);\r\n    student.average = Math.round((sum / grades.length) * 100) / 100;\r\n  }\r\n  \r\n  // 전체 학생 평균 재계산 및 순위 매기기\r\n  calculateRankings() {\r\n    // 모든 학생의 평균 재계산\r\n    this.students.forEach(student => this.calculateAverage(student));\r\n    \r\n    // 평균 점수로 정렬 (내림차순)\r\n    const sortedStudents = [...this.students].sort((a, b) => b.average - a.average);\r\n    \r\n    // 순위 매기기\r\n    sortedStudents.forEach((student, index) => {\r\n      const originalStudent = this.students.find(s => s.id === student.id);\r\n      originalStudent.rank = index + 1;\r\n    });\r\n  }\r\n  \r\n  // 학생별 성적표 출력\r\n  getStudentReport(studentId) {\r\n    const student = this.students.find(s => s.id === studentId);\r\n    if (!student) {\r\n      return '학생을 찾을 수 없습니다.';\r\n    }\r\n    \r\n    const { name, grades, average, rank } = student;\r\n    \r\n    return {\r\n      name,\r\n      grades: { ...grades },\r\n      average,\r\n      rank,\r\n      totalStudents: this.students.length,\r\n      completedSubjects: Object.keys(grades).length,\r\n      totalSubjects: this.subjects.length\r\n    };\r\n  }\r\n  \r\n  // 과목별 통계\r\n  getSubjectStatistics() {\r\n    const stats = {};\r\n    \r\n    this.subjects.forEach(subject => {\r\n      const scores = this.students\r\n        .filter(student => student.grades[subject] !== undefined)\r\n        .map(student => student.grades[subject]);\r\n      \r\n      if (scores.length > 0) {\r\n        const sum = scores.reduce((total, score) => total + score, 0);\r\n        const average = sum / scores.length;\r\n        const max = Math.max(...scores);\r\n        const min = Math.min(...scores);\r\n        \r\n        stats[subject] = {\r\n          average: Math.round(average * 100) / 100,\r\n          max,\r\n          min,\r\n          studentCount: scores.length\r\n        };\r\n      }\r\n    });\r\n    \r\n    return stats;\r\n  }\r\n  \r\n  // 우수 학생 조회 (평균 90점 이상)\r\n  getHonorStudents() {\r\n    return this.students\r\n      .filter(student => student.average >= 90)\r\n      .sort((a, b) => b.average - a.average)\r\n      .map(({ name, average, rank }) => ({ name, average, rank }));\r\n  }\r\n}\r\n\r\n// 사용 예제\r\nconst gradeManager = new GradeManager();\r\n\r\n// 학생 추가\r\ngradeManager.addStudent('김철수', 'S001');\r\ngradeManager.addStudent('이영희', 'S002');\r\ngradeManager.addStudent('박민수', 'S003');\r\ngradeManager.addStudent('최도형', 'S004');\r\n\r\n// 성적 입력\r\ngradeManager.addGrade('S001', '수학', 95);\r\ngradeManager.addGrade('S001', '영어', 88);\r\ngradeManager.addGrade('S001', '과학', 92);\r\n\r\ngradeManager.addGrade('S002', '수학', 98);\r\ngradeManager.addGrade('S002', '영어', 94);\r\ngradeManager.addGrade('S002', '과학', 96);\r\n\r\ngradeManager.addGrade('S003', '수학', 85);\r\ngradeManager.addGrade('S003', '영어', 90);\r\n\r\ngradeManager.addGrade('S004', '수학', 100);\r\ngradeManager.addGrade('S004', '영어', 95);\r\ngradeManager.addGrade('S004', '과학', 98);\r\ngradeManager.addGrade('S004', '국어', 92);\r\n\r\n// 순위 계산\r\ngradeManager.calculateRankings();\r\n\r\n// 결과 출력\r\nconsole.log('=== 학생별 성적표 ===');\r\ngradeManager.students.forEach(student => {\r\n  const report = gradeManager.getStudentReport(student.id);\r\n  console.log(report);\r\n});\r\n\r\nconsole.log('\\n=== 과목별 통계 ===');\r\nconsole.log(gradeManager.getSubjectStatistics());\r\n\r\nconsole.log('\\n=== 우수 학생 (평균 90점 이상) ===');\r\nconsole.log(gradeManager.getHonorStudents());\r\n```\r\n\r\n## 🎯 6월 학습 계획 수립\r\n\r\n```javascript\r\n// 6월 학습 로드맵\r\nconst juneStudyPlan = {\r\n  theme: 'JavaScript 실전 활용과 웹 개발',\r\n  \r\n  week1: {\r\n    topic: 'DOM 조작과 이벤트 처리',\r\n    goals: [\r\n      'DOM API 완전 이해',\r\n      '이벤트 리스너와 이벤트 객체',\r\n      '동적 웹페이지 제작',\r\n      '실습: 인터랙티브 할일 앱'\r\n    ]\r\n  },\r\n  \r\n  week2: {\r\n    topic: '비동기 JavaScript',\r\n    goals: [\r\n      'Promise와 async/await',\r\n      'Fetch API로 데이터 통신',\r\n      '에러 처리 패턴',\r\n      '실습: 날씨 정보 앱'\r\n    ]\r\n  },\r\n  \r\n  week3: {\r\n    topic: 'ES6+ 고급 기능',\r\n    goals: [\r\n      'Class와 상속',\r\n      'Module 시스템',\r\n      'Map, Set, Symbol 활용',\r\n      '실습: 모듈화된 게임 앱'\r\n    ]\r\n  },\r\n  \r\n  week4: {\r\n    topic: '실전 프로젝트',\r\n    goals: [\r\n      '포트폴리오 웹사이트 제작',\r\n      'API 연동 실습',\r\n      '성능 최적화',\r\n      '배포 및 호스팅'\r\n    ]\r\n  },\r\n  \r\n  dailyRoutine: {\r\n    study: '3-4시간',\r\n    practice: '2-3시간',\r\n    blogging: '30분',\r\n    commit: '매일 필수! 🔥'\r\n  },\r\n  \r\n  monthlyGoal: 'JavaScript로 완성도 높은 웹 애플리케이션 제작'\r\n};\r\n\r\nconsole.log('6월 목표:', juneStudyPlan.monthlyGoal);\r\n```\r\n\r\n## 💭 5월 마지막 날 회고\r\n\r\n이번 달은 정말 많은 것을 배웠다. JavaScript 기초부터 시작해서 함수, 객체, 배열까지... 처음에는 막막했는데 하루하루 꾸준히 하다 보니 어느새 이렇게 복잡한 프로그램도 만들 수 있게 되었다.\r\n\r\n특히 오늘 만든 학생 성적 관리 시스템은 정말 뿌듯했다. 객체와 배열, 메서드들을 조합해서 실제로 사용할 수 있는 프로그램을 만들었다는 게 신기하고 재미있었다.\r\n\r\n29일에 커밋을 놓친 것은 아직도 아쉽지만, 그 이후로 더욱 열심히 해서 많은 것을 배웠다. 실수도 성장의 일부라고 생각하자!\r\n\r\n### 5월 성과 요약\r\n- ✅ JavaScript 기초 문법 완전 마스터\r\n- ✅ 함수와 스코프 개념 이해\r\n- ✅ 객체와 배열 심화 학습\r\n- ✅ 실습 프로젝트 3개 완성\r\n- ✅ 블로그 포스팅 꾸준히 작성\r\n- ✅ 개발자 마인드셋 형성\r\n\r\n### 6월 다짐\r\n- 🎯 DOM 조작으로 실제 웹페이지 만들기\r\n- 🌐 API 연동해서 동적 데이터 활용하기\r\n- 📱 반응형 웹 애플리케이션 제작\r\n- 💻 매일 커밋 습관 완전히 정착시키기\r\n- 📚 꾸준한 학습과 기록\r\n\r\n6월에는 더욱 실전적인 웹 개발을 배워서, 실제로 사용할 수 있는 웹 애플리케이션을 만들어보고 싶다. JavaScript 기초가 탄탄해졌으니 이제 진짜 재미있는 것들을 만들 수 있을 것 같다!\r\n\r\n---\r\n\r\n**\"5월의 끝은 6월의 새로운 시작! 더 큰 도전을 향해 전진하자!\"** 🚀✨ "
    },
    {
      "id": "2025-05-29-auto-generated",
      "title": "커밋 빵꾸의 아쉬움과 JavaScript 함수 심화 학습",
      "date": "2025-05-29",
      "category": "daily",
      "tags": [
        "Git",
        "블로그",
        "JavaScript",
        "React",
        "CSS",
        "Node.js",
        "Java",
        "학습",
        "프로젝트"
      ],
      "image": "https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=400&h=200&fit=crop",
      "description": "2025-05-29의 학습 내용 정리",
      "excerpt": "오늘은 정말 아쉬운 하루였다. 어제까지 열심히 채워온 깃허브 잔디가 오늘 하루 빵꾸가 나버렸다... 😭 매일 커밋하는 습관을 들이려고 노력했는데, 하루 놓치니까 왠지 모르게 허전...",
      "content": "# 커밋 빵꾸의 아쉬움과 JavaScript 함수 심화 학습\r\n\r\n오늘은 정말 아쉬운 하루였다. 어제까지 열심히 채워온 깃허브 잔디가 오늘 하루 빵꾸가 나버렸다... 😭 매일 커밋하는 습관을 들이려고 노력했는데, 하루 놓치니까 왠지 모르게 허전하고 아쉽다. 하지만 이런 날도 있는 법이니까 너무 자책하지 말고 내일부터 다시 열심히 해야겠다!\r\n\r\n## 😅 깃허브 잔디 빵꾸 사건\r\n\r\n```javascript\r\n// 오늘의 깃허브 상태\r\nconst githubStatus = {\r\n  streak: 0,           // 연속 커밋 끊김 😢\r\n  lastCommit: '2025-05-28',\r\n  missedDay: '2025-05-29',\r\n  feeling: 'disappointed',\r\n  resolution: 'restart_tomorrow'\r\n};\r\n\r\n// 잔디 채우기 다짐\r\nfunction restartCommitStreak() {\r\n  const promise = new Promise((resolve) => {\r\n    console.log('내일부터 다시 매일 커밋하자!');\r\n    resolve('새로운 시작');\r\n  });\r\n  \r\n  return promise;\r\n}\r\n\r\nrestartCommitStreak().then(result => {\r\n  console.log(`다짐: ${result} 💪`);\r\n});\r\n```\r\n\r\n사실 어제 늦게까지 JavaScript 공부하느라 정신없었는데, 오늘 아침에 일어나서 깃허브를 확인해보니 커밋을 안 했더라... 이런 실수를 방지하기 위해 앞으로는 공부한 내용을 바로바로 커밋하는 습관을 들여야겠다.\r\n\r\n## 📚 JavaScript 함수 심화 학습\r\n\r\n어제 기초 문법을 마쳤으니 오늘은 함수에 대해 깊이 있게 공부했다. JavaScript의 함수는 정말 강력하고 유연해서 배울수록 재미있다!\r\n\r\n### 함수 선언 방식의 차이점\r\n\r\n```javascript\r\n// 1. 함수 선언문 (Function Declaration)\r\nfunction greetUser(name) {\r\n  return `안녕하세요, ${name}님!`;\r\n}\r\n\r\n// 2. 함수 표현식 (Function Expression)\r\nconst calculateAge = function(birthYear) {\r\n  const currentYear = new Date().getFullYear();\r\n  return currentYear - birthYear;\r\n};\r\n\r\n// 3. 화살표 함수 (Arrow Function) - ES6\r\nconst multiply = (a, b) => a * b;\r\n\r\n// 4. 즉시 실행 함수 (IIFE)\r\n(function() {\r\n  console.log('즉시 실행됩니다!');\r\n})();\r\n\r\n// 호이스팅 테스트\r\nconsole.log(greetUser('도형')); // 작동함 (호이스팅)\r\n// console.log(calculateAge(1998)); // ReferenceError (호이스팅 안됨)\r\n```\r\n\r\n### 고차 함수와 콜백 함수\r\n\r\n```javascript\r\n// 고차 함수 예제\r\nfunction processArray(arr, callback) {\r\n  const result = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    result.push(callback(arr[i]));\r\n  }\r\n  return result;\r\n}\r\n\r\n// 콜백 함수들\r\nconst double = x => x * 2;\r\nconst square = x => x * x;\r\nconst addExclamation = str => str + '!';\r\n\r\n// 사용 예제\r\nconst numbers = [1, 2, 3, 4, 5];\r\nconst words = ['안녕', '하세요', '반갑습니다'];\r\n\r\nconsole.log(processArray(numbers, double));        // [2, 4, 6, 8, 10]\r\nconsole.log(processArray(numbers, square));        // [1, 4, 9, 16, 25]\r\nconsole.log(processArray(words, addExclamation));  // ['안녕!', '하세요!', '반갑습니다!']\r\n\r\n// 배열 메서드와 콜백 함수\r\nconst studyTopics = [\r\n  { subject: 'JavaScript', difficulty: 3, completed: true },\r\n  { subject: 'React', difficulty: 4, completed: false },\r\n  { subject: 'Node.js', difficulty: 4, completed: false },\r\n  { subject: 'CSS', difficulty: 2, completed: true }\r\n];\r\n\r\n// filter, map, reduce 활용\r\nconst completedTopics = studyTopics.filter(topic => topic.completed);\r\nconst subjectNames = studyTopics.map(topic => topic.subject);\r\nconst totalDifficulty = studyTopics.reduce((sum, topic) => sum + topic.difficulty, 0);\r\n\r\nconsole.log('완료한 과목:', completedTopics);\r\nconsole.log('모든 과목명:', subjectNames);\r\nconsole.log('총 난이도:', totalDifficulty);\r\n```\r\n\r\n### 클로저(Closure) 개념 이해\r\n\r\n```javascript\r\n// 클로저 기본 예제\r\nfunction createCounter() {\r\n  let count = 0;\r\n  \r\n  return function() {\r\n    count++;\r\n    return count;\r\n  };\r\n}\r\n\r\nconst counter1 = createCounter();\r\nconst counter2 = createCounter();\r\n\r\nconsole.log(counter1()); // 1\r\nconsole.log(counter1()); // 2\r\nconsole.log(counter2()); // 1 (독립적인 카운터)\r\nconsole.log(counter1()); // 3\r\n\r\n// 실용적인 클로저 예제 - 설정 관리\r\nfunction createConfig() {\r\n  const settings = {\r\n    theme: 'light',\r\n    language: 'ko',\r\n    notifications: true\r\n  };\r\n  \r\n  return {\r\n    get: function(key) {\r\n      return settings[key];\r\n    },\r\n    set: function(key, value) {\r\n      settings[key] = value;\r\n      console.log(`${key} 설정이 ${value}로 변경되었습니다.`);\r\n    },\r\n    getAll: function() {\r\n      return { ...settings }; // 복사본 반환으로 직접 수정 방지\r\n    }\r\n  };\r\n}\r\n\r\nconst appConfig = createConfig();\r\nconsole.log(appConfig.get('theme')); // 'light'\r\nappConfig.set('theme', 'dark');\r\nconsole.log(appConfig.getAll()); // { theme: 'dark', language: 'ko', notifications: true }\r\n```\r\n\r\n## 🛠️ 실습 프로젝트: 간단한 할일 관리 함수\r\n\r\n오늘 배운 함수 개념들을 활용해서 간단한 할일 관리 시스템을 만들어봤다:\r\n\r\n```javascript\r\n// 할일 관리 시스템\r\nfunction createTodoManager() {\r\n  let todos = [];\r\n  let nextId = 1;\r\n  \r\n  return {\r\n    // 할일 추가\r\n    add: function(task, priority = 'medium') {\r\n      const todo = {\r\n        id: nextId++,\r\n        task: task,\r\n        priority: priority,\r\n        completed: false,\r\n        createdAt: new Date().toISOString()\r\n      };\r\n      todos.push(todo);\r\n      console.log(`할일 추가됨: ${task}`);\r\n      return todo;\r\n    },\r\n    \r\n    // 할일 완료 처리\r\n    complete: function(id) {\r\n      const todo = todos.find(t => t.id === id);\r\n      if (todo) {\r\n        todo.completed = true;\r\n        console.log(`할일 완료: ${todo.task}`);\r\n      } else {\r\n        console.log('해당 할일을 찾을 수 없습니다.');\r\n      }\r\n    },\r\n    \r\n    // 할일 목록 조회\r\n    list: function(filter = 'all') {\r\n      let filteredTodos = todos;\r\n      \r\n      if (filter === 'completed') {\r\n        filteredTodos = todos.filter(t => t.completed);\r\n      } else if (filter === 'pending') {\r\n        filteredTodos = todos.filter(t => !t.completed);\r\n      }\r\n      \r\n      return filteredTodos.sort((a, b) => {\r\n        const priorityOrder = { high: 3, medium: 2, low: 1 };\r\n        return priorityOrder[b.priority] - priorityOrder[a.priority];\r\n      });\r\n    },\r\n    \r\n    // 통계 정보\r\n    stats: function() {\r\n      const total = todos.length;\r\n      const completed = todos.filter(t => t.completed).length;\r\n      const pending = total - completed;\r\n      \r\n      return {\r\n        total,\r\n        completed,\r\n        pending,\r\n        completionRate: total > 0 ? Math.round((completed / total) * 100) : 0\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n// 사용 예제\r\nconst myTodos = createTodoManager();\r\n\r\nmyTodos.add('JavaScript 함수 공부하기', 'high');\r\nmyTodos.add('블로그 포스트 작성', 'medium');\r\nmyTodos.add('운동하기', 'low');\r\nmyTodos.add('독서하기', 'medium');\r\n\r\nmyTodos.complete(1);\r\nmyTodos.complete(2);\r\n\r\nconsole.log('전체 할일:', myTodos.list());\r\nconsole.log('완료된 할일:', myTodos.list('completed'));\r\nconsole.log('미완료 할일:', myTodos.list('pending'));\r\nconsole.log('통계:', myTodos.stats());\r\n```\r\n\r\n## 🎯 내일의 학습 계획\r\n\r\n```javascript\r\nconst tomorrowPlan = {\r\n  mainTopic: 'JavaScript 객체와 배열 심화',\r\n  goals: [\r\n    '객체 생성 패턴 학습 (리터럴, 생성자, Object.create)',\r\n    '배열 고급 메서드 마스터 (forEach, map, filter, reduce)',\r\n    '구조 분해 할당과 스프레드 연산자',\r\n    '실습: 학생 성적 관리 시스템 만들기'\r\n  ],\r\n  commitGoal: '오늘 놓친 커밋 만회하기! 💪',\r\n  studyTime: '4시간',\r\n  blogPost: '객체와 배열 활용법 정리'\r\n};\r\n\r\n// 다짐\r\nfunction makeCommitment() {\r\n  return new Promise((resolve) => {\r\n    setTimeout(() => {\r\n      resolve('내일은 반드시 커밋하고 더 열심히 공부하자!');\r\n    }, 1000);\r\n  });\r\n}\r\n\r\nmakeCommitment().then(message => {\r\n  console.log(message);\r\n});\r\n```\r\n\r\n## 💭 오늘의 회고\r\n\r\n커밋을 놓친 건 아쉽지만, JavaScript 함수에 대해 정말 많이 배웠다. 특히 클로저 개념이 처음에는 어려웠는데, 실습을 통해 점점 이해가 되기 시작했다. 함수형 프로그래밍의 매력을 조금씩 느끼고 있는 것 같다.\r\n\r\n내일은 객체와 배열을 깊이 있게 공부하면서, 오늘 놓친 커밋도 만회해야겠다. 실수는 누구나 할 수 있으니까 너무 자책하지 말고, 이런 경험을 통해 더 나은 습관을 만들어가자!\r\n\r\n### 오늘의 성과\r\n- ✅ 함수 선언 방식 4가지 완전 이해\r\n- ✅ 고차 함수와 콜백 함수 개념 습득\r\n- ✅ 클로저 기본 개념 이해\r\n- ✅ 실습 프로젝트 완성 (할일 관리 시스템)\r\n- ❌ 깃허브 커밋 (내일 만회 예정)\r\n\r\n### 내일의 다짐\r\n- 🎯 객체와 배열 마스터하기\r\n- 💻 깃허브 커밋 잊지 않기\r\n- 📝 블로그 포스트 꾸준히 작성하기\r\n- 🏃‍♂️ 학습 루틴 더욱 체계화하기\r\n\r\n---\r\n\r\n**\"실수는 성장의 발판이다. 오늘의 아쉬움을 내일의 동력으로!\"** 🚀 "
    },
    {
      "id": "2025-05-26-auto-generated",
      "title": "JavaScript 변수와 데이터 타입 마스터하기",
      "date": "2025-05-26",
      "category": "daily",
      "tags": [
        "1e1e1e",
        "d4d4d4",
        "2d2d30",
        "d4d4d4",
        "3e3e42",
        "0e639c",
        "f14c4c"
      ],
      "image": "https://images.unsplash.com/photo-1516321318423-f06f85e504b3?w=400&h=200&fit=crop",
      "description": "2025-05-26의 학습 내용 정리",
      "excerpt": "어제 다짐한 대로 오늘부터 본격적인 JavaScript \"빡센\" 공부를 시작했다! 첫 번째 주제는 가장 기본이 되는 변수와 데이터 타입. 단순해 보이지만 JavaScript만의 독...",
      "content": "# JavaScript 변수와 데이터 타입 마스터하기\r\n\r\n어제 다짐한 대로 오늘부터 본격적인 JavaScript \"빡센\" 공부를 시작했다! 첫 번째 주제는 가장 기본이 되는 변수와 데이터 타입. 단순해 보이지만 JavaScript만의 독특한 특징들이 많아서 생각보다 깊이 있는 내용이었다.\r\n\r\n## 🎯 오늘의 학습 목표 및 성과\r\n\r\n```javascript\r\n// 오늘의 학습 계획\r\nconst todayGoals = {\r\n  theory: [\r\n    'var, let, const 차이점 완전 이해',\r\n    '7가지 데이터 타입 마스터',\r\n    '타입 변환과 비교 연산 원리 파악'\r\n  ],\r\n  practice: [\r\n    '변수 선언 예제 20개 작성',\r\n    '타입 변환 실습 프로젝트',\r\n    '간단한 계산기 프로토타입 제작'\r\n  ],\r\n  achievement: '✅ 모든 목표 달성!'\r\n};\r\n```\r\n\r\n## 📝 변수 선언: var vs let vs const\r\n\r\nJavaScript에서 가장 혼란스러웠던 부분 중 하나가 변수 선언이었는데, 오늘 확실히 정리했다:\r\n\r\n### var의 특징과 문제점\r\n\r\n```javascript\r\n// var의 함수 스코프와 호이스팅\r\nconsole.log(beforeDeclaration); // undefined (에러 아님!)\r\nvar beforeDeclaration = \"나는 호이스팅됨\";\r\n\r\nfunction testVarScope() {\r\n  if (true) {\r\n    var functionScoped = \"함수 스코프\";\r\n  }\r\n  console.log(functionScoped); // \"함수 스코프\" (블록 밖에서도 접근 가능!)\r\n}\r\n\r\ntestVarScope();\r\n\r\n// var의 재선언 허용 문제\r\nvar userName = \"최도형\";\r\nvar userName = \"홍길동\"; // 에러 없이 덮어씀\r\nconsole.log(userName); // \"홍길동\"\r\n```\r\n\r\n### let의 블록 스코프\r\n\r\n```javascript\r\n// let의 블록 스코프\r\nfunction testLetScope() {\r\n  if (true) {\r\n    let blockScoped = \"블록 스코프\";\r\n    console.log(blockScoped); // \"블록 스코프\"\r\n  }\r\n  // console.log(blockScoped); // ReferenceError!\r\n}\r\n\r\n// let의 재선언 방지\r\nlet userAge = 25;\r\n// let userAge = 30; // SyntaxError: Identifier 'userAge' has already been declared\r\n\r\n// 하지만 재할당은 가능\r\nuserAge = 30; // OK\r\nconsole.log(userAge); // 30\r\n```\r\n\r\n### const의 상수 특성\r\n\r\n```javascript\r\n// const의 기본 사용\r\nconst PI = 3.14159;\r\n// PI = 3.14; // TypeError: Assignment to constant variable.\r\n\r\n// 객체와 배열의 경우 내용 변경은 가능\r\nconst person = {\r\n  name: \"최도형\",\r\n  age: 25\r\n};\r\n\r\nperson.age = 26; // OK (객체 내용 변경)\r\nperson.city = \"서울\"; // OK (속성 추가)\r\nconsole.log(person); // { name: \"최도형\", age: 26, city: \"서울\" }\r\n\r\n// person = {}; // TypeError: Assignment to constant variable.\r\n\r\nconst hobbies = [\"코딩\", \"독서\"];\r\nhobbies.push(\"운동\"); // OK (배열 내용 변경)\r\nconsole.log(hobbies); // [\"코딩\", \"독서\", \"운동\"]\r\n\r\n// hobbies = []; // TypeError: Assignment to constant variable.\r\n```\r\n\r\n### 실제 사용 가이드라인\r\n\r\n```javascript\r\n// 권장하는 변수 선언 패턴\r\nconst developmentGuidelines = {\r\n  // 1. 기본적으로 const 사용\r\n  DEFAULT_TIMEOUT: 5000,\r\n  API_ENDPOINTS: {\r\n    users: '/api/users',\r\n    posts: '/api/posts'\r\n  },\r\n  \r\n  // 2. 값이 변경되어야 하는 경우만 let 사용\r\n  getCurrentTime() {\r\n    let now = new Date();\r\n    let timeString = now.toLocaleTimeString();\r\n    return timeString;\r\n  },\r\n  \r\n  // 3. var는 사용하지 않기 (레거시 코드 제외)\r\n  // 4. 변수명은 의미있게 작성\r\n  calculateUserScore(correctAnswers, totalQuestions) {\r\n    let scorePercentage = (correctAnswers / totalQuestions) * 100;\r\n    return Math.round(scorePercentage);\r\n  }\r\n};\r\n```\r\n\r\n## 🔢 JavaScript 데이터 타입 완전 정복\r\n\r\nJavaScript의 7가지 데이터 타입을 실습하면서 깊이 이해했다:\r\n\r\n### 원시 타입 (Primitive Types)\r\n\r\n```javascript\r\n// 1. Number - 정수와 실수 구분 없음\r\nconst integer = 42;\r\nconst decimal = 3.14159;\r\nconst negative = -17;\r\nconst scientific = 2.5e6; // 2,500,000\r\n\r\n// 특별한 Number 값들\r\nconst infinity = Infinity;\r\nconst negativeInfinity = -Infinity;\r\nconst notANumber = NaN;\r\n\r\nconsole.log(typeof integer); // \"number\"\r\nconsole.log(Number.isInteger(integer)); // true\r\nconsole.log(Number.isNaN(notANumber)); // true\r\n\r\n// 2. String - 문자열\r\nconst singleQuote = '홑따옴표';\r\nconst doubleQuote = \"쌍따옴표\";\r\nconst templateLiteral = `템플릿 리터럴로 ${singleQuote}와 ${doubleQuote} 조합`;\r\n\r\n// 문자열 메서드 실습\r\nconst message = \"JavaScript는 재미있어!\";\r\nconsole.log(message.length); // 13\r\nconsole.log(message.toUpperCase()); // \"JAVASCRIPT는 재미있어!\"\r\nconsole.log(message.slice(0, 10)); // \"JavaScript\"\r\n\r\n// 3. Boolean - 논리값\r\nconst isLearning = true;\r\nconst isCompleted = false;\r\nconst isTruthy = Boolean(\"비어있지 않은 문자열\"); // true\r\nconst isFalsy = Boolean(\"\"); // false\r\n\r\n// 4. Undefined - 값이 할당되지 않음\r\nlet notAssigned;\r\nconsole.log(notAssigned); // undefined\r\nconsole.log(typeof notAssigned); // \"undefined\"\r\n\r\n// 5. Null - 의도적으로 빈 값\r\nconst emptyValue = null;\r\nconsole.log(emptyValue); // null\r\nconsole.log(typeof emptyValue); // \"object\" (JavaScript의 유명한 버그!)\r\n\r\n// 6. Symbol - 고유한 식별자 (ES6+)\r\nconst uniqueId = Symbol('id');\r\nconst anotherId = Symbol('id');\r\nconsole.log(uniqueId === anotherId); // false (각각 고유함)\r\n\r\n// 7. BigInt - 큰 정수 (ES2020+)\r\nconst bigNumber = 123456789012345678901234567890n;\r\nconst anotherBig = BigInt(\"999999999999999999999999999999\");\r\nconsole.log(typeof bigNumber); // \"bigint\"\r\n```\r\n\r\n### 참조 타입 (Reference Type)\r\n\r\n```javascript\r\n// Object - 객체 (배열, 함수도 객체)\r\nconst student = {\r\n  name: \"최도형\",\r\n  age: 25,\r\n  subjects: [\"JavaScript\", \"React\", \"Node.js\"],\r\n  study: function(subject) {\r\n    return `${this.name}이 ${subject}를 공부하고 있습니다.`;\r\n  }\r\n};\r\n\r\nconsole.log(typeof student); // \"object\"\r\nconsole.log(Array.isArray(student.subjects)); // true\r\nconsole.log(typeof student.study); // \"function\"\r\n\r\n// 배열도 객체\r\nconst numbers = [1, 2, 3, 4, 5];\r\nconsole.log(typeof numbers); // \"object\"\r\nconsole.log(numbers instanceof Array); // true\r\n\r\n// 함수도 객체\r\nfunction calculate(a, b) {\r\n  return a + b;\r\n}\r\nconsole.log(typeof calculate); // \"function\"\r\nconsole.log(calculate instanceof Object); // true\r\n```\r\n\r\n## 🔄 타입 변환과 비교 연산\r\n\r\nJavaScript의 타입 변환 시스템을 이해하는 것이 중요했다:\r\n\r\n### 암시적 타입 변환 (Type Coercion)\r\n\r\n```javascript\r\n// 문자열 연결에서의 변환\r\nconsole.log(\"5\" + 3); // \"53\" (숫자가 문자열로 변환)\r\nconsole.log(\"5\" - 3); // 2 (문자열이 숫자로 변환)\r\nconsole.log(\"5\" * \"3\"); // 15 (둘 다 숫자로 변환)\r\n\r\n// Boolean 변환\r\nconsole.log(!\"\"); // true (빈 문자열은 falsy)\r\nconsole.log(!0); // true (0은 falsy)\r\nconsole.log(!null); // true (null은 falsy)\r\nconsole.log(!undefined); // true (undefined는 falsy)\r\nconsole.log(!NaN); // true (NaN은 falsy)\r\n\r\n// 객체는 항상 truthy\r\nconsole.log(!{}); // false\r\nconsole.log(![]); // false\r\n\r\n// 비교 연산에서의 변환\r\nconsole.log(\"2\" > 1); // true (문자열 \"2\"가 숫자 2로 변환)\r\nconsole.log(null == undefined); // true (특별한 규칙)\r\nconsole.log(null === undefined); // false (타입이 다름)\r\n```\r\n\r\n### 명시적 타입 변환\r\n\r\n```javascript\r\n// 숫자로 변환\r\nconst stringNumber = \"123\";\r\nconst convertedNumber = Number(stringNumber); // 123\r\nconst parsedInt = parseInt(\"123.45\"); // 123\r\nconst parsedFloat = parseFloat(\"123.45\"); // 123.45\r\n\r\n// 문자열로 변환\r\nconst numberString = String(123); // \"123\"\r\nconst toStringMethod = (123).toString(); // \"123\"\r\nconst templateConversion = `${123}`; // \"123\"\r\n\r\n// Boolean으로 변환\r\nconst booleanValue = Boolean(1); // true\r\nconst notOperator = !!1; // true (!! 트릭)\r\n\r\n// 타입 검사 유틸리티 함수 만들기\r\nfunction getDetailedType(value) {\r\n  if (value === null) return 'null';\r\n  if (Array.isArray(value)) return 'array';\r\n  if (value instanceof Date) return 'date';\r\n  return typeof value;\r\n}\r\n\r\nconsole.log(getDetailedType([])); // \"array\"\r\nconsole.log(getDetailedType(null)); // \"null\" \r\nconsole.log(getDetailedType(new Date())); // \"date\"\r\n```\r\n\r\n## 🛠️ 실습 프로젝트: 타입 체커 도구\r\n\r\n오늘 배운 내용을 활용해서 타입 체커 도구를 만들어봤다:\r\n\r\n```html\r\n<!-- type-checker.html -->\r\n<!DOCTYPE html>\r\n<html lang=\"ko\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>JavaScript 타입 체커</title>\r\n    <style>\r\n        body {\r\n            font-family: 'Courier New', monospace;\r\n            max-width: 800px;\r\n            margin: 0 auto;\r\n            padding: 20px;\r\n            background-color: #1e1e1e;\r\n            color: #d4d4d4;\r\n        }\r\n        .input-section {\r\n            margin-bottom: 20px;\r\n        }\r\n        input[type=\"text\"] {\r\n            width: 100%;\r\n            padding: 10px;\r\n            font-size: 16px;\r\n            background-color: #2d2d30;\r\n            color: #d4d4d4;\r\n            border: 1px solid #3e3e42;\r\n            border-radius: 4px;\r\n        }\r\n        .result {\r\n            background-color: #0e639c;\r\n            padding: 15px;\r\n            border-radius: 4px;\r\n            margin-top: 10px;\r\n        }\r\n        .result.error {\r\n            background-color: #f14c4c;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <h1>🔍 JavaScript 타입 체커</h1>\r\n    <div class=\"input-section\">\r\n        <input type=\"text\" id=\"valueInput\" placeholder=\"값을 입력하세요 (예: 123, 'hello', true, null)\">\r\n        <button onclick=\"checkType()\">타입 검사</button>\r\n    </div>\r\n    <div id=\"result\"></div>\r\n    \r\n    <script src=\"type-checker.js\"></script>\r\n</body>\r\n</html>\r\n```\r\n\r\n```javascript\r\n// type-checker.js\r\nfunction checkType() {\r\n    const input = document.getElementById('valueInput').value;\r\n    const resultDiv = document.getElementById('result');\r\n    \r\n    try {\r\n        // 입력값을 JavaScript 값으로 파싱\r\n        const value = parseInput(input);\r\n        \r\n        // 상세한 타입 정보 수집\r\n        const typeInfo = getTypeInfo(value);\r\n        \r\n        // 결과 표시\r\n        displayResult(typeInfo, false);\r\n        \r\n    } catch (error) {\r\n        displayResult(`에러: ${error.message}`, true);\r\n    }\r\n}\r\n\r\nfunction parseInput(input) {\r\n    if (input === '') return undefined;\r\n    if (input === 'null') return null;\r\n    if (input === 'undefined') return undefined;\r\n    if (input === 'true') return true;\r\n    if (input === 'false') return false;\r\n    \r\n    // 문자열 (따옴표로 감싸진 경우)\r\n    if ((input.startsWith('\"') && input.endsWith('\"')) ||\r\n        (input.startsWith(\"'\") && input.endsWith(\"'\"))) {\r\n        return input.slice(1, -1);\r\n    }\r\n    \r\n    // 숫자\r\n    if (!isNaN(Number(input)) && input !== '') {\r\n        return Number(input);\r\n    }\r\n    \r\n    // 객체나 배열 (JSON 형태)\r\n    if (input.startsWith('{') || input.startsWith('[')) {\r\n        return JSON.parse(input);\r\n    }\r\n    \r\n    // 기본적으로 문자열로 처리\r\n    return input;\r\n}\r\n\r\nfunction getTypeInfo(value) {\r\n    const basicType = typeof value;\r\n    const detailedType = getDetailedType(value);\r\n    \r\n    return {\r\n        value: value,\r\n        basicType: basicType,\r\n        detailedType: detailedType,\r\n        isArray: Array.isArray(value),\r\n        isNull: value === null,\r\n        isTruthy: !!value,\r\n        isFalsy: !value,\r\n        stringRepresentation: String(value),\r\n        jsonRepresentation: JSON.stringify(value)\r\n    };\r\n}\r\n\r\nfunction getDetailedType(value) {\r\n    if (value === null) return 'null';\r\n    if (Array.isArray(value)) return 'array';\r\n    if (value instanceof Date) return 'date';\r\n    if (value instanceof RegExp) return 'regexp';\r\n    return typeof value;\r\n}\r\n\r\nfunction displayResult(info, isError) {\r\n    const resultDiv = document.getElementById('result');\r\n    \r\n    if (isError) {\r\n        resultDiv.innerHTML = `<div class=\"result error\">${info}</div>`;\r\n        return;\r\n    }\r\n    \r\n    resultDiv.innerHTML = `\r\n        <div class=\"result\">\r\n            <h3>📊 타입 분석 결과</h3>\r\n            <p><strong>값:</strong> ${info.jsonRepresentation}</p>\r\n            <p><strong>기본 타입:</strong> ${info.basicType}</p>\r\n            <p><strong>상세 타입:</strong> ${info.detailedType}</p>\r\n            <p><strong>배열 여부:</strong> ${info.isArray}</p>\r\n            <p><strong>null 여부:</strong> ${info.isNull}</p>\r\n            <p><strong>Truthy:</strong> ${info.isTruthy}</p>\r\n            <p><strong>Falsy:</strong> ${info.isFalsy}</p>\r\n            <p><strong>문자열 변환:</strong> \"${info.stringRepresentation}\"</p>\r\n        </div>\r\n    `;\r\n}\r\n\r\n// 페이지 로드 시 Enter 키 이벤트 추가\r\ndocument.addEventListener('DOMContentLoaded', function() {\r\n    const input = document.getElementById('valueInput');\r\n    input.addEventListener('keypress', function(event) {\r\n        if (event.key === 'Enter') {\r\n            checkType();\r\n        }\r\n    });\r\n    \r\n    // 샘플 값들로 테스트 버튼 추가\r\n    const sampleValues = ['123', '\"hello\"', 'true', 'null', 'undefined', '[]', '{}'];\r\n    \r\n    const buttonContainer = document.createElement('div');\r\n    buttonContainer.innerHTML = '<h3>🎯 샘플 테스트:</h3>';\r\n    \r\n    sampleValues.forEach(value => {\r\n        const button = document.createElement('button');\r\n        button.textContent = value;\r\n        button.onclick = () => {\r\n            input.value = value;\r\n            checkType();\r\n        };\r\n        button.style.margin = '5px';\r\n        buttonContainer.appendChild(button);\r\n    });\r\n    \r\n    document.body.appendChild(buttonContainer);\r\n});\r\n```\r\n\r\n## 💡 오늘 학습에서 발견한 흥미로운 점들\r\n\r\n### 1. JavaScript의 \"이상한\" 동작들\r\n\r\n```javascript\r\n// 타입 비교의 예상 밖 결과들\r\nconsole.log([] + []); // \"\" (빈 문자열)\r\nconsole.log([] + {}); // \"[object Object]\"\r\nconsole.log({} + []); // 0 (브라우저에 따라 다를 수 있음)\r\n\r\nconsole.log(true + true); // 2\r\nconsole.log(true - true); // 0\r\nconsole.log(true * false); // 0\r\n\r\nconsole.log(\"B\" + \"a\" + +\"a\" + \"a\"); // \"BaNaNa\" (+\"a\"는 NaN)\r\n\r\n// 이런 것들을 이해하면 JavaScript의 타입 시스템을 더 깊이 알 수 있다\r\n```\r\n\r\n### 2. 실용적인 타입 체크 패턴\r\n\r\n```javascript\r\n// 안전한 타입 체크 함수들\r\nconst TypeChecker = {\r\n  isString: (value) => typeof value === 'string',\r\n  isNumber: (value) => typeof value === 'number' && !isNaN(value),\r\n  isBoolean: (value) => typeof value === 'boolean',\r\n  isArray: (value) => Array.isArray(value),\r\n  isObject: (value) => value !== null && typeof value === 'object' && !Array.isArray(value),\r\n  isFunction: (value) => typeof value === 'function',\r\n  isNull: (value) => value === null,\r\n  isUndefined: (value) => value === undefined,\r\n  isEmpty: (value) => {\r\n    if (value === null || value === undefined) return true;\r\n    if (typeof value === 'string' || Array.isArray(value)) return value.length === 0;\r\n    if (typeof value === 'object') return Object.keys(value).length === 0;\r\n    return false;\r\n  }\r\n};\r\n\r\n// 사용 예시\r\nconst testValues = [\r\n  \"\",\r\n  0,\r\n  false,\r\n  null,\r\n  undefined,\r\n  [],\r\n  {},\r\n  \"hello\",\r\n  42,\r\n  true\r\n];\r\n\r\ntestValues.forEach(value => {\r\n  console.log(`${JSON.stringify(value)}:`, {\r\n    isEmpty: TypeChecker.isEmpty(value),\r\n    type: typeof value\r\n  });\r\n});\r\n```\r\n\r\n## 🤔 학습 중 어려웠던 개념들\r\n\r\n### 1. == vs === 의 차이\r\n\r\n```javascript\r\n// 동등 연산자(==)의 복잡한 변환 규칙\r\nconsole.log(0 == false); // true\r\nconsole.log(\"\" == false); // true\r\nconsole.log([] == false); // true\r\nconsole.log(null == undefined); // true\r\n\r\n// 일치 연산자(===)는 타입 변환 없이 비교\r\nconsole.log(0 === false); // false\r\nconsole.log(\"\" === false); // false\r\nconsole.log([] === false); // false\r\nconsole.log(null === undefined); // false\r\n\r\n// 권장: 항상 === 사용하기\r\nconst isEqual = (a, b) => a === b;\r\n```\r\n\r\n### 2. 객체의 참조 비교\r\n\r\n```javascript\r\n// 객체는 참조로 비교됨\r\nconst obj1 = { name: \"최도형\" };\r\nconst obj2 = { name: \"최도형\" };\r\nconst obj3 = obj1;\r\n\r\nconsole.log(obj1 === obj2); // false (다른 객체)\r\nconsole.log(obj1 === obj3); // true (같은 참조)\r\n\r\n// 객체 내용 비교 함수\r\nfunction deepEqual(a, b) {\r\n  if (a === b) return true;\r\n  \r\n  if (a == null || b == null) return false;\r\n  \r\n  if (typeof a !== 'object' || typeof b !== 'object') return false;\r\n  \r\n  const keysA = Object.keys(a);\r\n  const keysB = Object.keys(b);\r\n  \r\n  if (keysA.length !== keysB.length) return false;\r\n  \r\n  for (let key of keysA) {\r\n    if (!keysB.includes(key)) return false;\r\n    if (!deepEqual(a[key], b[key])) return false;\r\n  }\r\n  \r\n  return true;\r\n}\r\n\r\nconsole.log(deepEqual(obj1, obj2)); // true (내용이 같음)\r\n```\r\n\r\n## 📈 내일 학습 계획\r\n\r\n내일은 연산자와 조건문을 집중적으로 공부할 예정이다:\r\n\r\n```javascript\r\nconst tomorrowPlan = {\r\n  topics: [\r\n    'arithmetic_operators',      // 산술 연산자\r\n    'comparison_operators',      // 비교 연산자  \r\n    'logical_operators',         // 논리 연산자\r\n    'assignment_operators',      // 할당 연산자\r\n    'conditional_statements',    // 조건문 (if, else, switch)\r\n    'ternary_operator'          // 삼항 연산자\r\n  ],\r\n  \r\n  practiceProjects: [\r\n    'grade_calculator',          // 성적 계산기\r\n    'number_guessing_game',      // 숫자 맞추기 게임\r\n    'simple_validation_system'   // 간단한 유효성 검사 시스템\r\n  ],\r\n  \r\n  studyTime: {\r\n    theory: '2.5시간',\r\n    practice: '3.5시간', \r\n    blogging: '1시간'\r\n  }\r\n};\r\n```\r\n\r\n## 🪬 오늘의 교훈\r\n\r\n변수와 데이터 타입이라는 기초적인 내용이었지만, JavaScript만의 독특한 특징들이 정말 많다는 것을 깨달았다. 특히 타입 변환과 비교 연산 부분에서 다른 언어와는 다른 JavaScript만의 철학(?)을 느낄 수 있었다.\r\n\r\n가장 중요한 깨달음은 **\"기초가 탄탄해야 응용도 가능하다\"**는 것이다. 단순히 코드가 작동한다고 해서 이해한 것이 아니라, 왜 그렇게 동작하는지까지 알아야 진짜 실력이 늘어난다는 것을 실감했다.\r\n\r\n그리고 직접 타입 체커 도구를 만들어보면서, 배운 내용을 바로 실습으로 옮기는 것이 얼마나 효과적인지 알 수 있었다. 내일도 이런 식으로 이론과 실습을 병행하면서 공부해야겠다.\r\n\r\n```javascript\r\n// 오늘의 성장을 코드로 표현\r\nconst todayGrowth = {\r\n  knowledgeGained: [\r\n    'JavaScript 변수 선언의 차이점',\r\n    '7가지 데이터 타입의 특성',\r\n    '타입 변환 메커니즘',\r\n    '실용적인 타입 체크 방법'\r\n  ],\r\n  \r\n  skillsImproved: [\r\n    '문제 해결 능력',\r\n    '코드 디버깅 실력',\r\n    '문서화 능력',\r\n    '실습 프로젝트 구현 능력'\r\n  ],\r\n  \r\n  nextSteps: [\r\n    '연산자 마스터하기',\r\n    '조건문 완전 정복',\r\n    '더 복잡한 프로젝트 도전'\r\n  ],\r\n  \r\n  reflection: function() {\r\n    return \"기초가 탄탄해야 고층 빌딩을 지을 수 있다. 오늘도 한 걸음 성장!\";\r\n  }\r\n};\r\n\r\nconsole.log(todayGrowth.reflection());\r\n```\r\n\r\n---\r\n\r\n## 회고 요약\r\n\r\n- JavaScript 변수 선언(var, let, const)의 차이점과 스코프 완전 이해\r\n- 7가지 데이터 타입과 타입 변환 메커니즘 마스터\r\n- 실습 프로젝트(타입 체커 도구)를 통한 학습 내용 적용\r\n- JavaScript만의 독특한 특징들과 \"이상한\" 동작들 발견\r\n- 이론과 실습을 병행하는 효과적인 학습 방법 확립\r\n- 기초의 중요성과 깊이 있는 이해의 필요성 인식\r\n</rewritten_file> "
    },
    {
      "id": "2025-05-25-auto-generated",
      "title": "JavaScript 기초 다지기와 본격적인 학습 계획 수립",
      "date": "2025-05-25",
      "category": "daily",
      "tags": [
        "블로그",
        "JavaScript",
        "React",
        "CSS",
        "HTML",
        "Node.js",
        "Python",
        "Java",
        "학습",
        "프로젝트",
        "개발",
        "알고리즘"
      ],
      "image": "https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=400&h=200&fit=crop",
      "description": "2025-05-25의 학습 내용 정리",
      "excerpt": "새로운 포스트 테스트를 겸해서 오늘부터 JavaScript를 체계적으로 공부하기로 결심했다! 블로그도 만들었으니 이제 진짜 개발자로 성장하기 위한 첫 걸음을 내딛어보자.\r",
      "content": "# JavaScript 기초 다지기와 본격적인 학습 계획 수립\r\n\r\n새로운 포스트 테스트를 겸해서 오늘부터 JavaScript를 체계적으로 공부하기로 결심했다! 블로그도 만들었으니 이제 진짜 개발자로 성장하기 위한 첫 걸음을 내딛어보자.\r\n\r\n## 🎯 왜 JavaScript부터 시작하는가?\r\n\r\n웹 개발을 본격적으로 시작하려면 여러 언어 중에서 무엇을 먼저 배워야 할지 고민이 많았다. 하지만 JavaScript를 선택한 이유는 명확하다:\r\n\r\n### JavaScript 선택 근거\r\n\r\n```javascript\r\n// JavaScript 학습 우선순위 분석\r\nconst programmingLanguages = {\r\n  javascript: {\r\n    versatility: 5,      // 프론트엔드, 백엔드, 모바일 모두 가능\r\n    jobMarket: 5,        // 구인 수요 높음\r\n    community: 5,        // 활발한 커뮤니티와 풍부한 자료\r\n    learningCurve: 4,    // 비교적 접근하기 쉬움\r\n    futureProof: 5       // 지속적인 발전과 업데이트\r\n  },\r\n  python: {\r\n    versatility: 4,\r\n    jobMarket: 4,\r\n    community: 5,\r\n    learningCurve: 5,\r\n    futureProof: 4\r\n  },\r\n  java: {\r\n    versatility: 3,\r\n    jobMarket: 4,\r\n    community: 4,\r\n    learningCurve: 2,\r\n    futureProof: 4\r\n  }\r\n};\r\n\r\n// 총점 계산\r\nObject.keys(programmingLanguages).forEach(lang => {\r\n  const scores = programmingLanguages[lang];\r\n  const total = Object.values(scores).reduce((sum, score) => sum + score, 0);\r\n  console.log(`${lang}: ${total}점`);\r\n});\r\n\r\n// 결과: JavaScript 24점으로 1위!\r\n```\r\n\r\n특히 예비창업패키지를 준비하면서 웹 서비스를 만들 계획이 있어서, 하나의 언어로 프론트엔드와 백엔드를 모두 다룰 수 있는 JavaScript가 가장 효율적이라고 판단했다.\r\n\r\n## 📚 학습 로드맵과 전략\r\n\r\n체계적인 학습을 위해 단계별 로드맵을 세웠다:\r\n\r\n### Phase 1: 기초 문법 (1-2주)\r\n\r\n```javascript\r\n// 1주차: 변수, 데이터 타입, 연산자\r\nlet studyPlan = {\r\n  week1: [\r\n    'variables_and_constants',\r\n    'data_types',\r\n    'operators',\r\n    'basic_input_output'\r\n  ],\r\n  \r\n  week2: [\r\n    'conditionals',\r\n    'loops',\r\n    'functions',\r\n    'scope_and_hoisting'\r\n  ]\r\n};\r\n\r\n// 매일 학습 목표\r\nconst dailyGoals = {\r\n  theory: '2시간',           // 개념 학습\r\n  practice: '3시간',         // 실습 코딩\r\n  review: '1시간',           // 복습 및 정리\r\n  blogging: '30분'           // 블로그 포스팅\r\n};\r\n```\r\n\r\n### Phase 2: 중급 개념 (3-4주)\r\n\r\n```javascript\r\nconst intermediateTopics = [\r\n  {\r\n    topic: 'Objects and Arrays',\r\n    duration: '1주',\r\n    projects: ['todo_list', 'simple_calculator']\r\n  },\r\n  {\r\n    topic: 'DOM Manipulation',\r\n    duration: '1주', \r\n    projects: ['interactive_webpage', 'form_validation']\r\n  },\r\n  {\r\n    topic: 'Event Handling',\r\n    duration: '1주',\r\n    projects: ['quiz_app', 'image_slider']\r\n  },\r\n  {\r\n    topic: 'Asynchronous JavaScript',\r\n    duration: '1주',\r\n    projects: ['weather_app', 'api_data_fetcher']\r\n  }\r\n];\r\n```\r\n\r\n### Phase 3: 실전 프로젝트 (5-6주)\r\n\r\n```javascript\r\nconst projectMilestones = [\r\n  {\r\n    name: 'Personal Portfolio Website',\r\n    technologies: ['HTML', 'CSS', 'JavaScript'],\r\n    features: [\r\n      'responsive_design',\r\n      'interactive_animations',\r\n      'contact_form',\r\n      'project_showcase'\r\n    ],\r\n    duration: '2주'\r\n  },\r\n  {\r\n    name: 'Task Management App',\r\n    technologies: ['JavaScript', 'Local Storage', 'CSS Grid'],\r\n    features: [\r\n      'crud_operations',\r\n      'data_persistence',\r\n      'filtering_sorting',\r\n      'drag_and_drop'\r\n    ],\r\n    duration: '2주'\r\n  },\r\n  {\r\n    name: 'API Integration Project',\r\n    technologies: ['JavaScript', 'REST API', 'JSON'],\r\n    features: [\r\n      'external_api_calls',\r\n      'error_handling',\r\n      'data_visualization',\r\n      'user_authentication'\r\n    ],\r\n    duration: '2주'\r\n  }\r\n];\r\n```\r\n\r\n## 🛠️ 학습 도구와 환경 설정\r\n\r\n효율적인 학습을 위해 개발 환경을 구축했다:\r\n\r\n```javascript\r\n// 개발 환경 설정\r\nconst developmentSetup = {\r\n  editor: 'VS Code',\r\n  extensions: [\r\n    'Live Server',           // 실시간 미리보기\r\n    'JavaScript ES6 snippets', // 코드 스니펫\r\n    'Prettier',              // 코드 포매팅\r\n    'ESLint',               // 코드 품질 검사\r\n    'Bracket Pair Colorizer' // 괄호 색상 구분\r\n  ],\r\n  \r\n  browser: 'Chrome',\r\n  devTools: [\r\n    'Console',              // 디버깅\r\n    'Elements',             // DOM 검사\r\n    'Sources',              // 브레이크포인트\r\n    'Network'               // 네트워크 요청 모니터링\r\n  ],\r\n  \r\n  learningResources: [\r\n    'MDN Web Docs',         // 공식 문서\r\n    'JavaScript.info',      // 튜토리얼\r\n    'freeCodeCamp',        // 실습 문제\r\n    'Codewars',            // 알고리즘 문제\r\n    'YouTube tutorials'     // 영상 강의\r\n  ]\r\n};\r\n```\r\n\r\n## 📝 첫 번째 실습: Hello World부터 시작\r\n\r\n블로그 포스트 작성을 겸해서 오늘 첫 JavaScript 코드를 작성해봤다:\r\n\r\n```html\r\n<!-- index.html -->\r\n<!DOCTYPE html>\r\n<html lang=\"ko\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>JavaScript 첫 걸음</title>\r\n</head>\r\n<body>\r\n    <h1>JavaScript 학습 시작!</h1>\r\n    <button id=\"greetBtn\">인사하기</button>\r\n    <p id=\"output\"></p>\r\n    \r\n    <script src=\"script.js\"></script>\r\n</body>\r\n</html>\r\n```\r\n\r\n```javascript\r\n// script.js\r\n// 변수 선언과 함수 정의\r\nconst greetButton = document.getElementById('greetBtn');\r\nconst outputElement = document.getElementById('output');\r\n\r\nfunction greetUser() {\r\n    const userName = prompt('이름을 입력하세요:');\r\n    const currentTime = new Date().toLocaleTimeString();\r\n    \r\n    if (userName) {\r\n        outputElement.innerHTML = `\r\n            안녕하세요, ${userName}님! 🎉<br>\r\n            현재 시간: ${currentTime}<br>\r\n            JavaScript 학습을 시작해봅시다!\r\n        `;\r\n    } else {\r\n        outputElement.innerHTML = '이름을 입력해주세요! 😊';\r\n    }\r\n}\r\n\r\n// 이벤트 리스너 추가\r\ngreetButton.addEventListener('click', greetUser);\r\n\r\n// 페이지 로드 완료 메시지\r\nconsole.log('JavaScript 학습 페이지가 로드되었습니다!');\r\n```\r\n\r\n간단한 코드지만 여러 중요한 개념들을 포함하고 있다:\r\n\r\n1. **DOM 조작**: `getElementById()`, `innerHTML`\r\n2. **이벤트 처리**: `addEventListener()`\r\n3. **함수 정의**: `function` 키워드와 화살표 함수\r\n4. **변수 선언**: `const`, `let` 사용\r\n5. **조건문**: `if-else` 구문\r\n6. **템플릿 리터럴**: 백틱(`)과 `${}` 활용\r\n\r\n## 💡 학습하면서 발견한 JavaScript의 특징\r\n\r\n오늘 학습하면서 JavaScript의 독특한 특징들을 발견했다:\r\n\r\n### 1. 동적 타이핑\r\n\r\n```javascript\r\n// 같은 변수에 다른 타입 할당 가능\r\nlet dynamicVariable = 42;           // 숫자\r\nconsole.log(typeof dynamicVariable); // \"number\"\r\n\r\ndynamicVariable = \"Hello World\";    // 문자열\r\nconsole.log(typeof dynamicVariable); // \"string\"\r\n\r\ndynamicVariable = true;             // 불린\r\nconsole.log(typeof dynamicVariable); // \"boolean\"\r\n\r\n// 이런 유연성이 장점이자 단점\r\n// 장점: 빠른 개발과 프로토타이핑\r\n// 단점: 런타임 에러 가능성 증가\r\n```\r\n\r\n### 2. 호이스팅 (Hoisting)\r\n\r\n```javascript\r\n// 변수 선언이 끌어올려짐\r\nconsole.log(hoistedVar); // undefined (에러 아님!)\r\nvar hoistedVar = \"호이스팅 테스트\";\r\n\r\n// 하지만 let, const는 다름\r\ntry {\r\n    console.log(notHoisted); // ReferenceError\r\n    let notHoisted = \"에러 발생\";\r\n} catch (error) {\r\n    console.log(\"let은 호이스팅되지 않음\");\r\n}\r\n```\r\n\r\n### 3. 함수는 일급 객체\r\n\r\n```javascript\r\n// 함수를 변수에 할당\r\nconst greet = function(name) {\r\n    return `안녕하세요, ${name}님!`;\r\n};\r\n\r\n// 함수를 다른 함수의 인수로 전달\r\nfunction processUserInput(callback) {\r\n    const input = prompt(\"이름을 입력하세요:\");\r\n    return callback(input);\r\n}\r\n\r\nconst result = processUserInput(greet);\r\nconsole.log(result);\r\n\r\n// 함수를 배열에 저장\r\nconst mathOperations = [\r\n    (a, b) => a + b,\r\n    (a, b) => a - b,\r\n    (a, b) => a * b,\r\n    (a, b) => a / b\r\n];\r\n\r\nconsole.log(mathOperations[0](5, 3)); // 8\r\n```\r\n\r\n## 🤔 오늘 학습에서 어려웠던 점\r\n\r\n1. **스코프와 클로저**: 아직 완전히 이해하지 못한 개념\r\n2. **비동기 처리**: `setTimeout`, `Promise` 등의 개념이 헷갈림\r\n3. **`this` 키워드**: 컨텍스트에 따라 달라지는 것이 복잡\r\n\r\n```javascript\r\n// 아직 완전히 이해하지 못한 this 바인딩\r\nconst person = {\r\n    name: '최도형',\r\n    greet: function() {\r\n        console.log(`안녕하세요, ${this.name}입니다`);\r\n    }\r\n};\r\n\r\nperson.greet(); // \"안녕하세요, 최도형입니다\"\r\n\r\nconst greetFunction = person.greet;\r\ngreetFunction(); // \"안녕하세요, undefined입니다\" (?)\r\n\r\n// 이런 부분들을 더 깊이 공부해야겠다\r\n```\r\n\r\n## 📈 내일부터의 학습 계획\r\n\r\n구체적인 일일 학습 스케줄을 세웠다:\r\n\r\n```javascript\r\nconst weeklySchedule = {\r\n  monday: {\r\n    morning: 'JavaScript 기초 문법 (변수, 연산자)',\r\n    afternoon: '실습 문제 풀이 (10문제)',\r\n    evening: '학습 내용 블로그 정리'\r\n  },\r\n  \r\n  tuesday: {\r\n    morning: '조건문과 반복문',\r\n    afternoon: '간단한 프로젝트 (계산기 만들기)',\r\n    evening: '코드 리뷰 및 개선'\r\n  },\r\n  \r\n  wednesday: {\r\n    morning: '함수와 스코프',\r\n    afternoon: '함수 활용 실습',\r\n    evening: '어려웠던 개념 정리'\r\n  },\r\n  \r\n  // ... 나머지 요일들\r\n  \r\n  sunday: {\r\n    morning: '주간 학습 복습',\r\n    afternoon: '미니 프로젝트 진행',\r\n    evening: '다음 주 계획 수립'\r\n  }\r\n};\r\n```\r\n\r\n## 🚀 예비창업패키지와의 연계\r\n\r\nJavaScript 학습이 창업 준비에 어떻게 도움이 될지 생각해봤다:\r\n\r\n```python\r\n# 창업 프로젝트에서 JavaScript 활용 계획\r\nclass StartupTechStack:\r\n    def __init__(self):\r\n        self.frontend = ['HTML', 'CSS', 'JavaScript', 'React']\r\n        self.backend = ['Node.js', 'Express.js']\r\n        self.database = ['MongoDB', 'Firebase']\r\n        self.deployment = ['Netlify', 'Heroku', 'AWS']\r\n    \r\n    def estimate_development_time(self):\r\n        return {\r\n            'mvp_prototype': '6주',\r\n            'beta_version': '12주', \r\n            'production_ready': '20주'\r\n        }\r\n    \r\n    def calculate_cost_savings(self):\r\n        # 풀스택 JavaScript로 개발자 1명으로 가능\r\n        traditional_team_cost = 3000  # 개발자 3명 * 월 1000만원\r\n        fullstack_js_cost = 1000      # 개발자 1명 * 월 1000만원\r\n        savings = traditional_team_cost - fullstack_js_cost\r\n        \r\n        return f\"월 {savings}만원 절약 가능\"\r\n```\r\n\r\n## 💭 학습 동기와 각오\r\n\r\n블로그 첫 포스트에서 다짐한 것처럼, 체계적인 학습과 꾸준한 기록을 통해 실력을 쌓아가겠다. JavaScript는 단순히 프로그래밍 언어를 배우는 것이 아니라, 웹 개발자로서의 첫 걸음이자 창업가로서의 기술적 역량을 기르는 과정이다.\r\n\r\n```javascript\r\n// 나의 학습 다짐을 코드로 표현\r\nconst myLearningCommitment = {\r\n    dailyStudy: {\r\n        minimumHours: 4,\r\n        consistency: true,\r\n        blogPosting: true\r\n    },\r\n    \r\n    goals: {\r\n        shortTerm: '6주 내 기본기 완성',\r\n        mediumTerm: '3개월 내 실전 프로젝트 완성',\r\n        longTerm: '6개월 내 창업 아이템 MVP 개발'\r\n    },\r\n    \r\n    trackProgress: function() {\r\n        const today = new Date();\r\n        console.log(`${today.toLocaleDateString()}: JavaScript 학습 계속 진행 중!`);\r\n        return this.dailyStudy.consistency;\r\n    }\r\n};\r\n\r\n// 매일 실행할 다짐!\r\nmyLearningCommitment.trackProgress();\r\n```\r\n\r\n## 🪬 오늘의 교훈\r\n\r\nJavaScript 학습을 시작하면서 가장 크게 느낀 것은 '꾸준함의 중요성'이다. 단순히 문법을 외우는 것이 아니라, 실제로 손으로 코드를 작성하고 에러를 만나고 해결하는 과정에서 진짜 실력이 늘어난다는 것을 알았다.\r\n\r\n특히 오늘 간단한 \"Hello World\" 예제를 만들면서도 DOM 조작, 이벤트 처리, 함수 정의 등 여러 개념들이 유기적으로 연결되어 있다는 것을 깨달았다. 앞으로 더 복잡한 프로젝트를 만들어가면서 이런 개념들이 어떻게 조합되는지 경험해보고 싶다.\r\n\r\n무엇보다 블로그에 학습 과정을 기록하니, 하루 동안 무엇을 배웠는지 명확하게 정리되고 스스로도 성취감을 느낄 수 있어서 좋다. 내일부터는 정말 \"빡세게\" 공부해보자!\r\n\r\n---\r\n\r\n## 회고 요약\r\n\r\n- JavaScript 학습을 위한 체계적인 로드맵과 일일 계획 수립\r\n- 개발 환경 구축 및 첫 번째 실습 프로젝트 완성\r\n- JavaScript의 독특한 특징들(동적 타이핑, 호이스팅, 일급 객체) 학습\r\n- 예비창업패키지 프로젝트와의 연계점 파악\r\n- 꾸준한 학습과 블로그 기록의 중요성 인식\r\n- 실습 중심의 학습 방법론 확립"
    },
    {
      "id": "2025-05-24-auto-generated",
      "title": "개인 블로그 개설과 GitHub Pages 첫 발걸음",
      "date": "2025-05-24",
      "category": "daily",
      "tags": [
        "Git",
        "블로그",
        "JavaScript",
        "CSS",
        "HTML",
        "Python",
        "Java",
        "학습",
        "프로젝트",
        "개발"
      ],
      "image": "https://images.unsplash.com/photo-1518432031352-d6fc5c10da5a?w=400&h=200&fit=crop",
      "description": "2025-05-24의 학습 내용 정리",
      "excerpt": "오늘은 드디어 개인 블로그를 GitHub Pages로 개설했다! 개발자로서 꾸준한 학습과 성장을 기록할 공간을 만들고 싶었는데, 첫 번째 포스트를 올리니 뭔가 뿌듯하면서도 설레는 ...",
      "content": "# 개인 블로그 개설과 GitHub Pages 첫 발걸음\r\n\r\n오늘은 드디어 개인 블로그를 GitHub Pages로 개설했다! 개발자로서 꾸준한 학습과 성장을 기록할 공간을 만들고 싶었는데, 첫 번째 포스트를 올리니 뭔가 뿌듯하면서도 설레는 기분이다.\r\n\r\n## 🎯 블로그 개설 동기\r\n\r\n지금까지는 학습한 내용들을 개인적으로만 정리해왔는데, 몇 가지 아쉬운 점들이 있었다:\r\n\r\n1. **체계적인 정리 부족**: 메모장이나 노션에 흩어져 있는 내용들\r\n2. **복습과 활용 어려움**: 나중에 다시 찾아보기 힘든 구조\r\n3. **성장 과정 추적 불가**: 시간이 지나면서 어떻게 발전했는지 모르겠음\r\n4. **지식 공유 기회 상실**: 혼자만 알고 있기에는 아까운 내용들\r\n\r\n그래서 블로그라는 형태로 정리하면서 다음과 같은 목표를 세웠다:\r\n\r\n```markdown\r\n## 블로그 운영 목표\r\n- 매일 학습한 내용을 체계적으로 정리\r\n- 실제 프로젝트에 적용한 경험과 결과 공유\r\n- 문제 해결 과정과 시행착오 기록\r\n- 개발자로서의 성장 과정 추적\r\n- 같은 고민을 하는 다른 개발자들과 지식 공유\r\n```\r\n\r\n## 🛠️ GitHub Pages 선택 이유\r\n\r\n블로그 플랫폼을 선택할 때 여러 옵션을 고려했다:\r\n\r\n### 비교 분석\r\n\r\n| 플랫폼 | 장점 | 단점 | 점수 |\r\n|--------|------|------|------|\r\n| **GitHub Pages** | 무료, 버전 관리, 개발자 친화적 | 초기 설정 복잡 | ⭐⭐⭐⭐⭐ |\r\n| Tistory | 한국형, 쉬운 사용 | 커스터마이징 제한 | ⭐⭐⭐ |\r\n| Velog | 개발자 특화, 마크다운 | 플랫폼 의존성 | ⭐⭐⭐⭐ |\r\n| Medium | 글로벌, 네트워킹 | 한국어 SEO 약함 | ⭐⭐⭐ |\r\n\r\nGitHub Pages를 선택한 핵심 이유:\r\n\r\n```javascript\r\n// GitHub Pages 선택 로직\r\nconst blogPlatformSelector = {\r\n  criteria: {\r\n    cost: 0,              // 무료여야 함\r\n    customization: 5,     // 높은 커스터마이징 필요\r\n    versionControl: 5,    // Git 연동 필수\r\n    developerFriendly: 5, // 개발자 워크플로우 적합\r\n    ownership: 5          // 콘텐츠 소유권 중요\r\n  },\r\n  \r\n  evaluate(platform) {\r\n    if (platform === 'githubPages') {\r\n      return this.criteria.cost + \r\n             this.criteria.customization + \r\n             this.criteria.versionControl + \r\n             this.criteria.developerFriendly + \r\n             this.criteria.ownership;\r\n    }\r\n    // 다른 플랫폼들은 일부 기준에서 점수가 낮음\r\n  }\r\n};\r\n\r\nconsole.log(blogPlatformSelector.evaluate('githubPages')); // 25점 만점\r\n```\r\n\r\n## 📁 프로젝트 구조 설계\r\n\r\n블로그의 지속가능성을 위해 체계적인 구조를 계획했다:\r\n\r\n```\r\nstylechoi.github.io/\r\n├── _config.yml          # Jekyll 설정\r\n├── index.md             # 메인 페이지\r\n├── about.md             # 소개 페이지\r\n├── posts/\r\n│   ├── daily/           # 일일 회고\r\n│   │   ├── 2025-05/\r\n│   │   └── 2025-04/\r\n│   ├── projects/        # 프로젝트 회고\r\n│   ├── tutorials/       # 튜토리얼\r\n│   └── reviews/         # 도서/강의 리뷰\r\n├── assets/\r\n│   ├── css/\r\n│   ├── js/\r\n│   └── images/\r\n└── _layouts/            # 페이지 템플릿\r\n    ├── default.html\r\n    ├── post.html\r\n    └── archive.html\r\n```\r\n\r\n이런 구조를 선택한 이유:\r\n\r\n1. **카테고리별 분류**: 내용의 성격에 따라 폴더 분리\r\n2. **날짜별 정리**: 일일 회고는 년월별로 체계적 관리\r\n3. **확장 가능성**: 새로운 카테고리 추가 용이\r\n4. **유지보수성**: 파일 위치 예측 가능하고 관리 편함\r\n\r\n## 🔧 기술 스택과 도구\r\n\r\n```yaml\r\n# _config.yml\r\ntheme: minima\r\nmarkdown: kramdown\r\nhighlighter: rouge\r\nplugins:\r\n  - jekyll-feed\r\n  - jekyll-sitemap\r\n  - jekyll-seo-tag\r\n\r\n# 개발 환경\r\ndevelopment_tools:\r\n  - VS Code (Markdown 편집)\r\n  - Git (버전 관리)\r\n  - GitHub Desktop (GUI)\r\n  - Markdown Preview Enhanced (미리보기)\r\n```\r\n\r\n앞으로 추가할 기능들:\r\n\r\n```javascript\r\n// 향후 개선 계획\r\nconst blogImprovements = [\r\n  {\r\n    feature: 'search_functionality',\r\n    priority: 'high',\r\n    description: '포스트 검색 기능 추가'\r\n  },\r\n  {\r\n    feature: 'comment_system',\r\n    priority: 'medium', \r\n    description: 'Utterances로 댓글 시스템 구축'\r\n  },\r\n  {\r\n    feature: 'analytics',\r\n    priority: 'medium',\r\n    description: 'Google Analytics 연동으로 방문자 분석'\r\n  },\r\n  {\r\n    feature: 'rss_feed',\r\n    priority: 'low',\r\n    description: 'RSS 피드로 구독 기능 제공'\r\n  }\r\n];\r\n```\r\n\r\n## 💭 첫 포스트에 대한 소감\r\n\r\n블로그 첫 포스트를 작성하면서 든 생각들:\r\n\r\n**✅ 좋았던 점**:\r\n- Markdown으로 작성하니 개발자답고 깔끔함\r\n- Git으로 버전 관리되니 변경 이력 추적 가능\r\n- 무료지만 전문적인 느낌의 블로그 완성\r\n\r\n**⚠️ 아쉬운 점**:\r\n- 초기 설정에 시간이 꽤 소요됨\r\n- 테마 커스터마이징이 생각보다 복잡\r\n- SEO 최적화 등 추가 작업 필요\r\n\r\n**🚀 앞으로의 계획**:\r\n\r\n```markdown\r\n## 단기 목표 (1개월)\r\n- [ ] 매일 최소 1개 포스트 작성\r\n- [ ] 카테고리별 템플릿 정립\r\n- [ ] 기본적인 SEO 설정 완료\r\n\r\n## 중기 목표 (3개월)  \r\n- [ ] 총 100개 포스트 달성\r\n- [ ] 댓글 시스템 구축\r\n- [ ] 검색 기능 추가\r\n- [ ] 방문자 분석 도구 연동\r\n\r\n## 장기 목표 (6개월)\r\n- [ ] 매월 일정 수준의 방문자 확보\r\n- [ ] 시리즈 포스트 5개 이상 완성\r\n- [ ] 다른 개발자들과의 네트워킹 확대\r\n```\r\n\r\n## 🎯 예비창업패키지 준비와의 연계\r\n\r\n이 블로그가 예비창업패키지 준비에도 도움이 될 것 같다:\r\n\r\n1. **포트폴리오 역할**: 개발 역량과 성장 과정 증명\r\n2. **문제 해결 능력 증명**: 실제 프로젝트 경험과 시행착오 기록\r\n3. **커뮤니케이션 능력**: 기술적 내용을 명확하게 설명하는 능력\r\n4. **지속성과 열정**: 꾸준한 학습과 성장 의지 보여줌\r\n\r\n```python\r\n# 창업 준비에 활용할 블로그 컨텐츠 전략\r\nclass StartupBlogStrategy:\r\n    def __init__(self):\r\n        self.content_categories = [\r\n            'technical_skills',      # 기술 역량 증명\r\n            'problem_solving',       # 문제 해결 사례\r\n            'project_experience',    # 프로젝트 경험\r\n            'market_research',       # 시장 조사 및 분석\r\n            'business_insights'      # 비즈니스 인사이트\r\n        ]\r\n    \r\n    def create_portfolio_content(self):\r\n        return {\r\n            'credibility': '실제 코드와 결과물로 검증',\r\n            'growth': '시간에 따른 발전 과정 추적',\r\n            'communication': '복잡한 개념의 명확한 설명',\r\n            'passion': '지속적인 학습과 도전 정신'\r\n        }\r\n```\r\n\r\n## 🔮 기대하는 변화\r\n\r\n블로그를 통해 기대하는 개인적 변화:\r\n\r\n1. **학습 효율성 증대**: 글로 정리하면서 더 깊이 이해\r\n2. **지식 체계화**: 흩어진 정보를 논리적으로 구조화\r\n3. **설명 능력 향상**: 남에게 설명할 수 있을 정도로 명확히 파악\r\n4. **네트워킹 확대**: 같은 관심사를 가진 개발자들과 교류\r\n5. **자신감 증대**: 공개적으로 지식을 공유하는 용기\r\n\r\n## 💡 내일 계획\r\n\r\n1. **카테고리별 템플릿 정립**: 일관된 포스트 구조 만들기\r\n2. **첫 번째 기술 포스트**: JavaScript 관련 학습 내용 정리\r\n3. **블로그 메타 정보 최적화**: SEO를 위한 기본 설정\r\n\r\n## 🪬 오늘의 교훈\r\n\r\n블로그 개설은 단순한 웹사이트 만들기가 아니라, 내 생각과 학습을 체계화하는 도구를 만드는 과정이었다. 앞으로 이 공간이 내 성장의 발자취이자, 다른 개발자들에게도 도움이 되는 지식 공유의 장이 되기를 바란다.\r\n\r\n개발자로서 가장 중요한 것은 끊임없는 학습과 성장인데, 블로그라는 도구를 통해 이 과정을 더욱 체계적이고 의미있게 만들어갈 수 있을 것 같다. 첫 걸음을 뗀 오늘, 앞으로의 여정이 기대된다!\r\n\r\n---\r\n\r\n## 회고 요약\r\n\r\n- GitHub Pages로 개인 블로그 성공적으로 개설\r\n- 체계적인 디렉토리 구조와 콘텐츠 전략 수립\r\n- 블로그를 통한 학습 효율성과 지식 공유 기대\r\n- 예비창업패키지 준비를 위한 포트폴리오 도구로 활용 계획\r\n- 꾸준한 포스팅을 통한 개발자로서의 성장 의지 다짐"
    },
    {
      "id": "2025-05-22-auto-generated",
      "title": "Claude와 MCP를 활용한 AI 개발 환경 구축 학습",
      "date": "2025-05-22",
      "category": "daily",
      "tags": [
        "Git",
        "JavaScript",
        "React",
        "Python",
        "Java",
        "학습",
        "프로젝트",
        "개발"
      ],
      "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=400&h=200&fit=crop",
      "description": "2025-05-22의 학습 내용 정리",
      "excerpt": "오늘은 Claude의 Model Context Protocol(MCP)을 통해 로컬 파일 시스템에 접근하고, AI와 실제 개발 환경을 연동하는 방법을 직접 체험했다. 이전까지는 A...",
      "content": "# Claude와 MCP를 활용한 AI 개발 환경 구축 학습\r\n\r\n오늘은 Claude의 Model Context Protocol(MCP)을 통해 로컬 파일 시스템에 접근하고, AI와 실제 개발 환경을 연동하는 방법을 직접 체험했다. 이전까지는 AI를 단순한 질문-답변 도구로만 생각했는데, 실제 개발 워크플로우에 통합할 수 있다는 점이 흥미로웠다.\r\n\r\n## 🤖 MCP (Model Context Protocol) 이해\r\n\r\nMCP는 Claude가 로컬 시스템의 파일, 데이터베이스, API 등에 직접 접근할 수 있게 해주는 프로토콜이다. 오늘 실제로 사용해보니 몇 가지 강력한 기능을 발견했다:\r\n\r\n1. **로컬 파일 시스템 접근**: Claude가 직접 프로젝트 폴더를 읽고 파일을 분석할 수 있음\r\n2. **코드 패턴 학습**: 기존 코드 스타일을 파악해서 일관된 형태로 새 코드 생성 가능\r\n3. **실시간 협업**: 개발자의 기존 워크플로우를 학습해서 맞춤형 지원 제공\r\n\r\n```javascript\r\n// MCP를 통해 Claude가 직접 파일을 읽고 분석한 후 생성한 코드 예시\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\n// 기존 프로젝트 구조를 분석해서 일관된 네이밍 컨벤션 적용\r\nasync function generateDailyRetrospective(date) {\r\n  const retrospectiveTemplate = await analyzeExistingFiles();\r\n  const formattedDate = formatDate(date);\r\n  \r\n  return {\r\n    filename: `${formattedDate}.md`,\r\n    content: generateMarkdownContent(retrospectiveTemplate)\r\n  };\r\n}\r\n```\r\n\r\n이런 방식의 AI 활용이 흥미로운 이유:\r\n- **컨텍스트 인식**: 단순히 일반적인 답변이 아니라 내 프로젝트 상황에 맞는 구체적인 도움\r\n- **학습 능력**: 내가 사용하는 코딩 스타일이나 폴더 구조를 파악해서 일관성 유지\r\n- **자동화 가능성**: 반복적인 작업들을 AI가 패턴을 학습해서 자동화해줄 수 있을 것 같음\r\n\r\n## 📝 회고 작성 프로세스 자동화\r\n\r\n오늘의 가장 실용적인 성과는 tech-retrospective 작성 과정을 부분적으로 자동화한 것이다. 기존에는:\r\n\r\n1. 매일 빈 파일 생성\r\n2. 날짜와 제목 수동 입력\r\n3. 카테고리별 섹션 수동 구성\r\n4. 내용 작성\r\n\r\n이 과정을 MCP 활용으로 개선:\r\n\r\n```bash\r\n# Before: 수동으로 파일 생성하고 템플릿 복사\r\ntouch 2025-05-22.md\r\n# 템플릿 내용 수동 복사...\r\n\r\n# After: Claude가 기존 패턴 분석해서 자동 생성\r\n# 1. 기존 파일들 분석해서 일관된 구조 파악\r\n# 2. 오늘 날짜로 파일명 자동 생성\r\n# 3. 내 스타일에 맞는 템플릿 자동 적용\r\n```\r\n\r\n이렇게 자동화하니 몇 가지 이점이 있었다:\r\n- **인지 부하 감소**: 매번 \"어떤 구조로 쓸까\" 고민할 필요 없음\r\n- **일관성 유지**: AI가 기존 패턴을 학습해서 스타일 통일\r\n- **집중력 향상**: 형식보다는 내용에 더 집중할 수 있음\r\n\r\n## 🛠️ 개발 환경에서의 AI 활용 확장\r\n\r\nMCP 경험을 통해 AI를 개발 워크플로우에 더 깊이 통합할 수 있는 아이디어들이 떠올랐다:\r\n\r\n1. **코드 리뷰 자동화**:\r\n   ```javascript\r\n   // AI가 내 코딩 스타일을 학습한 후\r\n   // Git commit 전에 자동으로 코드 스타일 검토\r\n   function autoCodeReview(filePath) {\r\n     const codeStyle = analyzeMyCodeStyle();\r\n     const suggestions = checkConsistency(filePath, codeStyle);\r\n     return suggestions;\r\n   }\r\n   ```\r\n\r\n2. **프로젝트 문서화**:\r\n   ```markdown\r\n   # AI가 자동으로 생성할 수 있는 문서들\r\n   - README.md (프로젝트 구조 분석 후 자동 생성)\r\n   - API 문서 (코드 주석과 함수 시그니처 분석)\r\n   - 변경 이력 (Git 로그와 코드 변화 분석)\r\n   ```\r\n\r\n3. **개발 환경 설정 자동화**:\r\n   ```json\r\n   {\r\n     \"scripts\": {\r\n       \"setup\": \"AI가 프로젝트 분석 후 필요한 의존성과 설정 자동 구성\",\r\n       \"lint\": \"내 코딩 스타일에 맞는 린트 룰 자동 적용\",\r\n       \"test\": \"코드 패턴 분석 후 테스트 케이스 자동 생성\"\r\n     }\r\n   }\r\n   ```\r\n\r\n## 💭 AI와 함께하는 개발의 가능성\r\n\r\n오늘 경험을 통해 AI의 역할에 대한 인식이 바뀌었다:\r\n\r\n**🔴 이전 생각**: AI는 모르는 것을 물어보는 도구\r\n- \"React에서 useState 어떻게 써?\"\r\n- \"JavaScript 배열 메서드 알려줘\"\r\n\r\n**🟢 새로운 관점**: AI는 개발 파트너이자 생산성 도구\r\n- 내 코딩 스타일을 학습해서 일관된 코드 생성\r\n- 반복적인 작업 패턴을 파악해서 자동화\r\n- 프로젝트 컨텍스트를 이해한 맞춤형 제안\r\n\r\n```python\r\n# 예를 들어 Python 프로젝트에서\r\nclass AIAssistant:\r\n    def __init__(self, project_context):\r\n        self.context = project_context\r\n        self.coding_style = self.analyze_existing_code()\r\n        \r\n    def suggest_refactoring(self, file_path):\r\n        # 기존 코드 스타일과 프로젝트 구조를 고려한 리팩토링 제안\r\n        pass\r\n        \r\n    def generate_tests(self, function_signature):\r\n        # 프로젝트의 테스트 패턴을 학습해서 일관된 테스트 코드 생성\r\n        pass\r\n```\r\n\r\n## 🚀 예비창업패키지 준비에 적용할 점\r\n\r\n예비창업패키지 프로젝트 준비할 때 AI를 어떻게 활용할지 구체적인 계획을 세워보았다:\r\n\r\n1. **프로젝트 기획 단계**:\r\n   - 시장 조사 데이터 분석\r\n   - 경쟁사 기능 분석 및 차별화 포인트 도출\r\n   - 기술 스택 선택 근거 문서화\r\n\r\n2. **개발 단계**:\r\n   - 일관된 코딩 스타일 유지 (AI가 스타일 가이드 학습)\r\n   - 자동 테스트 코드 생성\r\n   - API 문서 자동화\r\n\r\n3. **문서화 단계**:\r\n   - 사업계획서 초안 작성 지원\r\n   - 기술 문서 자동 생성\r\n   - 프레젠테이션 자료 구조화\r\n\r\n특히 스타트업에서는 빠른 개발과 높은 품질을 동시에 달성해야 하는데, AI 활용으로 이 두 마리 토끼를 잡을 수 있을 것 같다.\r\n\r\n## 🤔 현재 한계점과 주의사항\r\n\r\n물론 AI 활용에도 몇 가지 주의할 점들을 발견했다:\r\n\r\n1. **과도한 의존 위험**: AI가 생성한 코드를 무작정 신뢰하면 안 됨\r\n2. **보안 고려사항**: 민감한 데이터나 API 키 등이 AI에 노출되지 않도록 주의\r\n3. **학습 데이터의 한계**: AI가 학습하지 못한 최신 기술이나 특수한 상황에서는 부정확할 수 있음\r\n\r\n```javascript\r\n// 예: AI 생성 코드를 사용할 때의 체크리스트\r\nconst aiGeneratedCodeChecklist = [\r\n  '보안 취약점 검토',\r\n  '성능 최적화 확인',\r\n  '기존 코드와의 일관성 검증',\r\n  '테스트 코드 작성',\r\n  '문서화 업데이트'\r\n];\r\n```\r\n\r\n## 💡 내일 학습 계획\r\n\r\n1. **MCP 심화**: 다른 개발 도구들(Git, Database)과의 연동 방법 학습\r\n2. **AI 코드 리뷰**: AI가 생성한 코드의 품질을 평가하는 방법론 연구\r\n3. **자동화 워크플로우**: GitHub Actions와 AI를 결합한 CI/CD 파이프라인 설계\r\n\r\n## 🪬 오늘의 교훈\r\n\r\nAI는 단순한 도구가 아니라 학습하고 적응하는 파트너라는 점을 깨달았다. 내가 AI에게 더 많은 컨텍스트를 제공할수록, AI도 더 정확하고 유용한 도움을 줄 수 있다. 마치 신입 개발자가 점차 팀의 코딩 스타일과 프로젝트 구조를 익혀가는 것처럼, AI도 내 개발 패턴을 학습해서 더 나은 협업 파트너가 될 수 있다는 가능성을 보았다.\r\n\r\n개발에서 중요한 것은 기술 자체가 아니라 그 기술을 어떻게 효과적으로 활용하느냐인데, AI도 마찬가지인 것 같다. 단순히 코드를 생성해달라고 요청하는 것보다, AI가 내 상황을 이해하고 맞춤형 도움을 줄 수 있도록 충분한 컨텍스트를 제공하는 것이 핵심이다.\r\n\r\n---\r\n\r\n## 회고 요약\r\n\r\n- MCP를 통한 AI와 로컬 개발 환경 연동 첫 경험\r\n- 회고 작성 프로세스 부분 자동화로 생산성 향상\r\n- AI를 단순 도구에서 개발 파트너로 인식 전환\r\n- 예비창업패키지 프로젝트에 AI 활용 방안 구체화\r\n- AI 의존도와 보안 측면의 주의사항 인식\r\n- 컨텍스트 제공의 중요성과 점진적 학습 파트너십 개념 이해"
    },
    {
      "id": "2025-05-21-auto-generated",
      "title": "웹 워커와 멀티스레딩 기반 성능 최적화",
      "date": "2025-05-21",
      "category": "daily",
      "tags": [
        "JavaScript",
        "CSS",
        "HTML",
        "Java",
        "학습",
        "프로젝트"
      ],
      "image": "https://images.unsplash.com/photo-1504639725590-34d0984388bd?w=400&h=200&fit=crop",
      "description": "2025-05-21의 학습 내용 정리",
      "excerpt": "오늘은 웹 워커를 활용한 JavaScript 멀티스레딩과 고성능 웹 애플리케이션 구현 방법에 대해 집중적으로 공부했다. 특히 애니메이션이 많은 웹앱에서 성능 병목 현상을 해결하는 ...",
      "content": "# 웹 워커와 멀티스레딩 기반 성능 최적화\r\n\r\n오늘은 웹 워커를 활용한 JavaScript 멀티스레딩과 고성능 웹 애플리케이션 구현 방법에 대해 집중적으로 공부했다. 특히 애니메이션이 많은 웹앱에서 성능 병목 현상을 해결하는 방법을 실험해봤다.\r\n\r\n## 🔁 웹 워커 기본과 활용\r\n\r\n무거운 작업을 메인 스레드에서 분리하기 위한 웹 워커에 대해 학습했다:\r\n\r\n### 웹 워커 기본 구현\r\n\r\n```javascript\r\n// main.js (메인 스레드)\r\nconst worker = new Worker('worker.js');\r\n\r\ndocument.getElementById('calculate-btn').addEventListener('click', () => {\r\n  const num = parseInt(document.getElementById('number-input').value);\r\n  \r\n  // 워커에게 메시지 전송\r\n  worker.postMessage({ type: 'CALCULATE_PRIMES', payload: num });\r\n  \r\n  // UI 업데이트 (진행 중 표시)\r\n  document.getElementById('status').textContent = '계산 중...';\r\n});\r\n\r\n// 워커로부터 응답 수신\r\nworker.onmessage = function(event) {\r\n  const { type, payload } = event.data;\r\n  \r\n  if (type === 'PROGRESS') {\r\n    document.getElementById('progress-bar').style.width = `${payload}%`;\r\n  }\r\n  else if (type === 'RESULT') {\r\n    document.getElementById('status').textContent = '완료!';\r\n    displayResults(payload);\r\n  }\r\n};\r\n\r\n// worker.js (워커 스레드)\r\nonmessage = function(event) {\r\n  const { type, payload } = event.data;\r\n  \r\n  if (type === 'CALCULATE_PRIMES') {\r\n    const primes = [];\r\n    const num = payload;\r\n    \r\n    for (let i = 2; i <= num; i++) {\r\n      // 진행률 보고 (10000개마다)\r\n      if (i % 10000 === 0) {\r\n        postMessage({\r\n          type: 'PROGRESS',\r\n          payload: Math.floor((i / num) * 100)\r\n        });\r\n      }\r\n      \r\n      let isPrime = true;\r\n      for (let j = 2; j < i; j++) {\r\n        if (i % j === 0) {\r\n          isPrime = false;\r\n          break;\r\n        }\r\n      }\r\n      if (isPrime) primes.push(i);\r\n    }\r\n    \r\n    // 결과 반환\r\n    postMessage({\r\n      type: 'RESULT',\r\n      payload: primes\r\n    });\r\n  }\r\n};\r\n```\r\n\r\n### 웹 워커 장단점 분석\r\n\r\n👍 **장점**:\r\n- 메인 스레드 블로킹 방지로 UI 반응성 유지\r\n- 멀티코어 CPU 활용 가능\r\n- 복잡한 계산, 데이터 처리에 적합\r\n\r\n👎 **단점**:\r\n- DOM 직접 접근 불가능 (메인 스레드와 통신 필요)\r\n- 메모리 오버헤드 증가\r\n- 스레드 간 통신에 시간 소요\r\n\r\n## 🔄 SharedArrayBuffer와 Atomics\r\n\r\n최근 웹 표준에 추가된 SharedArrayBuffer와 Atomics API에 대해서도 학습했다:\r\n\r\n```javascript\r\n// 메인 스레드\r\nconst buffer = new SharedArrayBuffer(4); // 4바이트 버퍼\r\nconst view = new Int32Array(buffer); // Int32 뷰\r\n\r\nview[0] = 123; // 초기값 설정\r\n\r\nconst worker = new Worker('shared-worker.js');\r\nworker.postMessage({ buffer }); // 워커에 공유 버퍼 전달\r\n\r\n// 워커 스레드 (shared-worker.js)\r\nonmessage = function(event) {\r\n  const { buffer } = event.data;\r\n  const view = new Int32Array(buffer);\r\n  \r\n  // Atomics.add로 원자적 연산 수행\r\n  const oldValue = Atomics.add(view, 0, 42);\r\n  console.log('이전 값:', oldValue); // 123\r\n  console.log('새 값:', view[0]); // 165 (123 + 42)\r\n  \r\n  // 메인 스레드에 알림\r\n  postMessage('완료');\r\n};\r\n\r\n// 메인 스레드에서 워커 응답 처리\r\nworker.onmessage = function() {\r\n  console.log('최종 값:', view[0]); // 165\r\n};\r\n```\r\n\r\n## 🎨 캔버스 애니메이션 최적화\r\n\r\n웹 워커와 이벤트 루프 지식을 활용해 캔버스 애니메이션을 최적화하는 프로젝트를 진행했다:\r\n\r\n```javascript\r\n// main.js\r\nconst canvas = document.getElementById('game-canvas');\r\nconst ctx = canvas.getContext('2d');\r\nconst particleWorker = new Worker('particle-worker.js');\r\n\r\n// 게임 상태\r\nlet particles = []; // 파티클 데이터 저장\r\nlet rendering = false;\r\n\r\n// 워커 초기화\r\nparticleWorker.postMessage({\r\n  type: 'INIT',\r\n  payload: {\r\n    width: canvas.width,\r\n    height: canvas.height,\r\n    particleCount: 5000\r\n  }\r\n});\r\n\r\n// 워커로부터 업데이트된 파티클 데이터 수신\r\nparticleWorker.onmessage = function(event) {\r\n  const { type, payload } = event.data;\r\n  \r\n  if (type === 'UPDATE') {\r\n    particles = payload;\r\n    \r\n    // 렌더링 중이 아니면 렌더링 시작\r\n    if (!rendering) {\r\n      rendering = true;\r\n      requestAnimationFrame(render);\r\n    }\r\n  }\r\n};\r\n\r\n// 렌더링 함수 (메인 스레드에서 실행)\r\nfunction render() {\r\n  // 캔버스 지우기\r\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n  \r\n  // 모든 파티클 그리기\r\n  ctx.fillStyle = 'rgba(0, 150, 255, 0.5)';\r\n  particles.forEach(particle => {\r\n    ctx.beginPath();\r\n    ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);\r\n    ctx.fill();\r\n  });\r\n  \r\n  // 다음 프레임 요청\r\n  rendering = true;\r\n  requestAnimationFrame(render);\r\n}\r\n\r\n// 애니메이션 시작\r\ndocument.getElementById('start-btn').addEventListener('click', () => {\r\n  particleWorker.postMessage({ type: 'START' });\r\n});\r\n\r\n// 애니메이션 정지\r\ndocument.getElementById('stop-btn').addEventListener('click', () => {\r\n  particleWorker.postMessage({ type: 'STOP' });\r\n});\r\n\r\n// particle-worker.js\r\nlet particles = [];\r\nlet width = 0;\r\nlet height = 0;\r\nlet animating = false;\r\n\r\n// 메시지 핸들러\r\nonmessage = function(event) {\r\n  const { type, payload } = event.data;\r\n  \r\n  switch (type) {\r\n    case 'INIT':\r\n      width = payload.width;\r\n      height = payload.height;\r\n      initParticles(payload.particleCount);\r\n      break;\r\n      \r\n    case 'START':\r\n      animating = true;\r\n      requestAnimationFrame(updateParticles);\r\n      break;\r\n      \r\n    case 'STOP':\r\n      animating = false;\r\n      break;\r\n  }\r\n};\r\n\r\n// 파티클 초기화\r\nfunction initParticles(count) {\r\n  particles = [];\r\n  \r\n  for (let i = 0; i < count; i++) {\r\n    particles.push({\r\n      x: Math.random() * width,\r\n      y: Math.random() * height,\r\n      vx: Math.random() * 2 - 1, // -1 ~ 1\r\n      vy: Math.random() * 2 - 1, // -1 ~ 1\r\n      radius: Math.random() * 3 + 1\r\n    });\r\n  }\r\n  \r\n  // 초기 데이터 메인 스레드로 전송\r\n  postMessage({\r\n    type: 'UPDATE',\r\n    payload: particles\r\n  });\r\n}\r\n\r\n// 파티클 업데이트 (애니메이션 프레임)\r\nfunction updateParticles() {\r\n  if (!animating) return;\r\n  \r\n  // 모든 파티클 위치 업데이트\r\n  particles.forEach(particle => {\r\n    // 위치 업데이트\r\n    particle.x += particle.vx;\r\n    particle.y += particle.vy;\r\n    \r\n    // 벽에 부딪힐 경우 반사\r\n    if (particle.x < 0 || particle.x > width) {\r\n      particle.vx *= -1;\r\n    }\r\n    \r\n    if (particle.y < 0 || particle.y > height) {\r\n      particle.vy *= -1;\r\n    }\r\n  });\r\n  \r\n  // 업데이트된 데이터 메인 스레드로 전송\r\n  postMessage({\r\n    type: 'UPDATE',\r\n    payload: particles\r\n  });\r\n  \r\n  // 다음 프레임 업데이트 예약\r\n  setTimeout(() => {\r\n    requestAnimationFrame(updateParticles);\r\n  }, 16); // 약 60fps\r\n}\r\n```\r\n\r\n## ⚠️ 발견한 성능 함정\r\n\r\n프로젝트를 진행하면서 몇 가지 성능 함정을 발견했다:\r\n\r\n1. **메시지 전달 오버헤드**:\r\n   웹 워커와 통신 시 데이터 직렬화/역직렬화 비용이 큼 → SharedArrayBuffer 사용으로 개선\r\n\r\n   ```javascript\r\n   // 개선된 버전 - 공유 메모리 사용\r\n   // main.js\r\n   const buffer = new SharedArrayBuffer(Float32Array.BYTES_PER_ELEMENT * particleCount * 4);\r\n   const particleData = new Float32Array(buffer);\r\n   \r\n   // particle-worker.js\r\n   function updateParticles() {\r\n     // 직접 공유 메모리에 쓰기\r\n     for (let i = 0; i < particleCount; i++) {\r\n       const baseIndex = i * 4;\r\n       particleData[baseIndex] += particleData[baseIndex + 2]; // x += vx\r\n       particleData[baseIndex + 1] += particleData[baseIndex + 3]; // y += vy\r\n       \r\n       // 경계 검사...\r\n     }\r\n     \r\n     // 업데이트 완료 신호만 전송 (데이터 없음)\r\n     postMessage({ type: 'FRAME_READY' });\r\n   }\r\n   ```\r\n\r\n2. **불필요한 렌더링**:\r\n   변경된 것이 없을 때도 렌더링 발생 → dirty 플래그로 최적화\r\n\r\n   ```javascript\r\n   let isDirty = true;\r\n   \r\n   function render() {\r\n     if (isDirty) {\r\n       // 실제 렌더링 수행...\r\n       isDirty = false;\r\n     }\r\n     \r\n     requestAnimationFrame(render);\r\n   }\r\n   \r\n   function updateSomething() {\r\n     // 변경 시 dirty 플래그 설정\r\n     isDirty = true;\r\n   }\r\n   ```\r\n\r\n3. **GPU 활용 부족**:\r\n   CPU에서 모든 계산 수행 → WebGL 또는 WebGPU로 전환 실험\r\n\r\n## 🔄 OffscreenCanvas 활용\r\n\r\n더 나아가 OffscreenCanvas를 사용해 렌더링까지 워커로 위임하는 방법도 실험했다:\r\n\r\n```javascript\r\n// main.js\r\nconst canvas = document.getElementById('game-canvas');\r\nconst offscreen = canvas.transferControlToOffscreen();\r\nconst worker = new Worker('render-worker.js');\r\n\r\n// 오프스크린 캔버스를 워커로 전송 (소유권 이전)\r\nworker.postMessage({ \r\n  type: 'INIT', \r\n  canvas: offscreen \r\n}, [offscreen]);\r\n\r\n// render-worker.js\r\nlet canvas;\r\nlet ctx;\r\nlet particles = [];\r\n\r\nonmessage = function(event) {\r\n  const { type, canvas: receivedCanvas } = event.data;\r\n  \r\n  if (type === 'INIT') {\r\n    canvas = receivedCanvas;\r\n    ctx = canvas.getContext('2d');\r\n    initParticles();\r\n    requestAnimationFrame(renderLoop);\r\n  }\r\n};\r\n\r\nfunction renderLoop() {\r\n  // 렌더링 및 업데이트 로직...\r\n  \r\n  requestAnimationFrame(renderLoop);\r\n}\r\n```\r\n\r\n## 🔄 워커 풀 구현 실험\r\n\r\n여러 워커를 효율적으로 관리하는 워커 풀 패턴도 구현해 보았다:\r\n\r\n```javascript\r\nclass WorkerPool {\r\n  constructor(size) {\r\n    this.size = size;\r\n    this.workers = [];\r\n    this.queue = [];\r\n    this.activeWorkers = 0;\r\n    \r\n    // 워커 풀 초기화\r\n    for (let i = 0; i < size; i++) {\r\n      const worker = new Worker('worker.js');\r\n      \r\n      worker.onmessage = (event) => {\r\n        // 작업 완료 처리\r\n        const { taskId, result } = event.data;\r\n        const task = this.queue.find(t => t.id === taskId);\r\n        \r\n        if (task && task.resolve) {\r\n          task.resolve(result);\r\n        }\r\n        \r\n        // 워커를 다시 사용 가능 상태로 표시\r\n        this.activeWorkers--;\r\n        \r\n        // 대기 중인 작업이 있으면 실행\r\n        this.processQueue();\r\n      };\r\n      \r\n      this.workers.push({\r\n        worker,\r\n        busy: false\r\n      });\r\n    }\r\n  }\r\n  \r\n  // 작업 추가\r\n  enqueue(taskType, data) {\r\n    return new Promise((resolve, reject) => {\r\n      const taskId = Math.random().toString(36).substr(2, 9);\r\n      \r\n      this.queue.push({\r\n        id: taskId,\r\n        type: taskType,\r\n        data,\r\n        resolve,\r\n        reject\r\n      });\r\n      \r\n      this.processQueue();\r\n    });\r\n  }\r\n  \r\n  // 대기 중인 작업 처리\r\n  processQueue() {\r\n    if (this.queue.length === 0) return;\r\n    if (this.activeWorkers >= this.size) return;\r\n    \r\n    // 사용 가능한 워커 찾기\r\n    const workerInfo = this.workers.find(w => !w.busy);\r\n    if (!workerInfo) return;\r\n    \r\n    // 워커 사용 중으로 표시\r\n    workerInfo.busy = true;\r\n    this.activeWorkers++;\r\n    \r\n    // 대기열에서 작업 가져오기\r\n    const task = this.queue.shift();\r\n    \r\n    // 워커에 작업 전송\r\n    workerInfo.worker.postMessage({\r\n      taskId: task.id,\r\n      type: task.type,\r\n      data: task.data\r\n    });\r\n  }\r\n  \r\n  // 모든 워커 종료\r\n  terminate() {\r\n    this.workers.forEach(workerInfo => {\r\n      workerInfo.worker.terminate();\r\n    });\r\n    \r\n    this.workers = [];\r\n    this.queue = [];\r\n    this.activeWorkers = 0;\r\n  }\r\n}\r\n\r\n// 워커 풀 사용 예시\r\nconst pool = new WorkerPool(navigator.hardwareConcurrency || 4);\r\n\r\n// 여러 작업 동시 처리\r\nasync function processImages(images) {\r\n  const results = await Promise.all(\r\n    images.map(image => \r\n      pool.enqueue('PROCESS_IMAGE', { imageData: image })\r\n    )\r\n  );\r\n  \r\n  return results;\r\n}\r\n```\r\n\r\n## 📊 성능 측정 및 비교\r\n\r\n여러 접근 방식의 성능을 Chrome DevTools의 Performance 탭으로 분석했다:\r\n\r\n| 구현 방식 | FPS | CPU 사용률 | 메모리 사용량 | 느낌 |\r\n|---------|-----|-----------|------------|-----|\r\n| 단일 스레드 | ~30 | 90-100% | 낮음 | 버벅임 |\r\n| 웹 워커 + 메시지 | ~55 | 70-80% | 중간 | 좋음 |\r\n| 웹 워커 + SharedArrayBuffer | ~58 | 65-75% | 중간 | 매우 좋음 |\r\n| OffscreenCanvas | ~60 | 60-70% | 높음 | 부드러움 |\r\n\r\n확실히 워커를 활용하면 메인 스레드 부하가 줄어들어 UI 반응성이 크게 향상되는 것을 확인했다.\r\n\r\n## 🌟 Service Worker와 PWA 연계\r\n\r\n웹 워커와 함께 Service Worker를 활용한 PWA(Progressive Web App) 최적화도 시도해 보았다:\r\n\r\n```javascript\r\n// service-worker.js\r\nself.addEventListener('install', event => {\r\n  event.waitUntil(\r\n    caches.open('app-v1').then(cache => {\r\n      return cache.addAll([\r\n        '/',\r\n        '/index.html',\r\n        '/styles.css',\r\n        '/app.js',\r\n        '/worker.js',\r\n        '/images/icon.png'\r\n      ]);\r\n    })\r\n  );\r\n});\r\n\r\nself.addEventListener('fetch', event => {\r\n  event.respondWith(\r\n    caches.match(event.request).then(response => {\r\n      if (response) {\r\n        return response; // 캐시에서 찾음\r\n      }\r\n      \r\n      // 네트워크 요청 및 캐시에 추가\r\n      return fetch(event.request).then(response => {\r\n        // 유효한 응답인지 확인\r\n        if (!response || response.status !== 200 || response.type !== 'basic') {\r\n          return response;\r\n        }\r\n        \r\n        // 응답 복제 (스트림은 한 번만 사용 가능)\r\n        const responseToCache = response.clone();\r\n        \r\n        caches.open('app-v1').then(cache => {\r\n          cache.put(event.request, responseToCache);\r\n        });\r\n        \r\n        return response;\r\n      });\r\n    })\r\n  );\r\n});\r\n```\r\n\r\n## 🤔 어려웠던 부분 & 앞으로의 학습 방향\r\n\r\n1. **디버깅 복잡성**: 웹 워커 내부 동작 디버깅이 어려움\r\n2. **브라우저 호환성**: SharedArrayBuffer, OffscreenCanvas 등은 아직 지원이 제한적\r\n3. **아키텍처 설계**: 어떤 작업을 워커로 분리할지 결정하는 것이 생각보다 복잡함\r\n\r\n## 🪬 오늘의 교훈\r\n\r\nJavaScript의 단일 스레드 모델은 여전히 큰 제약이지만, 웹 워커와 최신 API를 활용하면 꽤 강력한 멀티스레딩 애플리케이션을 구현할 수 있다는 점을 실감했다. 특히 프레임워크에 의존하지 않고 순수 JavaScript로 성능 최적화를 고민해보는 과정이 매우 유익했다.\r\n\r\n무조건 워커를 사용하는 것보다는 작업의 특성을 고려해 적절한 기법을 선택하는 것이 중요하다. 단순히 UI를 블로킹하지 않는 것을 넘어, 작업을 어떻게 분할하고 스레드 간 통신 오버헤드를 최소화할지 고민하는 것이 핵심이다.\r\n\r\n내일부터는 이 모든 기법을 종합해 실제 프로젝트에 적용하고, 더 깊이 있는 최적화를 실험해볼 예정이다.\r\n\r\n---\r\n\r\n## 회고 요약\r\n\r\n- 웹 워커를 활용한 멀티스레딩 구현\r\n- SharedArrayBuffer와 Atomics API 학습\r\n- 캔버스 애니메이션 최적화 프로젝트 진행\r\n- OffscreenCanvas로 렌더링 성능 개선\r\n- 워커 풀 패턴 구현 및 실험\r\n- Service Worker와 PWA 연계 최적화\r\n- 여러 방식의 성능 측정 및 비교 분석\r\n"
    },
    {
      "id": "2025-05-20-auto-generated",
      "title": "이벤트 루프 심화 이해와 비동기 최적화 기법",
      "date": "2025-05-20",
      "category": "daily",
      "tags": [
        "JavaScript",
        "Java",
        "학습",
        "프로젝트"
      ],
      "image": "https://images.unsplash.com/photo-1488590528505-98d2b5aba04b?w=400&h=200&fit=crop",
      "description": "2025-05-20의 학습 내용 정리",
      "excerpt": "오늘은 JavaScript의 이벤트 루프에 대해 더 깊이 파고들었다. 특히 비동기 작업의 실행 순서와 최적화 기법에 중점을 두고 공부했다.\r",
      "content": "# 이벤트 루프 심화 이해와 비동기 최적화 기법 \r\n\r\n오늘은 JavaScript의 이벤트 루프에 대해 더 깊이 파고들었다. 특히 비동기 작업의 실행 순서와 최적화 기법에 중점을 두고 공부했다.\r\n\r\n## 🔄 이벤트 루프 심화 이해하기\r\n\r\n지난번에 배운 비동기 프로그래밍 개념을 바탕으로 JavaScript 엔진이 어떻게 동작하는지 더 깊이 파악했다:\r\n\r\n```javascript\r\nconsole.log('시작');\r\n\r\nsetTimeout(() => {\r\n  console.log('타임아웃 콜백');\r\n}, 0);\r\n\r\nPromise.resolve().then(() => {\r\n  console.log('프로미스 콜백');\r\n});\r\n\r\nconsole.log('종료');\r\n\r\n// 출력 순서:\r\n// 시작\r\n// 종료\r\n// 프로미스 콜백\r\n// 타임아웃 콜백\r\n```\r\n\r\n### 이벤트 루프 구성 요소 분석\r\n\r\n1. **콜 스택(Call Stack)**: 함수 호출을 추적하는 데이터 구조\r\n2. **태스크 큐(Task Queue)**: setTimeout, setInterval 등의 콜백이 대기하는 큐\r\n3. **마이크로태스크 큐(Microtask Queue)**: Promise 콜백이 대기하는 큐 (태스크 큐보다 우선순위 높음)\r\n4. **렌더링 단계**: 브라우저 UI 업데이트 (레이아웃, 페인트 등)\r\n\r\n### 실전 활용 예시\r\n\r\n```javascript\r\n// 🔴 안 좋은 예: 무거운 계산으로 UI 차단\r\nfunction calculatePrimes(num) {\r\n  const primes = [];\r\n  for (let i = 2; i <= num; i++) {\r\n    let isPrime = true;\r\n    for (let j = 2; j < i; j++) {\r\n      if (i % j === 0) {\r\n        isPrime = false;\r\n        break;\r\n      }\r\n    }\r\n    if (isPrime) primes.push(i);\r\n  }\r\n  return primes;\r\n}\r\n\r\ndocument.getElementById('calculate-btn').addEventListener('click', () => {\r\n  const result = calculatePrimes(100000); // 메인 스레드 차단\r\n  displayResults(result);\r\n});\r\n\r\n// 🟢 좋은 예: 무거운 작업 청크로 분할\r\nfunction calculatePrimesInChunks(num, onProgress, onComplete) {\r\n  let i = 2;\r\n  const primes = [];\r\n  \r\n  function processChunk() {\r\n    const startTime = performance.now();\r\n    \r\n    while (i <= num && performance.now() - startTime < 10) {\r\n      let isPrime = true;\r\n      for (let j = 2; j < i; j++) {\r\n        if (i % j === 0) {\r\n          isPrime = false;\r\n          break;\r\n        }\r\n      }\r\n      if (isPrime) primes.push(i);\r\n      i++;\r\n    }\r\n    \r\n    // 진행률 보고\r\n    onProgress(Math.min(100, Math.floor((i / num) * 100)));\r\n    \r\n    if (i <= num) {\r\n      // 다음 프레임에서 계속 처리\r\n      requestAnimationFrame(processChunk);\r\n    } else {\r\n      // 완료\r\n      onComplete(primes);\r\n    }\r\n  }\r\n  \r\n  // 첫 청크 시작\r\n  requestAnimationFrame(processChunk);\r\n}\r\n\r\ndocument.getElementById('calculate-btn').addEventListener('click', () => {\r\n  const progressBar = document.getElementById('progress-bar');\r\n  \r\n  calculatePrimesInChunks(\r\n    100000,\r\n    (progress) => {\r\n      progressBar.style.width = `${progress}%`;\r\n    },\r\n    (result) => {\r\n      displayResults(result);\r\n    }\r\n  );\r\n});\r\n```\r\n\r\n## 📊 브라우저 렌더링 성능 디버깅\r\n\r\nChrome DevTools의 Performance와 Rendering 탭을 활용해 렌더링 성능을 분석하는 방법을 배웠다:\r\n\r\n### 주요 성능 지표\r\n\r\n1. **First Paint (FP)**: 첫 픽셀이 화면에 그려지는 시점\r\n2. **First Contentful Paint (FCP)**: 텍스트나 이미지가 처음 표시되는 시점\r\n3. **Largest Contentful Paint (LCP)**: 가장 큰 컨텐츠가 표시되는 시점\r\n4. **Time to Interactive (TTI)**: 사용자와 상호작용이 가능해지는 시점\r\n\r\n### 렌더링 병목 현상 분석 방법\r\n\r\n```javascript\r\n// 성능 측정을 위한 마커 추가\r\nperformance.mark('calculation-start');\r\n\r\n// 무거운 계산 수행\r\nconst result = calculatePrimes(50000);\r\n\r\nperformance.mark('calculation-end');\r\nperformance.measure(\r\n  'Prime Calculation',\r\n  'calculation-start',\r\n  'calculation-end'\r\n);\r\n\r\n// DevTools의 Performance 패널에서 확인 가능\r\n```\r\n\r\n## 🔄 requestAnimationFrame 활용 패턴\r\n\r\n부드러운 애니메이션을 위한 requestAnimationFrame의 다양한 활용 패턴을 실험했다:\r\n\r\n```javascript\r\nlet lastTime = 0;\r\nconst ballElement = document.getElementById('ball');\r\nlet ballX = 0;\r\nlet ballY = 0;\r\nlet velocityX = 100; // 픽셀/초\r\nlet velocityY = 80; // 픽셀/초\r\n\r\nfunction animate(currentTime) {\r\n  // currentTime은 밀리세컨드 단위\r\n  if (!lastTime) lastTime = currentTime;\r\n  \r\n  // 시간 차이 계산 (초 단위로 변환)\r\n  const deltaTime = (currentTime - lastTime) / 1000;\r\n  lastTime = currentTime;\r\n  \r\n  // 위치 업데이트 (속도 * 시간)\r\n  ballX += velocityX * deltaTime;\r\n  ballY += velocityY * deltaTime;\r\n  \r\n  // 화면 경계에서 반사\r\n  const maxX = window.innerWidth - 50; // 공 크기 고려\r\n  const maxY = window.innerHeight - 50; // 공 크기 고려\r\n  \r\n  if (ballX <= 0 || ballX >= maxX) {\r\n    velocityX = -velocityX;\r\n    ballX = Math.max(0, Math.min(ballX, maxX));\r\n  }\r\n  \r\n  if (ballY <= 0 || ballY >= maxY) {\r\n    velocityY = -velocityY;\r\n    ballY = Math.max(0, Math.min(ballY, maxY));\r\n  }\r\n  \r\n  // 공 위치 업데이트\r\n  ballElement.style.transform = `translate(${ballX}px, ${ballY}px)`;\r\n  \r\n  // 다음 프레임 요청\r\n  requestAnimationFrame(animate);\r\n}\r\n\r\n// 애니메이션 시작\r\nrequestAnimationFrame(animate);\r\n```\r\n\r\n### 스로틀링과 디바운싱 활용\r\n\r\n스크롤이나 리사이즈 같은 빈번한 이벤트 처리를 최적화하는 기법도 구현해 보았다:\r\n\r\n```javascript\r\n// 디바운스 함수 구현\r\nfunction debounce(func, wait) {\r\n  let timeout;\r\n  \r\n  return function executedFunction(...args) {\r\n    const later = () => {\r\n      clearTimeout(timeout);\r\n      func(...args);\r\n    };\r\n    \r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(later, wait);\r\n  };\r\n}\r\n\r\n// 스로틀 함수 구현\r\nfunction throttle(func, limit) {\r\n  let inThrottle;\r\n  \r\n  return function executedFunction(...args) {\r\n    if (!inThrottle) {\r\n      func(...args);\r\n      inThrottle = true;\r\n      \r\n      setTimeout(() => {\r\n        inThrottle = false;\r\n      }, limit);\r\n    }\r\n  };\r\n}\r\n\r\n// 스크롤 이벤트에 적용\r\nconst efficientScroll = throttle(() => {\r\n  // 스크롤 이벤트 처리 로직\r\n  console.log('스크롤 처리 중...');\r\n}, 100); // 100ms마다 최대 한 번 실행\r\n\r\nwindow.addEventListener('scroll', efficientScroll);\r\n\r\n// 리사이즈 이벤트에 적용\r\nconst efficientResize = debounce(() => {\r\n  // 리사이즈 이벤트 처리 로직\r\n  console.log('리사이즈 처리 완료!');\r\n}, 250); // 마지막 이벤트로부터 250ms 후 실행\r\n\r\nwindow.addEventListener('resize', efficientResize);\r\n```\r\n\r\n## 🔄 비동기 작업 스케줄링\r\n\r\n효율적인 비동기 작업 스케줄링을 위한 다양한 접근법을 비교했다:\r\n\r\n```javascript\r\n// 1. setTimeout with 0\r\nsetTimeout(() => {\r\n  console.log('태스크 큐로 스케줄링됨');\r\n}, 0);\r\n\r\n// 2. Promise 사용\r\nPromise.resolve().then(() => {\r\n  console.log('마이크로태스크 큐로 스케줄링됨');\r\n});\r\n\r\n// 3. requestAnimationFrame\r\nrequestAnimationFrame(() => {\r\n  console.log('다음 화면 업데이트 전에 실행됨');\r\n});\r\n\r\n// 4. requestIdleCallback\r\nrequestIdleCallback(() => {\r\n  console.log('브라우저가 쉬고 있을 때 실행됨');\r\n});\r\n\r\n// 5. MessageChannel 활용 (마이크로태스크보다 우선 순위 낮음)\r\nconst channel = new MessageChannel();\r\nchannel.port1.onmessage = () => {\r\n  console.log('MessageChannel 콜백 실행됨');\r\n};\r\nchannel.port2.postMessage(undefined);\r\n```\r\n\r\n## 🤔 인터렉티브 웹앱 최적화 프로젝트\r\n\r\n실제 프로젝트에 학습한 내용을 적용해 봤다:\r\n\r\n```javascript\r\nclass OptimizedApp {\r\n  constructor() {\r\n    this.tasks = [];\r\n    this.isProcessingTasks = false;\r\n    this.initEventListeners();\r\n  }\r\n  \r\n  initEventListeners() {\r\n    // 사용자 입력 이벤트 처리\r\n    document.getElementById('user-input').addEventListener('input', \r\n      this.debounce(this.handleUserInput.bind(this), 200)\r\n    );\r\n    \r\n    // 스크롤 이벤트 처리\r\n    window.addEventListener('scroll', \r\n      this.throttle(this.handleScroll.bind(this), 100)\r\n    );\r\n    \r\n    // 애니메이션 시작 버튼\r\n    document.getElementById('animate-btn').addEventListener('click', () => {\r\n      this.startAnimation();\r\n    });\r\n  }\r\n  \r\n  handleUserInput(event) {\r\n    const value = event.target.value;\r\n    \r\n    // 무거운 작업을 태스크 큐로 이동\r\n    this.scheduleTask(() => {\r\n      this.processUserInput(value);\r\n    });\r\n  }\r\n  \r\n  processUserInput(value) {\r\n    // 복잡한 처리 로직...\r\n    console.log('입력 처리 완료:', value);\r\n  }\r\n  \r\n  handleScroll() {\r\n    // 가시성 확인 및 필요한 요소만 업데이트\r\n    const elements = document.querySelectorAll('.lazy-load');\r\n    \r\n    elements.forEach(element => {\r\n      if (this.isElementInViewport(element) && !element.dataset.loaded) {\r\n        element.dataset.loaded = true;\r\n        this.loadContent(element);\r\n      }\r\n    });\r\n  }\r\n  \r\n  isElementInViewport(el) {\r\n    const rect = el.getBoundingClientRect();\r\n    return (\r\n      rect.top >= 0 &&\r\n      rect.left >= 0 &&\r\n      rect.bottom <= window.innerHeight &&\r\n      rect.right <= window.innerWidth\r\n    );\r\n  }\r\n  \r\n  loadContent(element) {\r\n    // 이미지나 컨텐츠 로드 로직...\r\n  }\r\n  \r\n  startAnimation() {\r\n    let frame = 0;\r\n    const animate = (timestamp) => {\r\n      // 애니메이션 로직...\r\n      frame++;\r\n      \r\n      // 다음 프레임 요청\r\n      this.animationId = requestAnimationFrame(animate);\r\n    };\r\n    \r\n    this.animationId = requestAnimationFrame(animate);\r\n  }\r\n  \r\n  scheduleTask(task) {\r\n    this.tasks.push(task);\r\n    \r\n    if (!this.isProcessingTasks) {\r\n      this.processTasks();\r\n    }\r\n  }\r\n  \r\n  processTasks() {\r\n    this.isProcessingTasks = true;\r\n    \r\n    requestIdleCallback(deadline => {\r\n      while (deadline.timeRemaining() > 0 && this.tasks.length > 0) {\r\n        const task = this.tasks.shift();\r\n        task();\r\n      }\r\n      \r\n      if (this.tasks.length > 0) {\r\n        // 아직 남은 작업이 있으면 다시 스케줄링\r\n        this.processTasks();\r\n      } else {\r\n        this.isProcessingTasks = false;\r\n      }\r\n    });\r\n  }\r\n  \r\n  // 유틸리티 메서드\r\n  debounce(func, wait) {\r\n    let timeout;\r\n    return function(...args) {\r\n      clearTimeout(timeout);\r\n      timeout = setTimeout(() => func(...args), wait);\r\n    };\r\n  }\r\n  \r\n  throttle(func, limit) {\r\n    let inThrottle;\r\n    return function(...args) {\r\n      if (!inThrottle) {\r\n        func(...args);\r\n        inThrottle = true;\r\n        setTimeout(() => inThrottle = false, limit);\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\n// 앱 초기화\r\nconst app = new OptimizedApp();\r\n```\r\n\r\n## 🤔 어려웠던 부분 & 앞으로의 학습 방향\r\n\r\n1. **작업 우선순위 관리**: 여러 비동기 작업의 우선순위를 어떻게 효과적으로 관리할지\r\n2. **디버깅 복잡성**: 비동기 코드의 디버깅과 성능 프로파일링 방법\r\n3. **최적의 청크 크기**: 작업을 얼마나 작은 단위로 분할해야 최적의 성능을 발휘할지\r\n\r\n## 🪬 오늘의 교훈\r\n\r\nJavaScript의 이벤트 루프를 깊이 이해하는 것이 성능 최적화의 첫걸음이라는 것을 깨달았다. 단순히 비동기 코드를 작성하는 것을 넘어, 브라우저의 렌더링 주기와 조화롭게 동작하도록 코드를 구성하는 것이 중요하다.\r\n\r\n특히 사용자 인터페이스와 관련된 작업은 메인 스레드를 차단하지 않도록 주의해야 하며, 적절한 작업 분할과 스케줄링이 사용자 경험을 크게 향상시킬 수 있다는 점을 실감했다.\r\n\r\n내일은 이 지식을 바탕으로 웹 워커를 활용해 실제 멀티스레딩 애플리케이션을 구현해볼 계획이다.\r\n\r\n---\r\n\r\n## 회고 요약\r\n\r\n- 이벤트 루프 구성 요소와 동작 방식 심화 이해\r\n- 무거운 작업의 청크 분할로 UI 반응성 유지\r\n- 브라우저 렌더링 성능 디버깅 방법 학습\r\n- requestAnimationFrame을 활용한 부드러운 애니메이션 구현\r\n- 스로틀링과 디바운싱 기법으로 이벤트 최적화\r\n- 다양한 비동기 작업 스케줄링 방법 비교 분석\r\n- 인터렉티브 웹앱 최적화 프로젝트 진행\r\n"
    },
    {
      "id": "2025-05-19-auto-generated",
      "title": "Async/Await와 실전 비동기 프로그래밍 학습",
      "date": "2025-05-19",
      "category": "daily",
      "tags": [
        "JavaScript",
        "React",
        "HTML",
        "Java",
        "학습",
        "프로젝트"
      ],
      "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=400&h=200&fit=crop",
      "description": "2025-05-19의 학습 내용 정리",
      "excerpt": "오늘은 JavaScript의 async/await 문법을 깊이 있게 공부하고, 주말 동안 배운 비동기 프로그래밍 개념들을 실제 미니 프로젝트에 적용해보았다. 점점 복잡한 JavaS...",
      "content": "# Async/Await와 실전 비동기 프로그래밍 학습\r\n\r\n오늘은 JavaScript의 async/await 문법을 깊이 있게 공부하고, 주말 동안 배운 비동기 프로그래밍 개념들을 실제 미니 프로젝트에 적용해보았다. 점점 복잡한 JavaScript 패턴들이 익숙해지고 있는 느낌이다.\r\n\r\n## 🔄 Async/Await 문법 이해하기\r\n\r\nPromise를 더 간결하고 직관적으로 다룰 수 있는 async/await 문법에 대해 학습했다:\r\n\r\n```javascript\r\n// Promise를 사용한 비동기 코드\r\nfunction fetchUserData(userId) {\r\n  return fetch(`https://api.example.com/users/${userId}`)\r\n    .then(response => {\r\n      if (!response.ok) {\r\n        throw new Error('사용자 데이터를 가져오는데 실패했습니다.');\r\n      }\r\n      return response.json();\r\n    })\r\n    .then(data => {\r\n      console.log(data);\r\n      return data;\r\n    })\r\n    .catch(error => {\r\n      console.error('에러 발생:', error);\r\n      throw error;\r\n    });\r\n}\r\n\r\n// async/await를 사용한 동일한 코드\r\nasync function fetchUserDataAsync(userId) {\r\n  try {\r\n    const response = await fetch(`https://api.example.com/users/${userId}`);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error('사용자 데이터를 가져오는데 실패했습니다.');\r\n    }\r\n    \r\n    const data = await response.json();\r\n    console.log(data);\r\n    return data;\r\n  } catch (error) {\r\n    console.error('에러 발생:', error);\r\n    throw error;\r\n  }\r\n}\r\n```\r\n\r\n### async/await의 장점\r\n\r\n1. **가독성 향상**: 비동기 코드를 동기 코드처럼 작성 가능\r\n2. **에러 처리 간소화**: 일반적인 try-catch 문으로 에러 처리\r\n3. **디버깅 용이성**: 스택 트레이스가 더 명확하게 표시됨\r\n\r\n### 주의할 점\r\n\r\n```javascript\r\n// 🔴 안 좋은 예: await를 병렬로 처리할 수 있는데 순차적으로 처리\r\nasync function fetchMultipleDataSequential() {\r\n  const userData = await fetchUserData(123);\r\n  const productData = await fetchProductData(456); // userData 완료 후에만 시작\r\n  return { userData, productData };\r\n}\r\n\r\n// 🟢 좋은 예: 독립적인 작업은 병렬로 처리\r\nasync function fetchMultipleDataParallel() {\r\n  const userDataPromise = fetchUserData(123);\r\n  const productDataPromise = fetchProductData(456); // fetchUserData와 동시에 시작\r\n  \r\n  const userData = await userDataPromise;\r\n  const productData = await productDataPromise;\r\n  return { userData, productData };\r\n}\r\n\r\n// 또는 더 간결하게 Promise.all 사용\r\nasync function fetchMultipleDataWithPromiseAll() {\r\n  const [userData, productData] = await Promise.all([\r\n    fetchUserData(123),\r\n    fetchProductData(456)\r\n  ]);\r\n  return { userData, productData };\r\n}\r\n```\r\n\r\n## 🔄 비동기 패턴 실전 활용\r\n\r\n배운 내용을 바탕으로 실제 데이터를 불러오는 미니 프로젝트를 구현했다:\r\n\r\n### 영화 정보 앱 만들기\r\n\r\n```javascript\r\n// 영화 API에서 데이터 가져오기\r\nasync function fetchMovieData(title) {\r\n  try {\r\n    const response = await fetch(`https://api.example.com/movies?title=${encodeURIComponent(title)}`);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`영화 정보를 가져오는데 실패했습니다 (${response.status})`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    console.error('API 호출 오류:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// 영화 상세 정보와 관련 영화 함께 가져오기\r\nasync function getMovieDetails(movieId) {\r\n  try {\r\n    // 두 API 요청을 병렬로 처리\r\n    const [details, relatedMovies] = await Promise.all([\r\n      fetch(`https://api.example.com/movies/${movieId}`).then(res => res.json()),\r\n      fetch(`https://api.example.com/movies/${movieId}/related`).then(res => res.json())\r\n    ]);\r\n    \r\n    return {\r\n      details,\r\n      relatedMovies\r\n    };\r\n  } catch (error) {\r\n    console.error('영화 상세 정보를 가져오는데 실패했습니다:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// UI 업데이트 함수\r\nfunction displayMovieDetails(movie) {\r\n  document.getElementById('movie-title').textContent = movie.details.title;\r\n  document.getElementById('movie-description').textContent = movie.details.description;\r\n  document.getElementById('movie-rating').textContent = `평점: ${movie.details.rating}/10`;\r\n  \r\n  const relatedMoviesList = document.getElementById('related-movies');\r\n  relatedMoviesList.innerHTML = '';\r\n  \r\n  movie.relatedMovies.forEach(relatedMovie => {\r\n    const li = document.createElement('li');\r\n    li.textContent = relatedMovie.title;\r\n    li.addEventListener('click', () => loadMovie(relatedMovie.id));\r\n    relatedMoviesList.appendChild(li);\r\n  });\r\n}\r\n\r\n// 영화 로드 함수\r\nasync function loadMovie(movieId) {\r\n  try {\r\n    document.getElementById('loading').style.display = 'block';\r\n    document.getElementById('error').style.display = 'none';\r\n    document.getElementById('movie-content').style.display = 'none';\r\n    \r\n    const movieData = await getMovieDetails(movieId);\r\n    displayMovieDetails(movieData);\r\n    \r\n    document.getElementById('loading').style.display = 'none';\r\n    document.getElementById('movie-content').style.display = 'block';\r\n  } catch (error) {\r\n    document.getElementById('loading').style.display = 'none';\r\n    document.getElementById('error').style.display = 'block';\r\n    document.getElementById('error-message').textContent = error.message;\r\n  }\r\n}\r\n\r\n// 검색 폼 처리\r\ndocument.getElementById('search-form').addEventListener('submit', async function(event) {\r\n  event.preventDefault();\r\n  \r\n  const searchInput = document.getElementById('search-input');\r\n  const title = searchInput.value.trim();\r\n  \r\n  if (!title) {\r\n    alert('영화 제목을 입력하세요');\r\n    return;\r\n  }\r\n  \r\n  try {\r\n    document.getElementById('search-results').innerHTML = '검색 중...';\r\n    const movies = await fetchMovieData(title);\r\n    \r\n    if (movies.length === 0) {\r\n      document.getElementById('search-results').innerHTML = '검색 결과가 없습니다.';\r\n      return;\r\n    }\r\n    \r\n    displaySearchResults(movies);\r\n  } catch (error) {\r\n    document.getElementById('search-results').innerHTML = `오류 발생: ${error.message}`;\r\n  }\r\n});\r\n\r\nfunction displaySearchResults(movies) {\r\n  const resultsContainer = document.getElementById('search-results');\r\n  resultsContainer.innerHTML = '';\r\n  \r\n  movies.forEach(movie => {\r\n    const movieEl = document.createElement('div');\r\n    movieEl.className = 'movie-item';\r\n    movieEl.innerHTML = `\r\n      <h3>${movie.title} (${movie.year})</h3>\r\n      <p>${movie.director}</p>\r\n    `;\r\n    movieEl.addEventListener('click', () => loadMovie(movie.id));\r\n    resultsContainer.appendChild(movieEl);\r\n  });\r\n}\r\n\r\n// 초기 인기 영화 목록 로드\r\nwindow.addEventListener('DOMContentLoaded', async () => {\r\n  try {\r\n    const popularMovies = await fetch('https://api.example.com/movies/popular').then(res => res.json());\r\n    displaySearchResults(popularMovies);\r\n  } catch (error) {\r\n    document.getElementById('search-results').innerHTML = '인기 영화를 불러오는데 실패했습니다.';\r\n  }\r\n});\r\n```\r\n\r\n## 🔄 에러 처리와 로딩 상태 관리\r\n\r\n비동기 작업에서 중요한 에러 처리와 로딩 상태 관리에 대해 심도 있게 학습했다:\r\n\r\n### 사용자 경험을 고려한 로딩 처리\r\n\r\n```javascript\r\nasync function fetchDataWithLoading(url) {\r\n  // 로딩 시작\r\n  showLoadingIndicator();\r\n  \r\n  try {\r\n    // 의도적으로 지연시켜 UX 개선 (너무 빨리 로딩이 끝나면 깜빡거림 현상 발생)\r\n    const [data] = await Promise.all([\r\n      fetch(url).then(res => res.json()),\r\n      new Promise(resolve => setTimeout(resolve, 300)) // 최소 300ms 대기\r\n    ]);\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    // 에러 상태 표시\r\n    showErrorMessage(error.message);\r\n    throw error;\r\n  } finally {\r\n    // 성공/실패 상관없이 로딩 종료\r\n    hideLoadingIndicator();\r\n  }\r\n}\r\n\r\nfunction showLoadingIndicator() {\r\n  const loader = document.getElementById('loader');\r\n  loader.style.display = 'block';\r\n}\r\n\r\nfunction hideLoadingIndicator() {\r\n  const loader = document.getElementById('loader');\r\n  loader.style.display = 'none';\r\n}\r\n\r\nfunction showErrorMessage(message) {\r\n  const errorContainer = document.getElementById('error-container');\r\n  const errorMessage = document.getElementById('error-message');\r\n  \r\n  errorMessage.textContent = message;\r\n  errorContainer.style.display = 'block';\r\n  \r\n  // 5초 후 에러 메시지 자동 숨김\r\n  setTimeout(() => {\r\n    errorContainer.style.display = 'none';\r\n  }, 5000);\r\n}\r\n```\r\n\r\n### 재시도 메커니즘\r\n\r\n일시적인 네트워크 오류에 대응하기 위한 재시도 로직도 구현해 보았다:\r\n\r\n```javascript\r\nasync function fetchWithRetry(url, options = {}, maxRetries = 3) {\r\n  let retries = 0;\r\n  \r\n  while (retries < maxRetries) {\r\n    try {\r\n      const response = await fetch(url, options);\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP 오류: ${response.status}`);\r\n      }\r\n      \r\n      return await response.json();\r\n    } catch (error) {\r\n      retries++;\r\n      \r\n      if (retries >= maxRetries) {\r\n        console.error(`${maxRetries}번 재시도 후 요청 실패:`, error);\r\n        throw error;\r\n      }\r\n      \r\n      console.warn(`요청 실패 (${retries}/${maxRetries}), 재시도 중...`, error);\r\n      \r\n      // 지수 백오프: 재시도마다 대기 시간 증가\r\n      const delay = 1000 * Math.pow(2, retries - 1);\r\n      await new Promise(resolve => setTimeout(resolve, delay));\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## 🤔 Async/Await vs Promise 선택 기준\r\n\r\n언제 async/await를 쓰고 언제 Promise를 직접 다루는게 좋을지에 대한 기준도 배웠다:\r\n\r\n- **Async/Await가 좋을 때**:\r\n  - 순차적인 비동기 작업에서 가독성이 중요할 때\r\n  - try-catch로 에러 처리가 필요할 때\r\n  - 비동기 코드를 더 동기적으로 읽고 싶을 때\r\n\r\n- **Promise가 좋을 때**:\r\n  - 여러 비동기 작업을 유연하게 조합할 때 (Promise.all, Promise.race 등)\r\n  - 비동기 작업 체인을 구성할 때\r\n  - 콜백 함수를 전달해야 하는 경우\r\n\r\n## 💡 HTTP 요청 라이브러리 비교\r\n\r\n실제 프로젝트에서 사용할 HTTP 요청 라이브러리에 대해서도 비교 분석했다:\r\n\r\n1. **Fetch API**: 모던 브라우저 내장 API, 별도 설치 필요 없음\r\n   ```javascript\r\n   const data = await fetch('/api/users').then(res => res.json());\r\n   ```\r\n\r\n2. **Axios**: 더 풍부한 기능과 에러 처리\r\n   ```javascript\r\n   const response = await axios.get('/api/users');\r\n   const data = response.data; // 자동으로 JSON 파싱\r\n   ```\r\n\r\n3. **기능 비교**:\r\n   - Fetch: 네이티브 API, 별도 설치 불필요, 간단한 API\r\n   - Axios: 인터셉터, 요청 취소, 자동 JSON 변환, 크로스 브라우징 지원\r\n\r\n실제 프로젝트에서는 axios를 사용하는게 더 편리할 것 같다는 결론에 도달했다.\r\n\r\n## 🔄 비동기 상태 관리 패턴\r\n\r\n실제 앱을 만들 때 비동기 작업의 상태를 관리하는 패턴도 배웠다:\r\n\r\n```javascript\r\n// 비동기 상태 객체 구조\r\nconst asyncState = {\r\n  data: null,\r\n  loading: false,\r\n  error: null\r\n};\r\n\r\n// React에서 비동기 상태 관리 예시 (useState 훅 사용)\r\nfunction UserProfile({ userId }) {\r\n  const [user, setUser] = useState(null);\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n\r\n  useEffect(() => {\r\n    async function loadUser() {\r\n      try {\r\n        setLoading(true);\r\n        setError(null);\r\n        \r\n        const userData = await fetchUserData(userId);\r\n        setUser(userData);\r\n      } catch (error) {\r\n        setError(error.message);\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    }\r\n    \r\n    loadUser();\r\n  }, [userId]);\r\n  \r\n  if (loading) return <div>로딩 중...</div>;\r\n  if (error) return <div>에러: {error}</div>;\r\n  if (!user) return <div>사용자 정보가 없습니다.</div>;\r\n  \r\n  return (\r\n    <div className=\"user-profile\">\r\n      <h1>{user.name}</h1>\r\n      <p>{user.email}</p>\r\n      {/* 사용자 정보 렌더링 */}\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n## 🤔 어려웠던 부분 & 앞으로의 학습 방향\r\n\r\n1. **비동기 작업 취소하기**: 사용자가 페이지를 나가거나 다른 요청을 시작했을 때 진행 중인 비동기 작업을 취소하는 방법\r\n2. **복잡한 비동기 흐름 관리**: 여러 API 간의 의존성과 조건부 호출을 관리하는 방법\r\n3. **효율적인 상태 업데이트**: 대량의 데이터를 처리할 때 렌더링 성능 최적화\r\n\r\n## 🪬 오늘의 교훈\r\n\r\n비동기 프로그래밍은 처음에는 복잡해 보이지만, 패턴을 익히고 실제로 구현해보니 점점 직관적으로 이해되기 시작했다. 특히 async/await 문법은 코드를 더 읽기 쉽게 만들어 주어 비즈니스 로직에 집중할 수 있게 해준다. \r\n\r\n하지만 성능 최적화와 에러 처리까지 고려하려면 Promise의 동작 원리도 깊이 이해해야 한다는 점을 깨달았다. 결국 도구를 사용하는 것보다 그 도구가 어떻게 작동하는지 이해하는 것이 중요하다.\r\n\r\n---\r\n\r\n## 회고 요약\r\n\r\n- async/await 문법의 장점과 활용법 학습\r\n- 병렬 비동기 처리를 위한 Promise.all 패턴 이해\r\n- 실제 API 호출 프로젝트에 적용해보기\r\n- 로딩 상태 관리와 에러 처리 심화 학습\r\n- HTTP 요청 라이브러리 비교 및 분석\r\n- 비동기 작업 취소와 복잡한 흐름 관리는 추가 학습 필요\r\n"
    },
    {
      "id": "2025-05-18-auto-generated",
      "title": "JavaScript의 배열과 객체 고급 활용법",
      "date": "2025-05-18",
      "category": "daily",
      "tags": [
        "JavaScript",
        "Java",
        "연습",
        "학습",
        "개발"
      ],
      "image": "https://images.unsplash.com/photo-1518432031352-d6fc5c10da5a?w=400&h=200&fit=crop",
      "description": "2025-05-18의 학습 내용 정리",
      "excerpt": "오늘은 JavaScript의 배열과 객체를 더 효과적으로 다루는 방법에 집중했다. 특히 배열 메서드와 객체 조작 기법을 실습하면서 실제 데이터 처리에 적용해보았다.\r",
      "content": "# JavaScript의 배열과 객체 고급 활용법\r\n\r\n오늘은 JavaScript의 배열과 객체를 더 효과적으로 다루는 방법에 집중했다. 특히 배열 메서드와 객체 조작 기법을 실습하면서 실제 데이터 처리에 적용해보았다.\r\n\r\n## 🔄 배열 메서드 심화 학습\r\n\r\n자주 사용하는 배열 메서드들을 더 깊이 학습했다:\r\n\r\n### map, filter, reduce 활용하기\r\n\r\n```javascript\r\nconst numbers = [1, 2, 3, 4, 5];\r\n\r\n// map: 각 요소를 변환\r\nconst doubled = numbers.map(num => num * 2);\r\nconsole.log(doubled); // [2, 4, 6, 8, 10]\r\n\r\n// filter: 조건에 맞는 요소만 선택\r\nconst evenNumbers = numbers.filter(num => num % 2 === 0);\r\nconsole.log(evenNumbers); // [2, 4]\r\n\r\n// reduce: 배열을 하나의 값으로 축소\r\nconst sum = numbers.reduce((acc, curr) => acc + curr, 0);\r\nconsole.log(sum); // 15\r\n\r\n// 메서드 체이닝: 여러 메서드를 연결해서 사용\r\nconst sumOfDoubledEven = numbers\r\n  .filter(num => num % 2 === 0) // 짝수만 필터링: [2, 4]\r\n  .map(num => num * 2) // 각 숫자 2배로: [4, 8]\r\n  .reduce((acc, curr) => acc + curr, 0); // 합계: 12\r\n\r\nconsole.log(sumOfDoubledEven); // 12\r\n```\r\n\r\n### 배열 메서드 실전 활용\r\n\r\n실제 데이터 처리 시나리오를 실습했다:\r\n\r\n```javascript\r\n// 사용자 데이터 예시\r\nconst users = [\r\n  { id: 1, name: '김철수', age: 25, active: true, scores: [85, 90, 78] },\r\n  { id: 2, name: '이영희', age: 32, active: false, scores: [92, 88, 95] },\r\n  { id: 3, name: '박민수', age: 28, active: true, scores: [76, 85, 90] },\r\n  { id: 4, name: '정다영', age: 21, active: true, scores: [82, 70, 84] },\r\n  { id: 5, name: '홍길동', age: 35, active: false, scores: [90, 92, 89] }\r\n];\r\n\r\n// 1. 활성 사용자만 필터링\r\nconst activeUsers = users.filter(user => user.active);\r\nconsole.log(activeUsers.length); // 3\r\n\r\n// 2. 사용자별 평균 점수 계산\r\nconst usersWithAvgScore = users.map(user => {\r\n  const avgScore = user.scores.reduce((sum, score) => sum + score, 0) / user.scores.length;\r\n  return {\r\n    ...user,\r\n    avgScore: Math.round(avgScore)\r\n  };\r\n});\r\nconsole.log(usersWithAvgScore[0]); // { id: 1, name: '김철수', ... avgScore: 84 }\r\n\r\n// 3. 평균 점수가 85점 이상인 사용자 이름 목록\r\nconst highScorers = usersWithAvgScore\r\n  .filter(user => user.avgScore >= 85)\r\n  .map(user => user.name);\r\n\r\nconsole.log(highScorers); // ['이영희', '박민수', '홍길동']\r\n\r\n// 4. 사용자 평균 나이 계산\r\nconst avgAge = users.reduce((sum, user) => sum + user.age, 0) / users.length;\r\nconsole.log(avgAge); // 28.2\r\n```\r\n\r\n### 새로운 배열 메서드 배우기\r\n\r\n최근 추가된 유용한 배열 메서드도 학습했다:\r\n\r\n```javascript\r\n// find: 조건에 맞는 첫 번째 요소 반환\r\nconst findUser = users.find(user => user.age > 30);\r\nconsole.log(findUser.name); // '이영희'\r\n\r\n// some: 하나라도 조건을 만족하는지 확인\r\nconst hasYoungUser = users.some(user => user.age < 25);\r\nconsole.log(hasYoungUser); // true\r\n\r\n// every: 모든 요소가 조건을 만족하는지 확인\r\nconst allActive = users.every(user => user.active);\r\nconsole.log(allActive); // false\r\n\r\n// includes: 특정 요소 포함 여부 확인\r\nconst numbers = [1, 2, 3, 4, 5];\r\nconsole.log(numbers.includes(3)); // true\r\n```\r\n\r\n## 🔍 객체 다루기\r\n\r\nJavaScript 객체를 효과적으로 다루는 방법을 배웠다:\r\n\r\n### 객체 구조 분해 할당\r\n\r\n```javascript\r\nconst user = {\r\n  name: '김철수',\r\n  age: 25,\r\n  address: {\r\n    city: '서울',\r\n    street: '강남대로 123'\r\n  },\r\n  hobbies: ['독서', '영화', '코딩']\r\n};\r\n\r\n// 기본 구조 분해\r\nconst { name, age } = user;\r\nconsole.log(name, age); // '김철수' 25\r\n\r\n// 중첩 객체 구조 분해\r\nconst { address: { city, street } } = user;\r\nconsole.log(city, street); // '서울' '강남대로 123'\r\n\r\n// 기본값 설정\r\nconst { country = '대한민국' } = user;\r\nconsole.log(country); // '대한민국'\r\n\r\n// 함수 매개변수에서 구조 분해\r\nfunction printUserInfo({ name, age, address: { city } = {} }) {\r\n  console.log(`${name}(${age}세)는 ${city}에 살고 있습니다.`);\r\n}\r\n\r\nprintUserInfo(user); // '김철수(25세)는 서울에 살고 있습니다.'\r\n```\r\n\r\n### 스프레드 연산자와 객체 합치기\r\n\r\n```javascript\r\n// 객체 복사 및 속성 추가\r\nconst userBasic = { name: '김철수', age: 25 };\r\nconst userWithJob = { ...userBasic, job: '개발자' };\r\nconsole.log(userWithJob); // { name: '김철수', age: 25, job: '개발자' }\r\n\r\n// 객체 병합\r\nconst userPreferences = { theme: 'dark', fontSize: 14 };\r\nconst deviceSettings = { notifications: true, theme: 'light' };\r\nconst mergedSettings = { ...userPreferences, ...deviceSettings };\r\nconsole.log(mergedSettings); \r\n// { theme: 'light', fontSize: 14, notifications: true }\r\n// (중복 키는 뒤에 오는 객체의 값으로 덮어씀)\r\n```\r\n\r\n### Object 정적 메서드 활용\r\n\r\n```javascript\r\nconst user = {   \r\n  s\r\n  name: '김철수', \r\n  age: 25, \r\n  job: '개발자',\r\n  active: true\r\n};\r\n\r\n// 키 배열 가져오기\r\nconst keys = Object.keys(user);\r\nconsole.log(keys); // ['name', 'age', 'job', 'active']\r\n\r\n// 값 배열 가져오기\r\nconst values = Object.values(user);\r\nconsole.log(values); // ['김철수', 25, '개발자', true]\r\n\r\n// 키-값 쌍 배열 가져오기\r\nconst entries = Object.entries(user);\r\nconsole.log(entries); \r\n// [['name', '김철수'], ['age', 25], ['job', '개발자'], ['active', true]]\r\n\r\n// entries를 활용한 객체 변환 예시\r\nconst capitalizedEntries = entries.map(([key, value]) => \r\n  [key, typeof value === 'string' ? value.toUpperCase() : value]\r\n);\r\nconst capitalizedUser = Object.fromEntries(capitalizedEntries);\r\nconsole.log(capitalizedUser); \r\n// { name: '김철수', age: 25, job: '개발자', active: true }\r\n```\r\n\r\n## 🔄 데이터 변환 실습\r\n\r\n배열과 객체 메서드를 활용한 실전 데이터 변환 작업을 실습했다:\r\n\r\n### 중첩 데이터 구조화\r\n\r\n```javascript\r\n// 원본 데이터\r\nconst salesData = [\r\n  { date: '2025-05-01', product: 'A', amount: 200 },\r\n  { date: '2025-05-01', product: 'B', amount: 150 },\r\n  { date: '2025-05-02', product: 'A', amount: 300 },\r\n  { date: '2025-05-02', product: 'B', amount: 250 },\r\n  { date: '2025-05-03', product: 'A', amount: 150 },\r\n  { date: '2025-05-03', product: 'B', amount: 350 }\r\n];\r\n\r\n// 날짜별로 그룹화\r\nconst salesByDate = salesData.reduce((result, item) => {\r\n  // 날짜 키가 없으면 생성\r\n  if (!result[item.date]) {\r\n    result[item.date] = [];\r\n  }\r\n  // 해당 날짜에 아이템 추가\r\n  result[item.date].push(item);\r\n  return result;\r\n}, {});\r\n\r\nconsole.log(salesByDate);\r\n/*\r\n{\r\n  '2025-05-01': [\r\n    { date: '2025-05-01', product: 'A', amount: 200 },\r\n    { date: '2025-05-01', product: 'B', amount: 150 }\r\n  ],\r\n  '2025-05-02': [ ... ],\r\n  '2025-05-03': [ ... ]\r\n}\r\n*/\r\n\r\n// 날짜별 총액 계산\r\nconst dailyTotals = Object.entries(salesByDate).map(([date, items]) => {\r\n  const total = items.reduce((sum, item) => sum + item.amount, 0);\r\n  return { date, total };\r\n});\r\n\r\nconsole.log(dailyTotals);\r\n/*\r\n[\r\n  { date: '2025-05-01', total: 350 },\r\n  { date: '2025-05-02', total: 550 },\r\n  { date: '2025-05-03', total: 500 }\r\n]\r\n*/\r\n```\r\n\r\n### 다차원 데이터 처리\r\n\r\n```javascript\r\n// 학생 시험 데이터\r\nconst examResults = [\r\n  { student: '김철수', subject: '수학', score: 85 },\r\n  { student: '김철수', subject: '영어', score: 90 },\r\n  { student: '김철수', subject: '국어', score: 78 },\r\n  { student: '이영희', subject: '수학', score: 92 },\r\n  { student: '이영희', subject: '영어', score: 88 },\r\n  { student: '이영희', subject: '국어', score: 95 }\r\n];\r\n\r\n// 학생별 결과 구조화\r\nconst resultsByStudent = examResults.reduce((acc, result) => {\r\n  // 학생이 없으면 추가\r\n  if (!acc[result.student]) {\r\n    acc[result.student] = {\r\n      name: result.student,\r\n      subjects: {}\r\n    };\r\n  }\r\n  \r\n  // 과목 점수 추가\r\n  acc[result.student].subjects[result.subject] = result.score;\r\n  \r\n  return acc;\r\n}, {});\r\n\r\n// 객체를 배열로 변환하고, 평균 점수 계산 추가\r\nconst studentsSummary = Object.values(resultsByStudent).map(student => {\r\n  const scores = Object.values(student.subjects);\r\n  const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;\r\n  \r\n  return {\r\n    ...student,\r\n    avgScore: Math.round(avgScore)\r\n  };\r\n});\r\n\r\nconsole.log(studentsSummary);\r\n/*\r\n[\r\n  {\r\n    name: '김철수',\r\n    subjects: { 수학: 85, 영어: 90, 국어: 78 },\r\n    avgScore: 84\r\n  },\r\n  {\r\n    name: '이영희',\r\n    subjects: { 수학: 92, 영어: 88, 국어: 95 },\r\n    avgScore: 92\r\n  }\r\n]\r\n*/\r\n```\r\n\r\n## 💡 배열 메서드 성능 최적화\r\n\r\n반복 작업 시 성능 최적화에 대해서도 배웠다:\r\n\r\n```javascript\r\nconst hugeArray = Array.from({ length: 1000000 }, (_, i) => i);\r\n\r\nconsole.time('Regular for loop');\r\nlet sum1 = 0;\r\nfor (let i = 0; i < hugeArray.length; i++) {\r\n  sum1 += hugeArray[i];\r\n}\r\nconsole.timeEnd('Regular for loop');\r\n\r\nconsole.time('forEach');\r\nlet sum2 = 0;\r\nhugeArray.forEach(num => {\r\n  sum2 += num;\r\n});\r\nconsole.timeEnd('forEach');\r\n\r\nconsole.time('reduce');\r\nconst sum3 = hugeArray.reduce((acc, curr) => acc + curr, 0);\r\nconsole.timeEnd('reduce');\r\n\r\n// 결과는 브라우저와 환경에 따라 다르지만, \r\n// 일반적으로 직접 for 루프가 가장 빠른 경우가 많음\r\n```\r\n\r\n## 🤔 어려웠던 부분 & 고민\r\n\r\n1. **메모리 효율성**: 큰 데이터셋에서 체이닝이 여러 중간 배열을 생성하는 문제\r\n2. **가독성 vs 효율성**: 체이닝이 읽기 쉽지만 디버깅이 어려움\r\n3. **얕은 복사와 깊은 복사**: 복잡한 중첩 객체를 다룰 때 참조 관계를 정확히 이해하기\r\n\r\n## 💡 다음 학습 계획\r\n\r\n1. **함수형 프로그래밍 패턴** 더 공부하기\r\n2. **lodash 라이브러리** 탐색해서 유용한 유틸리티 함수 익히기\r\n3. **TypeScript와 배열/객체** 함께 사용하는 방법 학습\r\n\r\n## 🪬 오늘의 교훈\r\n\r\nJavaScript에서 배열과 객체는 단순한 데이터 구조가 아니라 다양한 연산을 수행할 수 있는 강력한 도구임을 알게 되었다. 특히 체이닝을 통해 데이터 변환 파이프라인을 구축하는 방식이 코드를 더 선언적이고 읽기 쉽게 만든다는 점이 인상적이었다. 앞으로 복잡한 JSON 데이터 처리에 오늘 배운 패턴을 적극 활용해야겠다.\r\n\r\n---\r\n\r\n## 회고 요약\r\n\r\n- 배열 메서드(map, filter, reduce, find 등)의 심화 활용법 학습\r\n- 객체 조작 기법(구조 분해, 스프레드, Object 메서드) 익히기\r\n- 실전 데이터 변환 및 구조화 패턴 연습\r\n- 성능 최적화와 대용량 데이터 처리 고려사항 이해\r\n- 함수형 프로그래밍 접근법의 장점 경험\r\n \r\n"
    },
    {
      "id": "2025-05-17-auto-generated",
      "title": "JavaScript Event Loop와 비동기 처리 이해하기",
      "date": "2025-05-17",
      "category": "daily",
      "tags": [
        "JavaScript",
        "HTML",
        "Java",
        "학습",
        "프로젝트"
      ],
      "image": "https://images.unsplash.com/photo-1542831371-29b0f74f9713?w=400&h=200&fit=crop",
      "description": "2025-05-17의 학습 내용 정리",
      "excerpt": "부트캠프에서 JavaScript의 비동기 처리 방식을 배우는 날이었다. 처음엔 복잡해 보였지만 실습을 통해 조금씩 이해하게 되었다.\r",
      "content": "# JavaScript Event Loop와 비동기 처리 이해하기\r\n\r\n부트캠프에서 JavaScript의 비동기 처리 방식을 배우는 날이었다. 처음엔 복잡해 보였지만 실습을 통해 조금씩 이해하게 되었다.\r\n\r\n## 🔄 JavaScript 이벤트 루프 개념\r\n\r\n오늘 가장 중요한 개념인 이벤트 루프를 이해하는 데 집중했다:\r\n\r\n1. **싱글 스레드 언어**: JavaScript는 한 번에 하나의 작업만 처리할 수 있는 싱글 스레드 언어이다.\r\n2. **호출 스택(Call Stack)**: 함수 호출이 스택에 쌓이고, 실행이 완료되면 제거된다.\r\n3. **태스크 큐(Task Queue)**: 비동기 작업이 완료되면 콜백 함수가 대기하는 공간\r\n4. **이벤트 루프**: 호출 스택이 비었을 때 태스크 큐의 작업을 호출 스택으로 이동시킨다.\r\n\r\n```javascript\r\nconsole.log(\"시작\");\r\n\r\nsetTimeout(() => {\r\n  console.log(\"타이머 완료\");\r\n}, 2000);\r\n\r\nconsole.log(\"끝\");\r\n\r\n// 출력 순서:\r\n// \"시작\"\r\n// \"끝\"\r\n// (2초 후) \"타이머 완료\"\r\n```\r\n\r\n## ⏱️ setTimeout과 setInterval 활용\r\n\r\n타이머 함수들의 사용법을 실습했다:\r\n\r\n```javascript\r\n// 한 번 실행 후 종료\r\nconst timerId = setTimeout(() => {\r\n  console.log(\"3초 후에 실행됨!\");\r\n}, 3000);\r\n\r\n// 필요시 타이머 취소\r\nclearTimeout(timerId);\r\n\r\n// 주기적으로 반복 실행\r\nconst intervalId = setInterval(() => {\r\n  console.log(\"매 1초마다 실행됨!\");\r\n}, 1000);\r\n\r\n// 필요시 인터벌 취소\r\nclearInterval(intervalId);\r\n```\r\n\r\n특히 인터벌 함수를 이용해 간단한 카운트다운 타이머를 만들어보았다:\r\n\r\n```javascript\r\nlet countdown = 10;\r\n\r\nconst countdownEl = document.getElementById('countdown');\r\ncountdownEl.textContent = countdown;\r\n\r\nconst timerId = setInterval(() => {\r\n  countdown -= 1;\r\n  countdownEl.textContent = countdown;\r\n  \r\n  if (countdown <= 0) {\r\n    clearInterval(timerId);\r\n    countdownEl.textContent = \"발사!\";\r\n  }\r\n}, 1000);\r\n```\r\n\r\n## 🔄 콜백 함수와 콜백 지옥\r\n\r\n비동기 작업을 처리하기 위한 전통적인 방법인 콜백 함수와 그 한계에 대해 배웠다:\r\n\r\n```javascript\r\n// 콜백 지옥 예시\r\ngetUserData(userId, (userData) => {\r\n  getPostsByUser(userData.id, (posts) => {\r\n    getCommentsForPost(posts[0].id, (comments) => {\r\n      getLikesForComments(comments[0].id, (likes) => {\r\n        // 들여쓰기 지옥...\r\n        console.log(likes);\r\n      });\r\n    });\r\n  });\r\n});\r\n```\r\n\r\n이런 방식이 가독성과 에러 처리에 문제가 있다는 것을 이해하고, 더 나은 대안을 찾게 되었다.\r\n\r\n## 📝 Promise 개념 배우기\r\n\r\n콜백 지옥을 해결하기 위한 Promise 객체에 대해 배웠다:\r\n\r\n1. **상태**: pending(대기), fulfilled(이행), rejected(거부)\r\n2. **메서드**: then(), catch(), finally()\r\n\r\n```javascript\r\n// Promise 생성\r\nconst myPromise = new Promise((resolve, reject) => {\r\n  // 비동기 작업 수행\r\n  setTimeout(() => {\r\n    const success = Math.random() > 0.5; // 50% 확률로 성공/실패\r\n    \r\n    if (success) {\r\n      resolve(\"작업 성공!\"); // 성공 시 호출\r\n    } else {\r\n      reject(\"에러 발생!\"); // 실패 시 호출\r\n    }\r\n  }, 2000);\r\n});\r\n\r\n// Promise 사용\r\nmyPromise\r\n  .then((result) => {\r\n    console.log(\"성공:\", result);\r\n  })\r\n  .catch((error) => {\r\n    console.log(\"실패:\", error);\r\n  })\r\n  .finally(() => {\r\n    console.log(\"작업 완료 (성공/실패 상관없이 실행)\");\r\n  });\r\n```\r\n\r\n이렇게 하면 콜백 지옥을 피하고 더 가독성 있는 코드를 작성할 수 있다:\r\n\r\n```javascript\r\n// Promise 체이닝\r\ngetUserData(userId)\r\n  .then(userData => getPostsByUser(userData.id))\r\n  .then(posts => getCommentsForPost(posts[0].id))\r\n  .then(comments => getLikesForComments(comments[0].id))\r\n  .then(likes => console.log(likes))\r\n  .catch(error => console.error(\"에러 발생:\", error));\r\n```\r\n\r\n## ⚡ 실습 프로젝트: 날씨 API 호출\r\n\r\n배운 개념을 활용해서 간단한 날씨 API 호출 앱을 만들어보았다:\r\n\r\n```javascript\r\n// 날씨 API 호출 함수\r\nfunction getWeather(city) {\r\n  const apiKey = \"sample_api_key\"; // 실제 API 키로 대체해야 함\r\n  const url = `https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${apiKey}&units=metric`;\r\n  \r\n  // fetch API 사용 (Promise 기반)\r\n  return fetch(url)\r\n    .then(response => {\r\n      if (!response.ok) {\r\n        throw new Error(\"날씨 정보를 가져오는 데 실패했습니다.\");\r\n      }\r\n      return response.json();\r\n    })\r\n    .then(data => {\r\n      return {\r\n        city: data.name,\r\n        temp: data.main.temp,\r\n        description: data.weather[0].description,\r\n        icon: data.weather[0].icon\r\n      };\r\n    });\r\n}\r\n\r\n// 사용 예시\r\nconst cityInput = document.getElementById(\"city-input\");\r\nconst searchBtn = document.getElementById(\"search-button\");\r\nconst resultDiv = document.getElementById(\"weather-result\");\r\n\r\nsearchBtn.addEventListener(\"click\", () => {\r\n  const city = cityInput.value.trim();\r\n  \r\n  if (!city) {\r\n    alert(\"도시 이름을 입력하세요!\");\r\n    return;\r\n  }\r\n  \r\n  resultDiv.innerHTML = \"로딩 중...\";\r\n  \r\n  getWeather(city)\r\n    .then(weatherData => {\r\n      resultDiv.innerHTML = `\r\n        <h2>${weatherData.city}</h2>\r\n        <p>온도: ${weatherData.temp}°C</p>\r\n        <p>날씨: ${weatherData.description}</p>\r\n        <img src=\"https://openweathermap.org/img/wn/${weatherData.icon}@2x.png\" alt=\"날씨 아이콘\">\r\n      `;\r\n    })\r\n    .catch(error => {\r\n      resultDiv.innerHTML = `<p class=\"error\">에러: ${error.message}</p>`;\r\n    });\r\n});\r\n```\r\n\r\n## 🤔 아직 어려운 부분들\r\n\r\n1. **에러 처리 전략**: Promise 체인에서 어느 단계에서 에러가 발생했는지 구분하는 방법\r\n2. **동시 실행**: Promise.all()과 Promise.race()의 적절한 사용 시점\r\n3. **비동기 코드 테스트**: 비동기 코드를 어떻게 효과적으로 테스트할 수 있을지\r\n\r\n## 💡 다음 학습 계획\r\n\r\n1. **async/await 문법** 학습하기 - Promise를 더 간결하게 사용하는 방법\r\n2. **실전 프로젝트**에 비동기 처리 적용해보기\r\n3. **에러 처리 패턴** 더 깊이 공부하기\r\n\r\n## 🪬 오늘의 교훈\r\n\r\nJavaScript의 비동기 처리는 처음에는 복잡해 보이지만, 기본 개념만 이해하면 응용할 수 있다. 특히 콜백 함수 → Promise → async/await로 발전해온 역사적 맥락을 이해하니 왜 이런 문법들이 필요한지 공감할 수 있었다. 앞으로 실제 프로젝트에서 더 많이 활용해봐야겠다.\r\n\r\n---\r\n\r\n## 회고 요약\r\n\r\n- JavaScript 이벤트 루프와 비동기 처리 원리 이해\r\n- setTimeout, setInterval 활용 방법 학습\r\n- 콜백 지옥의 문제점과 Promise를 통한 해결책 이해\r\n- fetch API를 활용한 실제 비동기 API 호출 실습\r\n- 아직 에러 처리와 동시 실행 관련 개념 더 필요\r\n- 다음 단계로 async/await 학습 예정\r\n"
    },
    {
      "id": "2025-05-16-auto-generated",
      "title": "HTML, CSS, JavaScript 기초 학습 정리",
      "date": "2025-05-16",
      "category": "daily",
      "tags": [
        "3498db",
        "2ecc71",
        "333",
        "username",
        "3498db",
        "f4f4f4",
        "task",
        "ddd",
        "e74c3c",
        "task",
        "task"
      ],
      "image": "https://images.unsplash.com/photo-1542831371-29b0f74f9713?w=400&h=200&fit=crop",
      "description": "2025-05-16의 학습 내용 정리",
      "excerpt": "부트캠프 4주차를 마치며 HTML, CSS, JavaScript 기본기에 대해 배운 내용을 정리해봤다. 처음 접하는 개념들도 많았지만 조금씩 이해하고 있는 것 같다.\r",
      "content": "# HTML, CSS, JavaScript 기초 학습 정리\r\n\r\n부트캠프 4주차를 마치며 HTML, CSS, JavaScript 기본기에 대해 배운 내용을 정리해봤다. 처음 접하는 개념들도 많았지만 조금씩 이해하고 있는 것 같다.\r\n\r\n## 📝 HTML 구조화에 대한 배움\r\n\r\n오늘은 시맨틱 태그의 중요성에 대해 더 깊이 이해했다:\r\n\r\n1. **시맨틱 태그 활용하기**:\r\n   ```html\r\n   <!-- 🔴 Before: div만 사용한 구조 -->\r\n   <div class=\"header\">\r\n     <div class=\"logo\">로고</div>\r\n     <div class=\"nav\">메뉴</div>\r\n   </div>\r\n   <div class=\"main\">\r\n     <div class=\"article\">내용</div>\r\n     <div class=\"sidebar\">사이드바</div>\r\n   </div>\r\n   <div class=\"footer\">푸터</div>\r\n   \r\n   <!-- 🟢 After: 시맨틱 태그 사용 -->\r\n   <header>\r\n     <div class=\"logo\">로고</div>\r\n     <nav>메뉴</nav>\r\n   </header>\r\n   <main>\r\n     <article>내용</article>\r\n     <aside>사이드바</aside>\r\n   </main>\r\n   <footer>푸터</footer>\r\n   ```\r\n   \r\n2. **폼 요소 제대로 사용하기**:\r\n   ```html\r\n   <!-- label과 input 연결의 중요성 -->\r\n   <form>\r\n     <div class=\"form-group\">\r\n       <label for=\"username\">사용자 이름:</label>\r\n       <input type=\"text\" id=\"username\" name=\"username\" required>\r\n     </div>\r\n     <div class=\"form-group\">\r\n       <label for=\"email\">이메일:</label>\r\n       <input type=\"email\" id=\"email\" name=\"email\" required>\r\n     </div>\r\n     <button type=\"submit\">가입하기</button>\r\n   </form>\r\n   ```\r\n\r\n## 🎨 CSS 스타일링 능력 향상\r\n\r\nCSS 레이아웃 기본기를 다지는데 집중했다:\r\n\r\n1. **Flexbox 사용법 마스터하기**:\r\n   ```css\r\n   .container {\r\n     display: flex;\r\n     justify-content: space-between; /* 아이템 사이에 공간 배분 */\r\n     align-items: center; /* 세로 방향 가운데 정렬 */\r\n     flex-wrap: wrap; /* 공간이 부족하면 여러 줄로 */\r\n   }\r\n   \r\n   .item {\r\n     flex: 1; /* 여유 공간 균등 배분 */\r\n     margin: 10px;\r\n   }\r\n   ```\r\n\r\n2. **반응형 디자인 기초**:\r\n   ```css\r\n   /* 모바일 우선 접근법 */\r\n   .container {\r\n     padding: 15px;\r\n   }\r\n   \r\n   /* 태블릿 */\r\n   @media (min-width: 768px) {\r\n     .container {\r\n       padding: 30px;\r\n     }\r\n   }\r\n   \r\n   /* 데스크탑 */\r\n   @media (min-width: 1024px) {\r\n     .container {\r\n       max-width: 1200px;\r\n       margin: 0 auto;\r\n     }\r\n   }\r\n   ```\r\n\r\n3. **CSS 변수 활용하기**:\r\n   ```css\r\n   :root {\r\n     --primary-color: #3498db;\r\n     --secondary-color: #2ecc71;\r\n     --text-color: #333;\r\n     --spacing-unit: 8px;\r\n   }\r\n   \r\n   .button {\r\n     background-color: var(--primary-color);\r\n     color: white;\r\n     padding: calc(var(--spacing-unit) * 2);\r\n     border-radius: var(--spacing-unit);\r\n   }\r\n   \r\n   .alert {\r\n     border: 1px solid var(--secondary-color);\r\n     margin: var(--spacing-unit) 0;\r\n   }\r\n   ```\r\n\r\n## 🧠 JavaScript 기초 다지기\r\n\r\nJavaScript 기본 문법과 DOM 조작에 집중했다:\r\n\r\n1. **이벤트 리스너 활용**:\r\n   ```javascript\r\n   // 버튼 클릭 이벤트 처리\r\n   const button = document.querySelector('.submit-button');\r\n   \r\n   button.addEventListener('click', function(event) {\r\n     event.preventDefault(); // 기본 동작 방지\r\n     \r\n     const username = document.querySelector('#username').value;\r\n     \r\n     if (username.length < 3) {\r\n       alert('사용자 이름은 3글자 이상이어야 합니다.');\r\n       return;\r\n     }\r\n     \r\n     console.log('폼 제출 성공:', username);\r\n   });\r\n   ```\r\n\r\n2. **배열 메서드 이해하기**:\r\n   ```javascript\r\n   const numbers = [1, 2, 3, 4, 5];\r\n   \r\n   // forEach로 각 요소 순회\r\n   numbers.forEach(function(number) {\r\n     console.log(number * 2);\r\n   });\r\n   \r\n   // map으로 새 배열 만들기\r\n   const doubled = numbers.map(function(number) {\r\n     return number * 2;\r\n   });\r\n   \r\n   // filter로 조건에 맞는 요소만 선택\r\n   const evenNumbers = numbers.filter(function(number) {\r\n     return number % 2 === 0;\r\n   });\r\n   ```\r\n\r\n3. **로컬 스토리지 활용하기**:\r\n   ```javascript\r\n   // 데이터 저장하기\r\n   function saveTask(task) {\r\n     let tasks = getTasks();\r\n     tasks.push(task);\r\n     localStorage.setItem('tasks', JSON.stringify(tasks));\r\n   }\r\n   \r\n   // 데이터 불러오기\r\n   function getTasks() {\r\n     const tasksJSON = localStorage.getItem('tasks');\r\n     if (tasksJSON === null) {\r\n       return [];\r\n     }\r\n     return JSON.parse(tasksJSON);\r\n   }\r\n   \r\n   // 사용 예\r\n   saveTask('HTML 공부하기');\r\n   saveTask('CSS 레이아웃 연습');\r\n   console.log(getTasks());\r\n   ```\r\n\r\n## 🚀 미니 프로젝트: 할일 목록 만들기\r\n\r\n이번 주에 배운 내용을 활용해 간단한 할일 목록 앱을 만들어보았다. 아직 기능은 단순하지만 HTML, CSS, JavaScript를 모두 활용할 수 있었다:\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"ko\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n  <title>할일 목록</title>\r\n  <style>\r\n    :root {\r\n      --primary-color: #3498db;\r\n      --light-gray: #f4f4f4;\r\n    }\r\n    \r\n    body {\r\n      font-family: 'Arial', sans-serif;\r\n      line-height: 1.6;\r\n      margin: 0;\r\n      padding: 20px;\r\n    }\r\n    \r\n    .container {\r\n      max-width: 500px;\r\n      margin: 0 auto;\r\n      background: white;\r\n      padding: 20px;\r\n      border-radius: 5px;\r\n      box-shadow: 0 0 10px rgba(0,0,0,0.1);\r\n    }\r\n    \r\n    h1 {\r\n      text-align: center;\r\n      color: var(--primary-color);\r\n    }\r\n    \r\n    .task-form {\r\n      display: flex;\r\n      margin-bottom: 20px;\r\n    }\r\n    \r\n    #task-input {\r\n      flex: 1;\r\n      padding: 10px;\r\n      border: 1px solid #ddd;\r\n      border-radius: 4px 0 0 4px;\r\n    }\r\n    \r\n    .add-button {\r\n      background: var(--primary-color);\r\n      color: white;\r\n      border: none;\r\n      padding: 10px 15px;\r\n      border-radius: 0 4px 4px 0;\r\n      cursor: pointer;\r\n    }\r\n    \r\n    .task-list {\r\n      list-style: none;\r\n      padding: 0;\r\n    }\r\n    \r\n    .task-item {\r\n      display: flex;\r\n      justify-content: space-between;\r\n      align-items: center;\r\n      padding: 10px;\r\n      margin-bottom: 10px;\r\n      background: var(--light-gray);\r\n      border-radius: 4px;\r\n    }\r\n    \r\n    .delete-button {\r\n      background: #e74c3c;\r\n      color: white;\r\n      border: none;\r\n      padding: 5px 10px;\r\n      border-radius: 3px;\r\n      cursor: pointer;\r\n    }\r\n  </style>\r\n</head>\r\n<body>\r\n  <div class=\"container\">\r\n    <h1>할일 목록</h1>\r\n    \r\n    <form class=\"task-form\">\r\n      <input type=\"text\" id=\"task-input\" placeholder=\"할일을 입력하세요\">\r\n      <button type=\"submit\" class=\"add-button\">추가</button>\r\n    </form>\r\n    \r\n    <ul class=\"task-list\" id=\"task-list\">\r\n      <!-- 할일 항목이 여기에 추가됨 -->\r\n    </ul>\r\n  </div>\r\n\r\n  <script>\r\n    // DOM 요소 가져오기\r\n    const taskForm = document.querySelector('.task-form');\r\n    const taskInput = document.querySelector('#task-input');\r\n    const taskList = document.querySelector('#task-list');\r\n    \r\n    // 저장된 할일 불러오기\r\n    function loadTasks() {\r\n      const tasks = getTasks();\r\n      \r\n      tasks.forEach(function(task) {\r\n        addTaskToDOM(task);\r\n      });\r\n    }\r\n    \r\n    // 로컬 스토리지에서 할일 불러오기\r\n    function getTasks() {\r\n      const tasksJSON = localStorage.getItem('tasks');\r\n      if (tasksJSON === null) {\r\n        return [];\r\n      }\r\n      return JSON.parse(tasksJSON);\r\n    }\r\n    \r\n    // 로컬 스토리지에 할일 저장하기\r\n    function saveTasks(tasks) {\r\n      localStorage.setItem('tasks', JSON.stringify(tasks));\r\n    }\r\n    \r\n    // DOM에 할일 추가하기\r\n    function addTaskToDOM(task) {\r\n      const li = document.createElement('li');\r\n      li.className = 'task-item';\r\n      \r\n      const taskText = document.createElement('span');\r\n      taskText.textContent = task;\r\n      \r\n      const deleteButton = document.createElement('button');\r\n      deleteButton.className = 'delete-button';\r\n      deleteButton.textContent = '삭제';\r\n      \r\n      // 삭제 버튼 이벤트 리스너\r\n      deleteButton.addEventListener('click', function() {\r\n        li.remove();\r\n        removeTask(task);\r\n      });\r\n      \r\n      li.appendChild(taskText);\r\n      li.appendChild(deleteButton);\r\n      taskList.appendChild(li);\r\n    }\r\n    \r\n    // 할일 삭제하기\r\n    function removeTask(taskToRemove) {\r\n      let tasks = getTasks();\r\n      tasks = tasks.filter(function(task) {\r\n        return task !== taskToRemove;\r\n      });\r\n      saveTasks(tasks);\r\n    }\r\n    \r\n    // 폼 제출 이벤트 처리\r\n    taskForm.addEventListener('submit', function(event) {\r\n      event.preventDefault();\r\n      \r\n      const taskText = taskInput.value.trim();\r\n      \r\n      if (taskText === '') {\r\n        alert('할일을 입력해주세요!');\r\n        return;\r\n      }\r\n      \r\n      // 할일 추가\r\n      addTaskToDOM(taskText);\r\n      \r\n      // 로컬 스토리지에 저장\r\n      const tasks = getTasks();\r\n      tasks.push(taskText);\r\n      saveTasks(tasks);\r\n      \r\n      // 입력 필드 초기화\r\n      taskInput.value = '';\r\n    });\r\n    \r\n    // 페이지 로드 시 할일 불러오기\r\n    loadTasks();\r\n  </script>\r\n</body>\r\n</html>\r\n```\r\n\r\n## 🤔 현재 어려움을 겪는 부분\r\n\r\n1. **JavaScript 비동기 처리**: `setTimeout`이나 `fetch` 같은 비동기 함수들의 개념이 아직 완전히 와닿지 않는다. 콜백 함수가 언제 실행되는지 가끔 헷갈린다.\r\n\r\n2. **CSS 레이아웃**: Flexbox를 배웠지만 복잡한 레이아웃을 구성할 때 여전히 요소들이 의도한 대로 배치되지 않는 경우가 많다. 특히 반응형으로 만들 때 어려움을 느낀다.\r\n\r\n3. **JavaScript 스코프**: 변수의 스코프와 호이스팅 개념이 아직 확실하게 이해되지 않아 가끔 예상치 못한 결과가 나온다.\r\n\r\n## 💡 다음 주 학습 계획\r\n\r\n1. **JavaScript 이벤트 버블링과 캡처링** 개념 확실히 이해하기\r\n2. **CSS Grid** 학습하기 - Flexbox와 함께 사용하면 더 복잡한 레이아웃도 쉽게 만들 수 있을 것 같다\r\n3. **JavaScript 배열과 객체의 고급 메서드** 더 익숙해지기\r\n4. **간단한 API 호출**로 외부 데이터 가져오기 연습\r\n\r\n## 🪬 오늘의 교훈\r\n\r\n기본기가 탄탄해야 응용도 가능하다는 점을 다시 한번 느꼈다. HTML, CSS, JavaScript의 기초 개념들을 충분히 이해하지 않으면 복잡한 기능 구현에서 계속 막히게 된다. 조급해하지 말고 기본을 충실히 다지는 시간을 가져야겠다.\r\n\r\n---\r\n\r\n## 회고 요약\r\n\r\n- HTML 시맨틱 태그의 중요성과 올바른 사용법\r\n- CSS Flexbox를 활용한 레이아웃 구성\r\n- JavaScript 기본 문법과 DOM 조작 연습\r\n- 할일 목록 미니 프로젝트로 배운 내용 적용\r\n- 아직 어려운 부분: 비동기 처리, 복잡한 레이아웃, 스코프\r\n- 기본기 탄탄히 다지는 것의 중요성\r\n"
    },
    {
      "id": "2025-05-14-auto-generated",
      "title": "테일윈드 CSS 심화와 React 컴포넌트 구조화 학습",
      "date": "2025-05-14",
      "category": "daily",
      "tags": [
        "Git",
        "React",
        "CSS",
        "HTML",
        "Node.js",
        "학습",
        "프로젝트",
        "개발"
      ],
      "image": "https://images.unsplash.com/photo-1516321318423-f06f85e504b3?w=400&h=200&fit=crop",
      "description": "2025-05-14의 학습 내용 정리",
      "excerpt": "오늘은 테일윈드 CSS를 더 깊이 공부하고, React에서 효율적인 컴포넌트 구조를 설계하는 방법에 대해 학습했다. 맥북 환경에 점차 적응해가는 중이고, 이제는 꽤 편안하게 작업할...",
      "content": "# 테일윈드 CSS 심화와 React 컴포넌트 구조화 학습\r\n\r\n오늘은 테일윈드 CSS를 더 깊이 공부하고, React에서 효율적인 컴포넌트 구조를 설계하는 방법에 대해 학습했다. 맥북 환경에 점차 적응해가는 중이고, 이제는 꽤 편안하게 작업할 수 있게 되었다.\r\n\r\n## 📚 테일윈드 CSS 심화 학습\r\n\r\n테일윈드를 쓰기 전에는 CSS를 직접 작성하는 방식에 익숙했었는데, 테일윈드의 유틸리티 우선 접근법이 처음에는 다소 혼란스러웠다. 하지만 오늘 실제 프로젝트에 적용해보니 몇 가지 큰 장점을 발견했다:\r\n\r\n1. **클래스 작명에 드는 시간 절약**: 매번 BEM 같은 방식으로 클래스명을 고민할 필요가 없어졌다.\r\n2. **일관된 디자인 시스템**: spacing, color, typography 등이 사전 정의된 값으로 제한되어 디자인 일관성 유지가 쉬움\r\n3. **반응형 설계 간소화**: `md:`, `lg:` 같은 접두사로 간단하게 반응형 구현 가능\r\n\r\n```jsx\r\n// 이런 식으로 직관적인 클래스 이름들로 스타일링이 가능해짐\r\n<div className=\"p-4 m-2 bg-white rounded-lg shadow-md hover:shadow-lg transition-shadow duration-300 md:flex md:items-center\">\r\n  <h2 className=\"text-xl font-bold text-gray-800 mb-2 md:mb-0 md:mr-4\">테일윈드 예시</h2>\r\n  <p className=\"text-gray-600\">반응형으로 쉽게 스타일링 가능!</p>\r\n</div>\r\n```\r\n\r\n하지만 처음 배울 때 어려웠던 부분도 있었다:\r\n\r\n- **클래스명 폭발**: 여러 스타일을 적용하면 HTML이 클래스로 가득 차서 가독성이 떨어짐\r\n- **특정 상황에서 커스텀 필요**: 프로젝트 특성에 맞는 설정을 위해 `tailwind.config.js` 파일 수정 방법 습득 필요\r\n- **개발 도구 통합**: VSCode에서 Tailwind CSS IntelliSense 확장 프로그램 설치해서 자동완성 지원 받도록 설정\r\n\r\n## 🧩 React 컴포넌트 구조화\r\n\r\n오늘의 가장 큰 배움은 React 컴포넌트를 어떻게 효율적으로 구조화할지에 대한 고민이었다. 특히 아래 문제들을 해결하려고 노력했다:\r\n\r\n1. **컴포넌트 크기와 책임**: 너무 큰 컴포넌트는 유지보수가 어렵고, 너무 작은 컴포넌트는 복잡도만 증가시킨다.\r\n2. **상태 관리 위치**: 어떤 상태를 어느 레벨에서 관리할지 결정하는 것이 중요하다.\r\n3. **Props 드릴링 최소화**: 컴포넌트 트리가 깊어지면 props를 여러 계층 통과시키는 문제 발생\r\n\r\n이를 해결하기 위해 아래 패턴을 적용해봤다:\r\n\r\n```jsx\r\n// 🔴 Before: 모든 것이 하나의 큰 컴포넌트에 있음\r\nfunction UserDashboard() {\r\n  const [userData, setUserData] = useState(null);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n  \r\n  // 수십 줄의 로직과 UI 코드...\r\n  \r\n  return (\r\n    <div>\r\n      {/* 복잡한 JSX 구조 */}\r\n    </div>\r\n  );\r\n}\r\n\r\n// 🟢 After: 기능별로 분리하고 Custom Hook 사용\r\nfunction useUserData() {\r\n  const [userData, setUserData] = useState(null);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n  \r\n  // 데이터 로딩 로직...\r\n  \r\n  return { userData, isLoading, error };\r\n}\r\n\r\nfunction UserDashboard() {\r\n  const { userData, isLoading, error } = useUserData();\r\n  \r\n  if (isLoading) return <LoadingSpinner />;\r\n  if (error) return <ErrorMessage message={error} />;\r\n  \r\n  return (\r\n    <div className=\"p-4\">\r\n      <UserHeader user={userData} />\r\n      <div className=\"mt-4 grid grid-cols-1 md:grid-cols-2 gap-4\">\r\n        <UserStats stats={userData.stats} />\r\n        <UserActivities activities={userData.activities} />\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n이렇게 리팩토링하니 몇 가지 이점을 느꼈다:\r\n- 각 컴포넌트의 역할이 명확해짐\r\n- 테스트하기 쉬워짐\r\n- 코드 재사용성이 높아짐\r\n- 버그 발생 시 디버깅하기 쉬워짐\r\n\r\n## 🛠️ 맥북 개발 환경 최적화\r\n\r\n맥북을 사용한 지 얼마 안 되다 보니 개발 생산성을 높이기 위한 설정들을 계속 찾아보는 중이다. 오늘 적용한 것들:\r\n\r\n1. **Oh My Zsh**: 터미널 사용성 대폭 개선\r\n   ```bash\r\n   # 설치 후 몇 가지 유용한 플러그인 추가\r\n   plugins=(git node npm yarn vscode)\r\n   ```\r\n\r\n2. **VS Code 단축키 학습**: \r\n   - `Cmd+P`: 파일 빠르게 찾기\r\n   - `Cmd+Shift+P`: 모든 명령어 검색\r\n   - `Opt+Shift+F`: 코드 자동 포맷팅\r\n   - `Cmd+B`: 사이드바 토글\r\n\r\n3. **개발 도구**: Reactr 개발자 도구, Redux DevTools 등 브라우저 확장 프로그램 설치\r\n\r\n## 🤔 오늘의 고민\r\n\r\n프로젝트가 복잡해질수록 상태 관리에 대한 고민이 커진다. React의 Context API와 useReducer만으로 충분할지, 아니면 Redux나 Recoil 같은 외부 라이브러리가 필요할지 판단이 어렵다.\r\n\r\n```jsx\r\n// Context API + useReducer 조합은 간단한 상태 관리에 좋음\r\nconst initialState = { count: 0 };\r\n\r\nfunction reducer(state, action) {\r\n  switch (action.type) {\r\n    case 'increment':\r\n      return { count: state.count + 1 };\r\n    case 'decrement':\r\n      return { count: state.count - 1 };\r\n    default:\r\n      throw new Error();\r\n  }\r\n}\r\n\r\nfunction Counter() {\r\n  const [state, dispatch] = useReducer(reducer, initialState);\r\n  \r\n  return (\r\n    <>\r\n      Count: {state.count}\r\n      <button onClick={() => dispatch({type: 'increment'})}>+</button>\r\n      <button onClick={() => dispatch({type: 'decrement'})}>-</button>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n하지만 이런 방식도 컴포넌트가 많아지면 관리하기 어려울 것 같다. 예비창업패키지 준비하면서 만들 프로젝트에는 더 체계적인 접근이 필요할 듯.\r\n\r\n## 💡 내일 학습 계획\r\n\r\n1. **테일윈드 커스텀 설정**: 프로젝트에 맞는 테마 컬러, 애니메이션 등 커스텀 설정 방법 익히기\r\n2. **React Performance**: 불필요한 리렌더링 방지하는 메모이제이션 기법들 (useMemo, useCallback) 학습\r\n3. **상태 관리**: Redux vs Context API 심층 비교 및 적합한 사용 케이스 학습\r\n\r\n## 🪬 오늘의 교훈\r\n\r\n복잡한 문제는 작은 단위로 나누어 해결하는 것이 중요하다. 이는 UI 컴포넌트 설계에도 동일하게 적용된다. 처음부터 완벽한 구조를 만들려고 하기보다, 작은 단위로 쪼개고 반복적으로 개선해 나가는 접근법이 더 효과적임을 다시 한번 깨달았다.\r\n\r\n---\r\n\r\n## 회고 요약\r\n\r\n- 테일윈드 CSS의 유틸리티 중심 접근법 장단점 이해\r\n- React 컴포넌트 구조화와 관심사 분리 패턴 적용\r\n- 맥북 개발 환경 최적화 (터미널, VS Code 설정)\r\n- 확장성 있는 상태 관리 방법 고민 중\r\n- 점진적 개선 접근법의 중요성 재확인\r\n"
    },
    {
      "id": "2025-05-12-auto-generated",
      "title": "맥북 길들이기중",
      "date": "2025-05-12",
      "category": "daily",
      "tags": [
        "CSS"
      ],
      "image": "https://images.unsplash.com/photo-1516321318423-f06f85e504b3?w=400&h=200&fit=crop",
      "description": "2025-05-12의 학습 내용 정리",
      "excerpt": "최근 맥북을 구매해서 환경설정 세팅부터 하고있음.\r",
      "content": "# 맥북 길들이기중\r\n\r\n최근 맥북을 구매해서 환경설정 세팅부터 하고있음.\r\n\r\n확실히 윈도우랑 달라서, 어려운 부분은 있으나 휴대성이나 최적화 등등 여러가지를 생각 했을 때\r\n맥도 익숙해져야 할 것 같다!\r\n\r\n테일윈드에 대해 공부했는데 일단 기본에 충실하게 .css 부터 구현하는게 우선일듯."
    },
    {
      "id": "2025-05-10-auto-generated",
      "title": "2025-05-10 기술회고",
      "date": "2025-05-10",
      "category": "daily",
      "tags": [
        "CSS",
        "HTML"
      ],
      "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=400&h=200&fit=crop",
      "description": "2025-05-10의 학습 내용 정리",
      "excerpt": "자바스크립트를 공부하면서 html+css 에 대한 부족한 부분이 있을까 싶어,\r",
      "content": "# 2025-05-10 기술회고\r\n\r\n자바스크립트를 공부하면서 html+css 에 대한 부족한 부분이 있을까 싶어,\r\n챗지피티를 통한 테스트를 시작했다 정답률은 99퍼에 수렴하는데, 문제는\r\n해당 문제에 대한 정확한 로직을 알지못해서 디테일 하게 공부하는 중이다.\r\n\r\n자바스크립트는 양이 상당해서, 갈길이 멀었다고 느끼는 중이고,\r\n이건 기술회고가 아니라 til 블로그글 같은 개념이라 조만간 깃허브 제목도 수정해야 할듯 싶다.\r\n\r\n\r\n"
    },
    {
      "id": "2025-05-09-auto-generated",
      "title": "2025-05-09 학습 일지",
      "date": "2025-05-09",
      "category": "daily",
      "tags": [
        "Git",
        "CSS",
        "HTML",
        "학습"
      ],
      "image": "https://images.unsplash.com/photo-1518432031352-d6fc5c10da5a?w=400&h=200&fit=crop",
      "description": "2025-05-09의 학습 내용 정리",
      "excerpt": "- `login.html` 마크업 구조 재작성\r",
      "content": "## ✅ 오늘 진행한 작업\r\n\r\n- `login.html` 마크업 구조 재작성\r\n  - `<label>` 및 `<input>`의 접근성 마크업 준수\r\n  - SVG 직접 삽입 (Naver 로고, 체크박스)\r\n- `login.css` 전면 리디자인\r\n  - Apple 스타일 감성 적용 (카드형 UI, 라운드 버튼, 포커스 효과)\r\n  - 반응형 (768px 이상일 때 가로 500px 유지)\r\n  - rem 단위 글자 크기 및 여백 사용\r\n  - 로그인 상태 유지 / IP 보안 체크박스 커스텀 UI 적용\r\n- `Git` 커밋이 안 남는 현상 점검\r\n  - `git add`, `commit`, `push`의 흐름 다시 점검\r\n  - `.gitignore`와 브랜치 mismatch 가능성 체크\r\n- 회고 마크다운 양식 정비 및 md 구조 정렬\r\n\r\n---\r\n\r\n## 🧠 인사이트\r\n\r\n- CSS에서 감성 있는 디자인을 내려면 `기본 구조`보다 `위계`가 더 중요하다.\r\n- 단순히 작동하는 마크업이 아니라, **시각적으로 설득력 있는 UI 구조 설계**가 필수.\r\n- Git 작업 시 `commit이 안 남는 문제`는 거의 대부분 기본 흐름 누락이었다.\r\n\r\n---\r\n\r\n## 🛠️ 내일 할 일\r\n\r\n- 로그인 페이지 최종 polish (애니메이션/hover)\r\n- Vercel 배포 or GitHub Pages 연결 확인\r\n- Git 커밋 기록 정리 및 README에 기술 링크 정리\r\n\r\n---"
    },
    {
      "id": "2025-05-08-auto-generated",
      "title": "📘 HTML & CSS 핵심 총정리 기술회고",
      "date": "2025-05-08",
      "category": "daily",
      "tags": [
        "id"
      ],
      "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=400&h=200&fit=crop",
      "description": "2025-05-08의 학습 내용 정리",
      "excerpt": "> 작성일: 2025-05-08\r",
      "content": "# 📘 HTML & CSS 핵심 총정리 기술회고\r\n\r\n> 작성일: 2025-05-08\r\n> 작성자: 최도형 ([GitHub](https://github.com/stylechoi))\r\n> 학습 방식: HTML & CSS 실무 기준 실습형 정리\r\n\r\n---\r\n\r\n## ✅ HTML 핵심 정리\r\n\r\n### 1. HTML의 기본 구조\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"ko\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n  <title>문서 제목</title>\r\n</head>\r\n<body>\r\n  <!-- 내용 작성 -->\r\n</body>\r\n</html>\r\n```\r\n\r\n### 2. 자주 사용하는 HTML 태그\r\n\r\n* **구조 태그**: `<div>`, `<section>`, `<article>`, `<header>`, `<footer>`, `<nav>`\r\n* **텍스트 태그**: `<h1>~<h6>`, `<p>`, `<span>`, `<a>`\r\n* **리스트 태그**: `<ul>`, `<ol>`, `<li>`\r\n* **폼 태그**: `<form>`, `<input>`, `<button>`, `<select>`, `<textarea>`\r\n\r\n### 3. 시맨틱(semantic) 태그\r\n\r\n* 의미 있는 태그 사용으로 웹 접근성과 SEO 향상\r\n\r\n  * `<header>`: 머리말 영역\r\n  * `<footer>`: 꼬리말 영역\r\n  * `<main>`: 주요 콘텐츠 영역\r\n  * `<aside>`: 보조 콘텐츠 영역\r\n\r\n---\r\n\r\n## ✅ CSS 핵심 정리\r\n\r\n### 1. CSS 선택자(selector)\r\n\r\n* **기본 선택자**\r\n\r\n  ```css\r\n  p { color: blue; }\r\n  .class { font-size: 16px; }\r\n  #id { background-color: yellow; }\r\n  ```\r\n\r\n* **복합 선택자**\r\n\r\n  ```css\r\n  div p { margin-top: 10px; }\r\n  div > p { padding: 5px; }\r\n  ```\r\n\r\n### 2. CSS 박스 모델(Box Model)\r\n\r\n```css\r\n.box {\r\n  width: 100px;\r\n  height: 100px;\r\n  padding: 10px;\r\n  border: 5px solid black;\r\n  margin: 15px;\r\n}\r\n```\r\n\r\n* **width/height**: 콘텐츠 영역 크기\r\n* **padding**: 콘텐츠와 경계선 사이 여백\r\n* **border**: 테두리 선\r\n* **margin**: 박스 외부 여백\r\n\r\n### 3. Flexbox 레이아웃\r\n\r\n```css\r\n.container {\r\n  display: flex;\r\n  justify-content: center; /* 가로축 정렬 */\r\n  align-items: center; /* 세로축 정렬 */\r\n}\r\n```\r\n\r\n### 4. CSS Position\r\n\r\n* **static**: 기본값\r\n* **relative**: 원래 위치에서 상대적 이동 가능\r\n* **absolute**: 부모 요소 중 position 속성이 있는 요소 기준 절대 위치\r\n* **fixed**: 화면 기준 고정 위치\r\n* **sticky**: 스크롤 시 지정된 위치에서 고정\r\n\r\n```css\r\n.position-example {\r\n  position: absolute;\r\n  top: 20px;\r\n  left: 50px;\r\n}\r\n```\r\n\r\n### 5. 미디어 쿼리(Media Query)\r\n\r\n반응형 웹사이트를 위한 미디어 쿼리 사용 예시:\r\n\r\n```css\r\n@media (max-width: 768px) {\r\n  .container {\r\n    flex-direction: column;\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 🚀 기술회고\r\n\r\nHTML과 CSS는 실무에서 매우 중요하며, 정확히 개념을 숙지하고 실습을 통해 확실히 다져놓는 것이 중요하다. Flexbox, 박스모델, 미디어 쿼리 등 실무에서 빈번히 사용되는 기술들을 확실히 숙지했고, 특히 시맨틱 태그의 중요성을 재확인했다. 앞으로의 실습에서도 꾸준히 복습하고, 더 깊이 있는 학습을 이어갈 예정이다.\r\n"
    },
    {
      "id": "2025-05-07-auto-generated",
      "title": "📘 JavaScript API 응답 패턴 심화 및 상태 관리 연동 실습",
      "date": "2025-05-07",
      "category": "daily",
      "tags": [
        "Git",
        "JavaScript",
        "React",
        "Java",
        "연습",
        "학습"
      ],
      "image": "https://images.unsplash.com/photo-1518432031352-d6fc5c10da5a?w=400&h=200&fit=crop",
      "description": "2025-05-07의 학습 내용 정리",
      "excerpt": "> 작성일: 2025-05-07  \r",
      "content": "# 📘 JavaScript API 응답 패턴 심화 및 상태 관리 연동 실습\r\n\r\n> 작성일: 2025-05-07  \r\n> 작성자: [GitHub: stylechoi](https://github.com/stylechoi)  \r\n> 학습 방식: axios + 실시간 UI 연동 + Express 서버 연결 실습 중심\r\n\r\n---\r\n\r\n## ✅ 학습 목표\r\n\r\n- axios로 API를 호출한 뒤, 클라이언트 상태 흐름과 연동하는 구조 체득\r\n- 단순 fetch를 넘어서, **UI 상태**와의 강한 결합을 통한 사용자 경험 향상\r\n- 백엔드 Express 서버와 직접 연동하여 CRUD 전체 흐름 구성\r\n\r\n---\r\n\r\n## 📒 1. axios 모듈화 및 응답 패턴 고도화\r\n\r\n```js\r\n// src/api/axiosInstance.js\r\nimport axios from 'axios';\r\n\r\nconst instance = axios.create({\r\n  baseURL: 'http://localhost:3000', // Express 서버 주소\r\n  timeout: 5000,\r\n});\r\n\r\ninstance.interceptors.response.use(\r\n  (response) => response,\r\n  (error) => {\r\n    const customError = {\r\n      error: true,\r\n      message: error.response?.data?.message || '서버 오류 발생',\r\n      status: error.response?.status || 500,\r\n    };\r\n    return Promise.reject(customError);\r\n  }\r\n);\r\n\r\nexport default instance;\r\n```\r\n\r\n> 공통 설정을 모듈화하고, `interceptors`로 에러 응답을 일관되게 가공. 실무에서 거의 필수 구조.\r\n\r\n---\r\n\r\n## 📒 2. 클라이언트에서 API 호출 후 상태 처리 예시\r\n\r\n```js\r\nimport axios from './api/axiosInstance';\r\n\r\nconst getPosts = async () => {\r\n  try {\r\n    const res = await axios.get('/posts');\r\n    return { data: res.data };\r\n  } catch (err) {\r\n    return err; // error: true, message, status\r\n  }\r\n};\r\n\r\nconst renderPosts = async () => {\r\n  const { data, error, message } = await getPosts();\r\n\r\n  if (error) {\r\n    alert(`불러오기 실패: ${message}`);\r\n    return;\r\n  }\r\n\r\n  console.log('게시글 목록:', data);\r\n};\r\n```\r\n\r\n> 상태 라이브러리 없이도 구조화된 API 호출 방식으로 깔끔한 흐름 제어 가능.\r\n\r\n---\r\n\r\n## 📒 3. Express 서버 간단 구성 (테스트용)\r\n\r\n```js\r\n// server/index.js\r\nconst express = require('express');\r\nconst cors = require('cors');\r\n\r\nconst app = express();\r\napp.use(cors());\r\napp.use(express.json());\r\n\r\nlet posts = [\r\n  { id: 1, title: '첫 번째 글' },\r\n  { id: 2, title: '두 번째 글' },\r\n];\r\n\r\napp.get('/posts', (req, res) => {\r\n  res.json(posts);\r\n});\r\n\r\napp.listen(3000, () => {\r\n  console.log('서버 실행 중: http://localhost:3000');\r\n});\r\n```\r\n\r\n> 로컬 환경에서 API 흐름 테스트 시 자주 쓰이는 미니멀 서버 구성. `json-server`보다 커스터마이징이 유리.\r\n\r\n---\r\n\r\n## 📒 4. UI 상태 라이브러리 연결 예상 구조 (Zustand 예시)\r\n\r\n```js\r\nimport { create } from 'zustand';\r\nimport axios from '../api/axiosInstance';\r\n\r\nexport const usePostStore = create((set) => ({\r\n  posts: [],\r\n  loading: false,\r\n  error: null,\r\n  fetchPosts: async () => {\r\n    set({ loading: true, error: null });\r\n    try {\r\n      const res = await axios.get('/posts');\r\n      set({ posts: res.data, loading: false });\r\n    } catch (err) {\r\n      set({ error: err.message, loading: false });\r\n    }\r\n  },\r\n}));\r\n```\r\n\r\n> 이렇게 스토어로 분리하면 컴포넌트에서 간단히 `usePostStore()`만 호출하면 상태 연동 가능.\r\n\r\n---\r\n\r\n## 🧠 느낀 점 / 회고\r\n\r\n- axios의 instance 패턴과 interceptors를 통해 확실한 **에러 가공 흐름**을 정립했다.\r\n- UI 컴포넌트와 API를 단순 호출로 연결하기보단, 상태 관리로 분리하니 확장성이 훨씬 커짐.\r\n- Express 서버로부터의 응답 구조를 설계하면서 **프론트와 백의 연결 고리**를 실감 중.\r\n- 다음 단계로는 POST/PUT/DELETE 흐름까지 직접 구현하면서 실무에 가까운 CRUD 구조 완성 예정.\r\n\r\n---\r\n\r\n## 🔜 다음 계획\r\n\r\n- POST, PUT, DELETE 추가 후, CRUD 전체 흐름 완성  \r\n- Toast 알림 연결 (React Hot Toast 등)  \r\n- 사용자 입력 → 서버 반영 → 실시간 렌더링까지 전체 연결 흐름 연습  \r\n- 백엔드 인증 구조 (JWT 등) 기초 구조 설계 착수  \r\n"
    },
    {
      "id": "2025-05-06-auto-generated",
      "title": "📘 JavaScript API 응답 처리 패턴 및 실전 실습 계획",
      "date": "2025-05-06",
      "category": "daily",
      "tags": [
        "Git",
        "JavaScript",
        "Node.js",
        "Java",
        "연습",
        "학습"
      ],
      "image": "https://images.unsplash.com/photo-1504639725590-34d0984388bd?w=400&h=200&fit=crop",
      "description": "2025-05-06의 학습 내용 정리",
      "excerpt": "> 작성일: 2025-05-06  \r",
      "content": "# 📘 JavaScript API 응답 처리 패턴 및 실전 실습 계획\r\n\r\n> 작성일: 2025-05-06  \r\n> 작성자: [GitHub: stylechoi](https://github.com/stylechoi)  \r\n> 학습 방식: fetch + axios 실습 심화 + 서버 연동 설계 구상\r\n\r\n---\r\n\r\n## ✅ 학습 목표\r\n\r\n- 실무에서 자주 사용하는 API 응답 처리 패턴을 정리하고, 에러 처리 구조를 체계화한다.\r\n- 사용자 경험을 고려한 API 상태 관리 플로우 설계.\r\n- 향후 직접 만든 백엔드 API와의 연동을 염두에 두고 구조 설계 연습.\r\n\r\n---\r\n\r\n## 📒 1. fetch의 한계와 명시적 에러 핸들링\r\n\r\n```js\r\nconst safeFetch = async (url) => {\r\n  try {\r\n    const response = await fetch(url);\r\n\r\n    if (!response.ok) {\r\n      // 서버가 200이 아니더라도 catch가 아닌 이 로직에서 걸러짐\r\n      return { error: true, status: response.status, message: response.statusText };\r\n    }\r\n\r\n    const data = await response.json();\r\n    return { data };\r\n  } catch (err) {\r\n    return { error: true, message: err.message };\r\n  }\r\n};\r\n```\r\n\r\n> 이 패턴은 데이터를 요청한 컴포넌트나 함수가 처리 분기를 쉽게 할 수 있도록 `error`, `data` 키를 명확히 리턴함. 실무에서 아주 자주 쓰임.\r\n\r\n---\r\n\r\n## 📒 2. axios 기반 try-catch + status 기반 응답 흐름 제어\r\n\r\n```js\r\nimport axios from 'axios';\r\n\r\nconst fetchWithStatusHandling = async (url) => {\r\n  try {\r\n    const response = await axios.get(url);\r\n\r\n    switch (response.status) {\r\n      case 200:\r\n        return { data: response.data };\r\n      case 401:\r\n        return { error: true, message: '인증이 필요합니다.' };\r\n      case 403:\r\n        return { error: true, message: '권한이 없습니다.' };\r\n      default:\r\n        return { error: true, message: '알 수 없는 오류 발생' };\r\n    }\r\n  } catch (error) {\r\n    return {\r\n      error: true,\r\n      message: error.response?.data?.message || error.message,\r\n    };\r\n  }\r\n};\r\n```\r\n\r\n> 실무에서는 status code에 따른 UI 피드백 처리가 중요. 이런 switch 패턴은 토스트/알림 처리와도 자주 연동됨.\r\n\r\n---\r\n\r\n## 📒 3. API 응답을 통한 UI 상태 설계 예시\r\n\r\n```js\r\nconst loadPost = async () => {\r\n  const { data, error, message } = await fetchWithStatusHandling('https://jsonplaceholder.typicode.com/posts/1');\r\n\r\n  if (error) {\r\n    alert(`불러오기 실패: ${message}`);\r\n    return;\r\n  }\r\n\r\n  console.log('성공한 데이터:', data);\r\n};\r\n```\r\n\r\n- 이처럼 응답값에 따라 상태를 제어하고 UI 처리 흐름을 관리하는 게 실무 핵심\r\n- 직접 상태 관리 라이브러리 (예: Zustand, Recoil, Redux)와 연결되기도 함\r\n\r\n---\r\n\r\n## 🚧 다음 실습 계획\r\n\r\n1. Node.js로 간단한 Express 서버 제작  \r\n2. `/posts`, `/login`, `/register` 등 기본 라우터 구성  \r\n3. 클라이언트에서 axios로 해당 API 호출 → 응답 상태에 따른 흐름 분기  \r\n4. CRUD 전체 흐름 설계 후, **프론트-백 실시간 연동** 경험 확보  \r\n\r\n---\r\n\r\n## 🧠 느낀 점 / 회고\r\n\r\n- 단순한 fetch/axios 사용은 시작일 뿐, 구조적 에러 관리 패턴이 진짜 핵심이다.\r\n- 상태 코드와 메시지 기반 분기를 만들면서, API와 UI가 강하게 연결되어 있다는 걸 체감했다.\r\n- 이후 직접 만든 API에 클라이언트를 붙여보면서, 실무에 가까운 흐름을 훈련할 계획이다.\r\n- **디버깅보다는 설계**가 중요하다는 마인드로 접근 중.\r\n"
    },
    {
      "id": "2025-05-05-auto-generated",
      "title": "📘 JavaScript API 통신 실전 정리 및 학습 회고",
      "date": "2025-05-05",
      "category": "daily",
      "tags": [
        "Git",
        "JavaScript",
        "Node.js",
        "Java",
        "연습",
        "학습"
      ],
      "image": "https://images.unsplash.com/photo-1504639725590-34d0984388bd?w=400&h=200&fit=crop",
      "description": "2025-05-05의 학습 내용 정리",
      "excerpt": "> 작성일: 2025-05-05  \r",
      "content": "# 📘 JavaScript API 통신 실전 정리 및 학습 회고\r\n\r\n> 작성일: 2025-05-05  \r\n> 작성자: [GitHub: stylechoi](https://github.com/stylechoi)  \r\n> 학습 방식: 모던 JavaScript Deep Dive + 실습 + API 테스트\r\n\r\n---\r\n\r\n## ✅ 학습 목표\r\n\r\n- 브라우저 내장 함수 `fetch`의 사용법을 이해하고 실습한다.\r\n- `axios` 라이브러리의 장점과 기본 사용법을 익힌다.\r\n- 실제 REST API와의 통신 구조를 익히고, 에러 핸들링까지 연습한다.\r\n\r\n---\r\n\r\n## 📒 1. fetch API 기본 사용법\r\n\r\n```js\r\nfetch('https://jsonplaceholder.typicode.com/posts/1')\r\n  .then(response => response.json())   // 응답을 JSON 형태로 파싱\r\n  .then(data => console.log(data))     // 파싱된 데이터 출력\r\n  .catch(error => console.error('에러 발생:', error));\r\n```\r\n\r\n- `fetch()`는 Promise를 반환한다.\r\n- `.json()`도 Promise를 반환하므로 `.then()` 체인으로 이어야 함.\r\n- 네트워크 실패 외의 HTTP 에러(404, 500 등)는 `catch`로 잡히지 않음 (직접 처리 필요)\r\n\r\n---\r\n\r\n## 📒 2. async/await로 fetch 사용하기\r\n\r\n```js\r\nconst getPost = async () => {\r\n  try {\r\n    const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`HTTP 에러 상태: ${response.status}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n    console.log(data);\r\n  } catch (error) {\r\n    console.error('에러 발생:', error.message);\r\n  }\r\n};\r\n\r\ngetPost();\r\n```\r\n\r\n- `response.ok` 확인을 통해 상태코드 체크 (성공: 200~299)\r\n- `try/catch`를 통해 async/await 구조에서도 안전한 에러 처리 가능\r\n\r\n---\r\n\r\n## 📒 3. axios 사용법\r\n\r\n```bash\r\nnpm install axios\r\n```\r\n\r\n```js\r\nimport axios from 'axios';\r\n\r\nconst getPost = async () => {\r\n  try {\r\n    const response = await axios.get('https://jsonplaceholder.typicode.com/posts/1');\r\n    console.log(response.data);\r\n  } catch (error) {\r\n    console.error('에러 발생:', error.message);\r\n  }\r\n};\r\n\r\ngetPost();\r\n```\r\n\r\n- `axios.get()`도 Promise를 반환하며 `response.data`로 바로 데이터 접근 가능\r\n- `fetch`보다 직관적이며, 자동으로 JSON 파싱해줌\r\n- `timeout`, `interceptors`, `headers` 설정 등 고급 기능이 풍부함\r\n\r\n---\r\n\r\n## 📒 4. POST 요청 실습 (axios)\r\n\r\n```js\r\nconst createPost = async () => {\r\n  try {\r\n    const response = await axios.post('https://jsonplaceholder.typicode.com/posts', {\r\n      title: '제목입니다',\r\n      body: '내용입니다',\r\n      userId: 1\r\n    });\r\n    console.log('생성된 데이터:', response.data);\r\n  } catch (error) {\r\n    console.error('POST 요청 실패:', error.message);\r\n  }\r\n};\r\n\r\ncreatePost();\r\n```\r\n\r\n- `axios.post(URL, 데이터)` 형식\r\n- 실제 API 연동에서 폼 제출, 로그인, 회원가입 등에 필수적으로 사용됨\r\n\r\n---\r\n\r\n## 🧠 느낀 점 / 회고\r\n\r\n- `fetch`는 내장되어 가볍고, `axios`는 더 편리하고 실무에 적합했다.\r\n- 비동기 로직에서 중요한 건 **에러를 반드시 처리**하는 습관이라는 걸 체감했다.\r\n- API 통신은 단순히 데이터를 가져오는 게 아니라, 서버와의 약속(JSON 포맷, 상태코드)에 따른 흐름 제어가 필수임.\r\n- 다음에는 직접 API 서버(Node.js 기반) 만들어서 클라이언트와 연동 실습할 예정.\r\n"
    },
    {
      "id": "2025-05-04-auto-generated",
      "title": "📘 JavaScript 비동기 처리 개념 정리 및 학습 회고",
      "date": "2025-05-04",
      "category": "daily",
      "tags": [
        "Git",
        "JavaScript",
        "Java",
        "연습",
        "학습"
      ],
      "image": "https://images.unsplash.com/photo-1488590528505-98d2b5aba04b?w=400&h=200&fit=crop",
      "description": "2025-05-04의 학습 내용 정리",
      "excerpt": "> 작성일: 2025-05-04  \r",
      "content": "# 📘 JavaScript 비동기 처리 개념 정리 및 학습 회고\r\n\r\n> 작성일: 2025-05-04  \r\n> 작성자: [GitHub: stylechoi](https://github.com/stylechoi)  \r\n> 학습 방식: 모던 JavaScript Deep Dive + 실습 기반 정리\r\n\r\n---\r\n\r\n## ✅ 학습 목표\r\n\r\n- 자바스크립트에서 **비동기 처리**의 필요성과 동작 원리를 이해한다.\r\n- `Promise`, `async/await`를 활용한 비동기 로직 작성을 연습한다.\r\n- 콜백 지옥을 해결하는 방법을 체득하고 실무 활용까지 대비한다.\r\n\r\n---\r\n\r\n## 📒 1. 비동기 처리란?\r\n\r\n- 자바스크립트는 **단일 스레드** 기반 언어라서, 블로킹 없이 **비동기 작업**이 필수.\r\n- 예: 서버에서 데이터 요청, 타이머, 사용자 입력 등  \r\n- 동기식: 순차 실행 / 비동기식: 특정 작업이 끝나기를 **기다리지 않고** 다음 작업 수행\r\n\r\n---\r\n\r\n## 📒 2. 콜백 함수의 한계 (콜백 지옥)\r\n\r\n```js\r\nsetTimeout(() => {\r\n  console.log(\"1초 후 실행\");\r\n  setTimeout(() => {\r\n    console.log(\"2초 후 실행\");\r\n    setTimeout(() => {\r\n      console.log(\"3초 후 실행\");\r\n    }, 1000);\r\n  }, 1000);\r\n}, 1000);\r\n\r\n중첩 구조로 인해 코드가 복잡하고 유지보수가 어려움\r\n\r\n이걸 해결하기 위해 Promise 도입\r\n\r\n## 📒 3. Promise 기본 문법\r\n\r\nconst fetchData = () => {\r\n  return new Promise((resolve, reject) => {\r\n    const success = true;\r\n    if (success) {\r\n      resolve(\"성공!\");\r\n    } else {\r\n      reject(\"실패!\");\r\n    }\r\n  });\r\n};\r\n\r\nfetchData()\r\n  .then(result => console.log(result))\r\n  .catch(err => console.error(err));\r\n\r\nresolve 호출 → 성공\r\nreject 호출 → 실패\r\nthen, catch로 결과 처리\r\n\r\n## 📒 4. async / await 문법\r\n\r\nconst fetchUser = () => {\r\n  return new Promise((resolve) => {\r\n    setTimeout(() => {\r\n      resolve(\"유저 데이터 가져옴\");\r\n    }, 1000);\r\n  });\r\n};\r\n\r\nconst showUser = async () => {\r\n  const result = await fetchUser();\r\n  console.log(result);\r\n};\r\n\r\nshowUser();   1초 후 '유저 데이터 가져옴' 출력\r\n\r\nasync 함수는 항상 Promise 반환\r\n\r\nawait는 Promise가 처리될 때까지 기다림 (비동기 작업을 동기처럼 작성 가능)\r\n\r\n## 📒 5. 에러 처리와 실전 팁\r\n\r\nconst getData = async () => {\r\n  try {\r\n    const result = await fetchUser();\r\n    console.log(result);\r\n  } catch (error) {\r\n    console.error(\"에러 발생:\", error);\r\n  }\r\n};\r\n\r\ntry/catch를 통해 async 내부 에러 핸들링 가능\r\n\r\n실제 API 호출에서 매우 중요함\r\n\r\n## 🧠 느낀 점 / 회고\r\n\r\nPromise 체인보다 async/await 문법이 훨씬 읽기 쉽고 구조도 깔끔했다.\r\n\r\n단순히 문법만 외우는 것이 아니라, 비동기 흐름 자체를 이해하는 게 중요하다는 걸 느낌.\r\n\r\n앞으로 fetch, axios, 서버 통신 구현 등에서 필수로 쓰이기 때문에 계속 반복 숙달할 예정."
    },
    {
      "id": "2025-05-03-auto-generated",
      "title": "📘 JavaScript 기초 정리 및 학습 회고",
      "date": "2025-05-03",
      "category": "daily",
      "tags": [
        "Git",
        "JavaScript",
        "CSS",
        "HTML",
        "Java",
        "학습"
      ],
      "image": "https://images.unsplash.com/photo-1504639725590-34d0984388bd?w=400&h=200&fit=crop",
      "description": "2025-05-03의 학습 내용 정리",
      "excerpt": "> 작성일: 2025-05-03  \r",
      "content": "\r\n# 📘 JavaScript 기초 정리 및 학습 회고\r\n\r\n> 작성일: 2025-05-03  \r\n> 작성자: [GitHub: stylechoi](https://github.com/stylechoi)  \r\n> 학습 방식: 모던 JavaScript Deep Dive + 실습 기반 정리\r\n\r\n---\r\n\r\n## ✅ 학습 목표\r\n\r\n- 자바스크립트의 기본 문법 및 개념을 완전 정복한다.\r\n- HTML, CSS와의 연계를 염두에 두고 실전에서 바로 쓸 수 있는 자바스크립트를 익힌다.\r\n- DOM 조작, 이벤트, 함수, 객체 등 실무에서 자주 쓰는 것 위주로 학습한다.\r\n\r\n---\r\n\r\n## 📒 1. 변수 선언과 자료형\r\n\r\n```js\r\nvar x = 10;       // 재선언/재할당 가능 (지양)\r\nlet y = 20;       // 재할당 가능, 재선언 불가\r\nconst z = 30;     // 재할당 불가, 상수\r\n```\r\n\r\n- **자료형**: number, string, boolean, null, undefined, object, symbol  \r\n- **typeof 연산자**로 타입 확인 가능\r\n\r\n---\r\n\r\n## 📒 2. 함수 선언\r\n\r\n```js\r\n// 함수 선언식\r\nfunction sayHello(name) {\r\n  return `Hello, ${name}`;\r\n}\r\n\r\n// 함수 표현식\r\nconst sayBye = function(name) {\r\n  return `Bye, ${name}`;\r\n};\r\n\r\n// 화살표 함수 (Arrow Function)\r\nconst greet = (name) => `Hi, ${name}`;\r\n```\r\n\r\n---\r\n\r\n## 📒 3. 조건문과 반복문\r\n\r\n```js\r\nif (x > 10) {\r\n  console.log(\"크다\");\r\n} else {\r\n  console.log(\"작다\");\r\n}\r\n\r\nfor (let i = 0; i < 5; i++) {\r\n  console.log(i);\r\n}\r\n\r\nwhile (x > 0) {\r\n  x--;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 📒 4. 배열과 객체\r\n\r\n```js\r\nconst arr = [1, 2, 3];\r\narr.push(4);         // 배열에 값 추가\r\n\r\nconst user = {\r\n  name: \"철수\",\r\n  age: 25\r\n};\r\nconsole.log(user.name);    // 점 표기법\r\nconsole.log(user[\"age\"]);  // 대괄호 표기법\r\n```\r\n\r\n---\r\n\r\n## 📒 5. DOM 조작 (기초)\r\n\r\n```js\r\nconst title = document.getElementById(\"title\");\r\ntitle.innerText = \"바뀐 제목\";\r\n\r\nconst btn = document.querySelector(\".btn\");\r\nbtn.addEventListener(\"click\", () => {\r\n  alert(\"버튼 클릭됨!\");\r\n});\r\n```\r\n\r\n---\r\n\r\n## 📒 6. 기타 중요 개념 요약\r\n\r\n| 개념 | 설명 |\r\n|------|------|\r\n| hoisting | 변수/함수 선언이 위로 끌어올려지는 현상 |\r\n| scope | 변수의 유효 범위 (global vs local) |\r\n| closure | 외부 함수의 변수를 참조하는 내부 함수 |\r\n| this | 실행 컨텍스트에 따라 달라지는 참조값 |\r\n| 이벤트 버블링 | 하위 → 상위로 이벤트 전달됨 |\r\n| JSON | 데이터를 문자열로 직렬화해서 저장/전송할 때 사용 |\r\n\r\n---\r\n\r\n## 🧠 느낀 점 / 회고\r\n\r\n- 함수형 문법, 화살표 함수 문법에 익숙해질수록 코드가 간결해진다.\r\n- DOM 조작은 HTML/CSS 구조를 정확히 이해해야 효과적으로 다룰 수 있다.\r\n- ‘this’는 상황에 따라 달라지므로 화살표 함수와 일반 함수의 차이를 정확히 알고 있어야 함.\r\n- 앞으로는 **비동기 처리 (Promise, async/await)**, **ES6+ 문법**, **모듈화** 쪽도 정리할 예정.\r\n\r\n---\r\n\r\n## 🗂️ 참고 자료\r\n\r\n- [모던 JavaScript Deep Dive](https://github.com/namjunemy/TIL/blob/main/javascript/Modern%20JavaScript%20Deep%20Dive.md)\r\n- [MDN JavaScript](https://developer.mozilla.org/ko/docs/Web/JavaScript)\r\n- [코드잇 JavaScript 강의](https://www.codeit.kr)\r\n"
    },
    {
      "id": "2025-05-02-auto-generated",
      "title": "🧠 2025-05-02 학습 회고 — HTML 기초 복습",
      "date": "2025-05-02",
      "category": "daily",
      "tags": [
        "Git",
        "CSS",
        "HTML",
        "연습",
        "학습"
      ],
      "image": "https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=400&h=200&fit=crop",
      "description": "2025-05-02의 학습 내용 정리",
      "excerpt": "> 학습 주제: HTML 기본 구조 및 시맨틱 태그 복습  \r",
      "content": "# 🧠 2025-05-02 학습 회고 — HTML 기초 복습\r\n\r\n> 학습 주제: HTML 기본 구조 및 시맨틱 태그 복습  \r\n> 학습 시간: 약 2시간  \r\n> 작성자: [GitHub: stylechoi](https://github.com/stylechoi)\r\n\r\n---\r\n\r\n## ✅ 오늘의 학습 목표\r\n\r\n- HTML의 기본 구조를 정확히 이해하고, 손코딩으로 작성할 수 있다.\r\n- 시맨틱 태그의 역할과 사용하는 이유를 실제 예시와 함께 익힌다.\r\n- `<form>`, `<input>`, `<button>` 등 폼 관련 태그를 다시 한번 연습한다.\r\n\r\n---\r\n\r\n## 📝 복습한 주요 내용\r\n\r\n### 1. HTML 기본 구조\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"ko\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>HTML 복습</title>\r\n  </head>\r\n  <body>\r\n    <h1>HTML 구조 복습</h1>\r\n    <p>HTML은 Head와 Body로 나뉘며, 이 안에 다양한 시맨틱 태그가 들어간다.</p>\r\n  </body>\r\n</html>\r\n```\r\n\r\n---\r\n\r\n### 2. 시맨틱 태그 활용\r\n\r\n- `<header>`: 페이지 상단 구성 요소 (로고, 내비게이션 등)\r\n- `<main>`: 핵심 콘텐츠\r\n- `<section>`: 문서의 구획\r\n- `<article>`: 독립적인 내용\r\n- `<footer>`: 저작권, 연락처 등 하단 정보\r\n\r\n---\r\n\r\n### 3. 폼 요소 연습\r\n\r\n```html\r\n<form>\r\n  <label for=\"email\">이메일:</label>\r\n  <input type=\"email\" id=\"email\" name=\"email\" required />\r\n  <br />\r\n  <label for=\"password\">비밀번호:</label>\r\n  <input type=\"password\" id=\"password\" name=\"password\" />\r\n  <br />\r\n  <button type=\"submit\">제출</button>\r\n</form>\r\n```\r\n\r\n---\r\n\r\n## 🧩 실습 포인트\r\n\r\n- `label`과 `input`의 연결을 `for`와 `id`로 정확히 해주는 습관\r\n- `<input type=\"email\">` 등 HTML5 기능 활용\r\n- 시맨틱 태그를 사용해서 구조적으로 의미 있는 코드 작성\r\n\r\n---\r\n\r\n## 💡 느낀 점\r\n\r\n- 오랜만에 HTML을 직접 작성해보니 자동완성 없이도 구조를 손으로 그릴 수 있게 된 게 성취감 있었다.\r\n- 시맨틱 태그를 사용하는 이유를 다시금 체감했고, SEO나 접근성 측면에서도 중요하다는 걸 느꼈다.\r\n- 단순히 눈에 보이는 화면이 아니라 **의미를 부여한 구조 설계**가 중요하다는 마인드를 다시 다짐했다.\r\n\r\n---\r\n\r\n## 🛠️ 내일 목표\r\n\r\n- CSS 레이아웃 복습 시작: `display`, `position`, `flex`, `grid`의 개념과 차이부터 정리할 예정\r\n"
    },
    {
      "id": "2025-04-29-auto-generated",
      "title": "예비창업패키지(예창패) 준비 정리",
      "date": "2025-04-29",
      "category": "daily",
      "tags": [
        "Git",
        "JavaScript",
        "React",
        "CSS",
        "HTML",
        "Node.js",
        "Java",
        "학습",
        "프로젝트",
        "개발"
      ],
      "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=400&h=200&fit=crop",
      "description": "2025-04-29의 학습 내용 정리",
      "excerpt": "- **지원 대상**: 예비 창업자 (사업자 등록 전 또는 3년 이내 폐업자 가능)\r",
      "content": "# 예비창업패키지(예창패) 준비 정리\r\n\r\n## ✅ 1. 예창패 기본 개요\r\n- **지원 대상**: 예비 창업자 (사업자 등록 전 또는 3년 이내 폐업자 가능)\r\n- **지원 금액**: 최대 **5,000만 원 (정부지원금 100%)**\r\n- **자부담금**: 없음\r\n- **지원 기간**: 약 6개월\r\n- **조건**: 사업자 등록 必 (선정 후 2개월 이내 등록)\r\n\r\n---\r\n\r\n## ✅ 2. 지원 시 주의사항 및 팁\r\n- 대표가 고졸이라도 상관 없음 → 핵심은 문제 인식 + MVP + BM 명확성\r\n- 개발 경험 부족 시 외주/자문 활용 OK\r\n- 공무원/의사 등은 자문료 집행 불가 (사례금도 ×)\r\n- **자문료는 외주계약 형태로만 가능 (사적 금전 제공 ×)**\r\n\r\n---\r\n\r\n## ✅ 3. 자문 관련 이슈\r\n| 항목 | 내용 |\r\n|------|------|\r\n| 공무원 자문 | 공무원 신분이면 사례비 절대 불가 (위법) |\r\n| 영상 출연 | 자문 수준으로 출연은 가능하나, 실무 참여처럼 보이면 위험 |\r\n| 교수·의사 외주 | **교수나 일반 개원의와 외주계약**은 가능함 |\r\n\r\n---\r\n\r\n## ✅ 4. 예창패 지원금 사용 범위\r\n| 항목 | 가능 여부 | 비고 |\r\n|--------|------------|------|\r\n| 맥북 등 장비 구입 | ✅ | 1년간 자산 귀속, 이후 개인 소유 가능 |\r\n| 외주 개발/디자인비 | ✅ | 계약서 + 세금계산서 필요 |\r\n| 대표 월급 | ⚠️ | 최대 50만원까지 사례비 가능 |\r\n| 가족 인건비 | ✅ | 참여 실무자일 경우 정당한 인건비 집행 가능 |\r\n| 굿즈/포스터 제작 | ✅ | 홍보비로 인정 |\r\n| 도메인/서버비 | ✅ | 사업 운영비로 인정 |\r\n\r\n---\r\n\r\n## ✅ 5. 피해야 할 실수\r\n- 의료 분야 전문 자문 없이 제출 → 기각 확률 높음\r\n- MVP 없이 아이디어만 제출 → 탈락\r\n- 모든 업무를 대표 혼자 하겠다고 작성 → 팀워크 부족으로 감점\r\n\r\n---\r\n\r\n## ✅ 6. 예창패 vs 기타 창업 지원사업\r\n| 프로그램명 | 차이점 |\r\n|------------|--------|\r\n| 청년창업사관학교(청창사) | 실내 사무공간 + 멘토링 / 자부담 30% 있음 |\r\n| 소셜벤처 육성사업 | 사회적가치 중심 / 공익성 강조 |\r\n| 비대면 바우처 | 서비스 납품/구매 위주 / 법인 필수 |\r\n| 창업맞춤형 사업화지원 | 기존 사업자 대상 (3년 이내) |\r\n\r\n---\r\n\r\n## ✅ 7. 꿀팁 요약\r\n- 맥북 1대 + 실무자 1인 기자재 OK\r\n- 가족을 실무자 등재 가능 (단, 서류/계약 명확히)\r\n- 외주계약은 반드시 **공식 세금계산서 + 계약서** 필요\r\n- 자문은 공무원 제외한 교수/전문의 대상으로 진행\r\n\r\n---\r\n\r\n## ✅ 8. 현재 계획 및 학습 병행\r\n### 💻 부트캠프를 통한 공부\r\n- 6개월 풀타임 과정 참여 중 (프론트엔드 중심)\r\n- HTML/CSS → JavaScript → React 순으로 집중 학습 중\r\n- 매일 TIL (Today I Learned) 작성 및 GitHub 1일 1커밋 실천\r\n\r\n### 📚 학습 심화 계획\r\n- 학습 내용 정리 후 기술 블로그 업로드 (Astro 기반)\r\n- 부트캠프 외 개인 프로젝트 2~3개 이상 제작 예정\r\n- 예창패용 MVP는 실제 운영 가능한 수준으로 개발\r\n- Firebase → Node.js + Express → SQL 또는 Supabase 로 백엔드까지 익힐 계획\r\n- Figma 활용한 UX/UI 프로토타입 고도화\r\n\r\n---\r\n\r\n## ✅ 향후 일정 요약\r\n```markdown\r\n[5~6월]  \r\n- 부트캠프 실습 + 포트폴리오용 웹 개발  \r\n- 예창패용 사업 아이템 고도화, 기획서 초안 작성  \r\n\r\n[7~8월]  \r\n- MVP 개발 완료 목표 + 외주/자문 구성 준비  \r\n- 사업계획서, 영상, 피그마 프로토타입 제작  \r\n\r\n[9~10월]  \r\n- 예창패 최종 제출 및 면접 준비  \r\n- 기술 블로그/포트폴리오/정리 자료 최종 제출\r\n```\r\n\r\n---\r\n✅ 사업내용에 대해서는 삭제처리함\r\n\r\n직접알아보고 조사한 내용들, 유출될 염려가있는 내부정보는 전부 삭제처리함!\r\n\r\n\r\n✅ 소감\r\n\r\n오늘은 부트캠프를 듣고 남는 시간에는, 대부분 창업관련된 부분을 찾아봤다.\r\n또한, 수업을 듣긴 들었지만 창업관련 준비 때문에 붕뜬 시간이 많았다.\r\n확실한 목표를 잡아가니, 이제 공부에만 집중하면 될 것같다."
    },
    {
      "id": "2025-04-28-auto-generated",
      "title": "📐 Figma 실제 사용법 총정리",
      "date": "2025-04-28",
      "category": "daily",
      "tags": [
        "CSS",
        "HTML",
        "연습",
        "프로젝트",
        "개발"
      ],
      "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=400&h=200&fit=crop",
      "description": "2025-04-28의 학습 내용 정리",
      "excerpt": "Figma는 \"가입하고 열어보면 알겠지\" 수준이 아니라,  \r",
      "content": "# 📐 Figma 실제 사용법 총정리\r\n\r\n## 🚀 시작하기 전에\r\n\r\nFigma는 \"가입하고 열어보면 알겠지\" 수준이 아니라,  \r\n**어떻게 써야지 '진짜' 좋은 디자인이 나오는지** 흐름을 이해하고 시작해야 됩니다.\r\n\r\n---\r\n\r\n## 1. 프로젝트 세팅 방법\r\n\r\n1. **Figma 웹사이트**에서 `New Design File` 생성\r\n2. 왼쪽 상단 `Frame Tool (F)` → iPhone 15 Pro / Desktop 1440px 등 **기기 사이즈** 골라서 작업 시작\r\n3. 프레임은 **기기 화면**처럼 생각하고, 이 안에 레이아웃을 짭니다.\r\n\r\n🔵 **팁:**  \r\n처음엔 그냥 Desktop 1440px 짜리부터 연습하는 게 편함.\r\n\r\n---\r\n\r\n## 2. 실전 디자인 플로우\r\n\r\n### 2-1. 무료 이미지/아이콘 불러오기\r\n\r\n- **Unsplash 플러그인**: 고화질 무료 사진\r\n  - 설치: `Plugins → Unsplash 검색 → Install`\r\n  - 사용: 플러그인 열고 키워드 검색 (`city`, `people`, `coffee` 등)\r\n\r\n- **Iconify 플러그인**: 무료 아이콘 (Material Icons, Fluent 등)\r\n  - 설치: `Plugins → Iconify 설치`\r\n  - 사용: 키워드 검색 후 바로 드래그해서 삽입\r\n\r\n- **Remove.bg 플러그인**: 배경 삭제용 (인물, 제품컷 처리)\r\n  - 인물 사진을 배경 투명하게 만들고 싶을 때 유용\r\n\r\n> 🔥 **요약:** 플러그인 설치 → 키워드 검색 → 끌어다 쓰면 끝.\r\n\r\n---\r\n\r\n### 2-2. 컴포넌트 제대로 쓰기\r\n\r\n**컴포넌트(Component)** = 재사용할 수 있는 기본 단위입니다.\r\n\r\n- 버튼, 카드, 네비게이션바 같은 건 무조건 **컴포넌트화** 해야 함.\r\n- `Ctrl+Alt+K` 로 바로 컴포넌트 만들기.\r\n- 복제할 땐 `Instance`로 복사 → 원본 컴포넌트 수정하면 복사본도 자동 업데이트!\r\n\r\n📦 **팁:**  \r\n컴포넌트는 따로 관리할 `Components 페이지`를 하나 만들어두면 나중에 지옥 안 봄.\r\n\r\n---\r\n\r\n### 2-3. 프로토타입 연결\r\n\r\n- 상단 `Prototype` 탭 클릭\r\n- 버튼 → 이동할 화면으로 드래그해서 연결\r\n- 트랜지션 설정: `Instant`, `Smart Animate`, `Slide In` 등 선택 가능\r\n\r\n🌟 **실제 앱처럼 보이게 하고 싶으면**  \r\n`Smart Animate`를 적극적으로 써야 진짜 프로토타입 느낌이 남.\r\n\r\n---\r\n\r\n## 3. 협업 & 공유\r\n\r\n- **공유 (Share) 버튼** 누르고, 링크 생성해서 팀원 초대\r\n- 편집 권한 / 코멘트 전용 권한 선택 가능\r\n- 코멘트 모드로 화면에 직접 메모 남길 수 있음\r\n\r\n📢 **개발자 넘길 때 중요한 팁:**\r\n\r\n- **Inspect 모드** (View → Inspect) 열고\r\n- 개발자는 `CSS`, `iOS`, `Android` 코드 스니펫까지 바로 복붙할 수 있음\r\n- 개발 넘길 땐, 컴포넌트 이름, 프레임 이름, 계층구조까지 깔끔하게 정리해야 됨\r\n\r\n---\r\n\r\n## 4. 실제로 자주 쓰는 플러그인 추천\r\n\r\n| 플러그인 이름       | 기능 설명 |\r\n|-------------------|----------|\r\n| Unsplash          | 고퀄 무료 사진 삽입 |\r\n| Iconify           | 전 세계 아이콘 모음 |\r\n| Remove.bg         | 배경 제거 툴 |\r\n| Wireframe         | 와이어프레임 빠르게 만들기 |\r\n| Content Reel      | 가짜 이름, 이메일, 텍스트 랜덤 삽입 |\r\n| Lorem Ipsum       | 가짜 본문 텍스트 삽입 |\r\n\r\n> ✅ 플러그인 3개만 설치해도 초반 생산성 10배 올라감.\r\n\r\n---\r\n\r\n## 5. 팁 모음 (진짜 중요)\r\n\r\n- 디자인은 무조건 **Grid** (격자) 설정하고 시작해라. (`Shift+G`)\r\n- 색상은 **Style**로 등록해서 관리해야 일관성 유지 가능\r\n- 텍스트 스타일도 등록하고 쓴다. (`Body 16px`, `Headline 32px` 이런 식)\r\n- 레이어 이름 정리 습관 들여라. (Frame1, Frame2 이런 거 절대 금지)\r\n- 모바일 앱 디자인할 땐 실제 디바이스에서 미리보기 꼭 해봐라. (Figma Mirror 앱 설치)\r\n\r\n---\r\n\r\n# 🎯 결론\r\n\r\n> **Figma는 \"그림 그리는 툴\"이 아니라 \"구조를 설계하는 툴\"이다.**\r\n\r\n- 구도 먼저 잡고\r\n- 그다음 컴포넌트화하고\r\n- 마지막에 예쁘게 다듬는다\r\n\r\n# 후기\r\n\r\n부트캠프에서 피그마 무료가입(피교육자용) 으로 무료로 쓸수 있다고 해서\r\n쓰는김에 기본에 대해서 공부 해봄.\r\n\r\n사실 지금 html > css > 자바스크립트로 넘어가는 중요한 단계이기 떄문에\r\n피그마는 조금 나중에 건드려도 될것 같음.\r\n\r\n우선은 빠르게 기초개념을 잡고 무엇이든 시작하는게 맞다고 생각함!!\r\n\r\n---\r\n"
    },
    {
      "id": "2025-04-27-auto-generated",
      "title": "2025-04-27 학습 일지",
      "date": "2025-04-27",
      "category": "daily",
      "tags": [
        "Git",
        "CSS",
        "HTML",
        "학습",
        "프로젝트"
      ],
      "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=400&h=200&fit=crop",
      "description": "2025-04-27의 학습 내용 정리",
      "excerpt": "- 직접 **HTML + CSS + SVG** 조합으로 \"HELLO, MY NAME IS CHOI!\" 문구를 순차적으로 글자가 나타나는 애니메이션 형태로 제작\r",
      "content": "## 📋 2025-04-27 Technical Retrospective\r\n\r\n---\r\n\r\n## 🌟 Today’s Main Work Summary\r\n\r\n### 1. SVG 타이포 애니메이션 제작\r\n- 직접 **HTML + CSS + SVG** 조합으로 \"HELLO, MY NAME IS CHOI!\" 문구를 순차적으로 글자가 나타나는 애니메이션 형태로 제작\r\n- **주요 포인트**:\r\n  - 글자 하나하나에 `stroke-dasharray` + `stroke-dashoffset` 적용하여 선으로 그려지는 느낌 구현\r\n  - `animation-delay`를 줘서 한 글자씩 0.2초 간격으로 순차 등장\r\n  - 고급스럽고 담백한 스타일의 텍스트 연출\r\n\r\n### 2. SVG 애니메이션을 GIF로 변환\r\n- 완성된 SVG 애니메이션을 브라우저에서 재생 후 **ScreenToGif** 툴로 고해상도 캡쳐\r\n- 결과물을 부드럽게 편집하여 최종 GIF로 변환\r\n- **결과**:\r\n  - 자연스럽게 등장하는 느낌을 그대로 GIF에 반영\r\n  - GIF 파일 최적화(용량 압축 및 끊김 없는 흐름 처리)\r\n\r\n### 3. GitHub 프로필 배너 적용\r\n- 프로필 상단에 완성된 GIF를 업로드\r\n- 기존 Apple 그림은 제외하고, 깔끔하게 \"HELLO, MY NAME IS CHOI!\" 애니메이션만 메인 포커스로 강조\r\n\r\n### 최종 목표\r\n- 깔끔함\r\n- 전문성\r\n- 담백하지만 강한 인상\r\n\r\n---\r\n\r\n## 💡 Key Learnings\r\n\r\n- **SVG 애니메이션 + Screen Recording + GIF 변환 과정**을 한 사이클 직접 경험\r\n- 단순한 이미지가 아니라, **텍스트 타이포그래피를 활용한 개인 브랜딩**이 훨씬 임팩트 있다는 것 체감\r\n- GitHub Profile에서 **첫인상(배너)이 갖는 심리적 효과**를 명확히 이해함\r\n\r\n---\r\n\r\n## 📈 Tomorrow's Plan\r\n\r\n- GitHub README 최종 **About Me** 섹션 작성\r\n- 1개 포트폴리오 프로젝트 추가 기획\r\n- GitHub TIL 레포지토리 **깔끔하게 카테고리 정리** 시작\r\n\r\n---\r\n\r\n## ✍️ Quote of the Day\r\n\r\n- 애니메이션을 만드는게 크게 어렵지 않다는 걸 느낌 \r\n- 다만 아무것도 모르는상태로 배우려니깐 시간소요가 많이 되었음 (개선 해야될듯)\r\n- 내일 부터 부트캠프에서 빡세게 공부해야 될듯\r\n"
    },
    {
      "id": "2025-04-25-auto-generated",
      "title": "🧠 GitHub 그룹 프로젝트 완벽 가이드",
      "date": "2025-04-25",
      "category": "daily",
      "tags": [
        "프로젝트",
        "브랜치",
        "프로젝트",
        "개인",
        "코드",
        "충돌conflict",
        "최종",
        "실전",
        "vs",
        "초보자"
      ],
      "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=400&h=200&fit=crop",
      "description": "2025-04-25의 학습 내용 정리",
      "excerpt": "이 문서는 GitHub를 활용한 그룹 프로젝트의 실전 운영 전략을 담고 있습니다. 브랜치 전략, 충돌(Conflict) 해결, 코드 리뷰, 배포 등 실무에서 바로 써먹을 수 있도록...",
      "content": "\r\n# 🧠 GitHub 그룹 프로젝트 완벽 가이드\r\n\r\n이 문서는 GitHub를 활용한 그룹 프로젝트의 실전 운영 전략을 담고 있습니다. 브랜치 전략, 충돌(Conflict) 해결, 코드 리뷰, 배포 등 실무에서 바로 써먹을 수 있도록 정리했습니다.\r\n\r\n---\r\n\r\n## 📌 목차\r\n\r\n1. [프로젝트 초기 세팅](#프로젝트-초기-세팅)\r\n2. [브랜치 전략](#브랜치-전략)\r\n3. [프로젝트 보드 관리](#프로젝트-보드-관리)\r\n4. [개인 작업 브랜치와 Pull Request](#개인-작업-브랜치와-pull-request)\r\n5. [코드 리뷰와 Approve](#코드-리뷰와-approve)\r\n6. [충돌(Conflict) 해결](#충돌conflict-해결)\r\n7. [최종 배포(Master Merge)](#최종-배포master-merge)\r\n8. [실전 팁](#실전-팁)\r\n9. [VS Code 연동 및 실전 워크플로우](#vs-code-연동-및-실전-워크플로우)\r\n10. [초보자 FAQ](#초보자-faq)\r\n\r\n---\r\n\r\n## 🛠️ 프로젝트 초기 세팅\r\n\r\n- GitHub에서 Repository 생성 및 팀원 초대\r\n- 초기 커밋 후 `master` 브랜치에 업로드\r\n- `develop` 브랜치를 `master`에서 파생\r\n\r\n```bash\r\ngit checkout -b develop\r\ngit push --set-upstream origin develop\r\n````\r\n\r\n---\r\n\r\n## 🌿 브랜치 전략\r\n\r\n| 브랜치 이름 | 용도 |\r\n|-------------|------|\r\n| `master`    | 유저에게 배포할 최종 제품 코드 |\r\n| `develop`   | 여러 개발자들의 작업물을 병합할 통합 브랜치 |\r\n| `feature/*` | 개인 작업 브랜치 (`feature/login` 등) |\r\n| `hotfix/*`  | 긴급 패치용 브랜치 |\r\n| `release/*` | 릴리즈 준비 브랜치 |\r\n\r\n✅ `master` 브랜치는 **Protected Branch**로 설정:\r\n- 강제 푸시 금지\r\n- Pull Request 없이 병합 금지\r\n- 리뷰 최소 1인 이상 요구 권장\r\n\r\n---\r\n\r\n## ✅ 프로젝트 보드 관리\r\n\r\n- GitHub Projects → Kanban Board 생성\r\n- Todo / In Progress / Done 단계 구성\r\n- 카드 → Issue 연결 → 브랜치 생성 가능\r\n\r\n```text\r\n📌 예시:\r\n[Todo] 로그인 페이지 → [feature/login]\r\n[In Progress] 유저 프로필 → [feature/profile]\r\n[Done] 회원가입 기능 → develop 병합 완료\r\n```\r\n\r\n---\r\n\r\n## 🌱 개인 작업 브랜치와 Pull Request\r\n\r\n1. `develop` 브랜치 최신화\r\n2. `feature/작업명` 브랜치 생성\r\n3. 커밋 및 푸시\r\n4. GitHub에서 Pull Request 작성\r\n\r\n```bash\r\ngit checkout develop\r\ngit pull origin develop\r\ngit checkout -b feature/my-task\r\n# 작업 후\r\ngit add .\r\ngit commit -m \"feat: 작업 설명\"\r\ngit push origin feature/my-task\r\n```\r\n\r\n- PR은 항상 `develop` 브랜치 대상으로 생성\r\n- PR 템플릿 사용 권장\r\n\r\n---\r\n\r\n## 🔍 코드 리뷰와 Approve\r\n\r\n- 팀원들은 PR을 확인하고 다음 중 하나를 선택:\r\n  - `Approve` (병합 승인)\r\n  - `Request changes` (수정 요청)\r\n\r\n리뷰는 다음과 같은 기준으로:\r\n- 코드 스타일\r\n- 로직의 명확성\r\n- 불필요한 코드 여부\r\n- 에러 핸들링\r\n\r\n---\r\n\r\n## ⚠️ 충돌(Conflict) 해결\r\n\r\n### 1. 최신 develop 코드 가져오기\r\n```bash\r\ngit checkout develop\r\ngit pull origin develop\r\n```\r\n\r\n### 2. 작업 브랜치로 이동\r\n```bash\r\ngit checkout feature/a\r\n```\r\n\r\n### 3. merge (로컬에서 먼저 충돌 확인)\r\n```bash\r\ngit merge develop\r\n```\r\n\r\n### 4. 충돌 해결 후\r\n```bash\r\n# <<<<<<< ======= >>>>>>> 구간 수정\r\ngit add .\r\ngit commit -m \"fix: 충돌 해결\"\r\ngit push\r\n```\r\n\r\n---\r\n\r\n## 🚀 최종 배포(Master Merge)\r\n\r\n- develop이 안정화되고 배포 준비가 완료되면 `master`로 PR\r\n- 리뷰자 2인 이상 승인 필수\r\n\r\n```bash\r\n# 브랜치에서\r\ngit checkout develop\r\ngit pull\r\n# PR 생성 → base: master ← compare: develop\r\n```\r\n\r\n---\r\n\r\n## 💡 실전 팁\r\n\r\n- 항상 `git pull origin develop` 후 작업\r\n- 자주 push 하지 말고, 작은 단위로 커밋\r\n- 브랜치명은 명확하게 (예: `feature/login-form`)\r\n- 팀원과 사전 브랜치/업무 분배 회의 필수\r\n- PR 템플릿, Issue 템플릿 설정 시 자동화 가능\r\n- VS Code와 GitHub 계정 연동 추천\r\n\r\n---\r\n\r\n## 💻 VS Code 연동 및 실전 워크플로우\r\n\r\n- GitHub 계정 연동: `Settings → Accounts → GitHub 로그인`\r\n- Source Control 탭으로 변경 파일, 스테이징, 커밋 모두 가능\r\n- `.env`, `node_modules`, `*.log` 등은 `.gitignore`에 추가\r\n- `Remote Repositories` 확장 플러그인 사용 시 로컬 클론 없이 작업 가능\r\n\r\n---\r\n\r\n## ❓ 초보자 FAQ\r\n\r\n- **Q. 커밋 메시지 어떻게 써야 해요?**  \r\n  → `\"feat: 로그인 기능 추가\"` 형식 (타입: 설명)\r\n\r\n- **Q. 커밋 후 실수했어요!**  \r\n  → `git reset --soft HEAD~1` 후 다시 커밋\r\n\r\n- **Q. 충돌 계속 나요!**  \r\n  → 항상 `develop`에서 새 브랜치 만들고 최신화할 것\r\n\r\n- **Q. 누가 작업 중인지 모르겠어요!**  \r\n  → Project Board에서 할당된 담당자 확인 가능\r\n\r\n---\r\n\r\n🎉 **이 가이드 하나로 팀 프로젝트, 실무처럼 운영 가능!**\r\n\r\n# 주관적 해석과 요약\r\n\r\n깃허브에서 팀프로젝트를 하려면\r\n팀리드가 레포를 생성하고, main 과 develop할 브랜치를 하나 더 추가 생성해야된다.\r\ndevelop > main 으로 가야 main이 터지는 상황을 대비 할 수 있다.\r\n근데 devlop 단계 이전에서 우리는 \"우리가 개발할 내용\" > deveop > main, 즉 디벨로 하위에서 작업을하다가\r\n디벨로에서 팀원들과 의견을 취합해서 main 으로 최종으로 올려야 하는 것이다.\r\n실제로 팀프로젝트를 겪어 봐야 하겠지만 메인과 브랜치 그리고 하위에서 작업하다 main 으로 올린다는 본질을 생각 하면 될 것 같다. 각자 작업하다 합칠 때 컨플이 많이생기는데, 이런건 겪어보면 큰 문제가 아닐 거라 생각하다.\r\n\r\n# 추가적으로 공부 해야할 것\r\n\r\ngit과 github 를 사용하고 명렁어 사용이 어느정도 익숙 해졌다.\r\n커밋과 푸쉬를 하고, 이것저것 정리를 하는 과정이 크게 어렵지 않다는 생각이 들었다\r\n하지만 부족한건, 조금 더 실무에서 필요한 디테일 한 것들이 비어있다는 것.\r\n\r\n1. 깃 관련 명령어 모두 숙지하기 (특히 실무관련 명령어는 무조건적 원리이해 > 암기)\r\n2. html,css 를 이틀동안 공부하고 클론코딩도 해봤지만, 나름 프론트에 근간이 되는만큼 주말전까지 복습 철저히\r\n3. 자바스크립트를 다음주에 넘어가기전에 html,css 챗지피티와 테스트 보면서 레벨업 하기.\r\n\r\n\r\n\r\n"
    },
    {
      "id": "2025-04-24-auto-generated",
      "title": "CSS 완전정복 기술 회고",
      "date": "2025-04-24",
      "category": "daily",
      "tags": [
        "main",
        "main",
        "333",
        "f5f5f5",
        "3498db"
      ],
      "image": "https://images.unsplash.com/photo-1542831371-29b0f74f9713?w=400&h=200&fit=crop",
      "description": "2025-04-24의 학습 내용 정리",
      "excerpt": "HTML 요소의 \"스타일\"을 정의하는 언어로, 구조는 HTML, 동작은 JS, 디자인은 CSS가 맡는다. 아래 예시는 h1에 CSS를 적용한 기본 예시다.\r",
      "content": "# CSS 완전정복 기술 회고\r\n\r\n## CSS란 무엇인가\r\n\r\nHTML 요소의 \"스타일\"을 정의하는 언어로, 구조는 HTML, 동작은 JS, 디자인은 CSS가 맡는다. 아래 예시는 h1에 CSS를 적용한 기본 예시다.\r\n\r\n```html\r\n<h1>안녕</h1>\r\n```\r\n\r\n```css\r\nh1 {\r\n  color: red;\r\n  font-size: 32px;\r\n}\r\n```\r\n\r\n---\r\n\r\n## CSS 문법 구조\r\n\r\n```css\r\n선택자 {\r\n  속성: 값;\r\n}\r\n```\r\n\r\n```css\r\np {\r\n  color: blue;\r\n  font-size: 20px;\r\n}\r\n```\r\n\r\n- 선택자: p 태그\r\n- 속성: color, font-size\r\n- 값: blue, 20px\r\n\r\n---\r\n\r\n## CSS 적용 방식 3가지\r\n\r\n### 1. 인라인 스타일 (실무에서 거의 사용 ❌)\r\n\r\n```html\r\n<p style=\"color: red;\">텍스트</p>\r\n```\r\n\r\n### 2. 내부 스타일\r\n\r\n```html\r\n<head>\r\n  <style>\r\n    p { color: blue; }\r\n  </style>\r\n</head>\r\n```\r\n\r\n### 3. 외부 스타일 (실무 필수 ✅)\r\n\r\n```html\r\n<head>\r\n  <link rel=\"stylesheet\" href=\"style.css\">\r\n</head>\r\n```\r\n\r\n```css\r\n/* style.css */\r\np {\r\n  color: green;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 선택자 종류\r\n\r\n```html\r\n<p class=\"text\">문단</p>\r\n<div id=\"main\">박스</div>\r\n```\r\n\r\n```css\r\n.text { color: blue; }\r\n#main { background: yellow; }\r\n```\r\n\r\n| 종류      | 예시    | 설명             |\r\n| ------- | ----- | -------------- |\r\n| 전체 선택자  | \\*    | 모든 요소에 적용      |\r\n| 태그 선택자  | p, h1 | 특정 태그에 적용      |\r\n| 클래스 선택자 | .box  | class=\"box\" 대상 |\r\n| 아이디 선택자 | #main | id=\"main\" 대상   |\r\n\r\n---\r\n\r\n## 결합 선택자\r\n\r\n| 종류     | 예시             | 설명                 |\r\n| ------ | -------------- | ------------------ |\r\n| 자손 선택자 | .container p   | container 하위의 모든 p |\r\n| 자식 선택자 | .container > p | container의 직계 p만   |\r\n| 형제 선택자 | h1 + p         | h1 바로 다음 p         |\r\n| 일반 형제  | h1 \\~ p        | h1 이후 모든 p         |\r\n\r\n---\r\n\r\n## 상태(가상) 선택자\r\n\r\n| 선택자      | 예시             | 설명        |\r\n| -------- | -------------- | --------- |\r\n| :hover   | a\\:hover       | 마우스 오버 시  |\r\n| :focus   | input\\:focus   | 포커스 되었을 때 |\r\n| :active  | button\\:active | 클릭 중일 때   |\r\n| :checked | input\\:checked | 체크된 경우    |\r\n\r\n---\r\n\r\n## 속성 선택자\r\n\r\n| 예시              | 설명               |\r\n| --------------- | ---------------- |\r\n| [type=\"text\"]   | 해당 속성 가진 태그      |\r\n| [href^=\"https\"] | https로 시작하는 href |\r\n| [src\\$=\".png\"]  | .png로 끝나는 이미지    |\r\n\r\n---\r\n\r\n## 그룹 선택자\r\n\r\n```css\r\nh1, h2, h3 {\r\n  color: darkblue;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 박스 모델\r\n\r\nHTML 요소는 기본적으로 아래 4가지 구성:\r\n\r\n1. **content** – 내용 (텍스트, 이미지)\r\n2. **padding** – 내부 여백\r\n3. **border** – 테두리\r\n4. **margin** – 외부 여백\r\n\r\n```css\r\n.box {\r\n  width: 200px;\r\n  height: 100px;\r\n  padding: 10px;\r\n  border: 5px solid blue;\r\n  margin: 20px;\r\n  background-color: lightgray;\r\n}\r\n```\r\n\r\n총 너비 계산 (box-sizing: content-box 기준) → 200 + 20(padding) + 10(border) = **240px**\r\n\r\n✅ 실무에서는 항상 아래 설정 사용\r\n\r\n```css\r\n* { box-sizing: border-box; }\r\n```\r\n\r\n---\r\n\r\n## 단축 속성\r\n\r\n```css\r\nmargin: 10px 20px 30px 40px;  /* 상 우 하 좌 */\r\nmargin: 10px 20px;            /* 상하, 좌우 */\r\nmargin: 10px;                 /* 전체 동일 */\r\n```\r\n\r\n### 마진 겹침 (margin collapse)\r\n\r\n- 상하 마진이 겹칠 경우 큰 값 하나만 적용됨\r\n\r\n---\r\n\r\n## 텍스트 스타일링\r\n\r\n| 속성              | 예시                       | 설명      |\r\n| --------------- | ------------------------ | ------- |\r\n| font-family     | 'Pretendard', sans-serif | 글꼴 설정   |\r\n| font-size       | 16px, 24px               | 글자 크기   |\r\n| font-weight     | normal, bold, 700        | 글자 두께   |\r\n| line-height     | 1.5                      | 줄 간격    |\r\n| text-align      | center, left             | 정렬      |\r\n| letter-spacing  | 1px                      | 자간      |\r\n| text-transform  | uppercase                | 대소문자 변환 |\r\n| text-decoration | underline                | 밑줄 등    |\r\n| white-space     | nowrap                   | 줄바꿈 금지  |\r\n| text-overflow   | ellipsis                 | 말줄임 처리  |\r\n\r\n---\r\n\r\n## 색상 & 배경\r\n\r\n| 속성                  | 예시                      | 설명               |\r\n| ------------------- | ----------------------- | ---------------- |\r\n| color               | #333, rgba(255,0,0,0.5) | 글자 색상            |\r\n| background-color    | #f5f5f5                 | 배경 색상            |\r\n| background-image    | url('bg.jpg')           | 배경 이미지           |\r\n| background          | [단축]                    | 색상, 이미지, 위치 등 통합 |\r\n| opacity             | 0.5                     | 투명도 조절           |\r\n| background-gradient | linear-gradient(...)    | 그라데이션 배경         |\r\n\r\n---\r\n\r\n## 레이아웃 시스템: Flex, Grid, Position\r\n\r\n### Flexbox\r\n\r\n```css\r\n.container {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  gap: 20px;\r\n}\r\n```\r\n\r\n| 속성              | 값                     | 설명    |\r\n| --------------- | --------------------- | ----- |\r\n| justify-content | center, space-between | 가로 정렬 |\r\n| align-items     | center, flex-start    | 세로 정렬 |\r\n| flex-direction  | row, column           | 방향 설정 |\r\n\r\n### Grid\r\n\r\n- 행과 열을 동시에 구성할 때 사용\r\n\r\n### Position\r\n\r\n| 속성       | 설명           |\r\n| -------- | ------------ |\r\n| static   | 기본 위치        |\r\n| relative | 기준 이동 가능     |\r\n| absolute | 부모 기준 배치     |\r\n| fixed    | 화면 고정        |\r\n| sticky   | 위치에 따라 고정/해제 |\r\n\r\n✅ fixed / sticky / absolute는 레이아웃 설계 시 많이 씀\r\n\r\n---\r\n\r\n## 추가 실무 속성\r\n\r\n### z-index\r\n\r\n```css\r\n.modal {\r\n  position: absolute;\r\n  z-index: 999;\r\n}\r\n```\r\n\r\n### calc()\r\n\r\n```css\r\nwidth: calc(100% - 40px);\r\n```\r\n\r\n### clamp()\r\n\r\n```css\r\nfont-size: clamp(14px, 2vw, 24px);\r\n```\r\n\r\n### media query\r\n\r\n```css\r\n@media (max-width: 768px) {\r\n  body { background: pink; }\r\n}\r\n```\r\n\r\n### object-fit (반응형 이미지)\r\n\r\n```css\r\nimg {\r\n  width: 100%;\r\n  height: 200px;\r\n  object-fit: cover;\r\n}\r\n```\r\n\r\n### transition\r\n\r\n```css\r\nbutton {\r\n  transition: all 0.3s ease;\r\n}\r\n```\r\n\r\n### custom property (CSS 변수)\r\n\r\n```css\r\n:root {\r\n  --main-color: #3498db;\r\n}\r\n\r\n.button {\r\n  background: var(--main-color);\r\n}\r\n```\r\n\r\n---\r\n\r\n## 마무리 회고\r\n\r\n- CSS는 단순히 예쁜 웹사이트를 만드는 걸 넘어서, **디자인 감각 + 구조적 사고**가 결합된 기술이다.\r\n- 초반에는 감각이 없어도 되지만, **많이 보고 따라 만들면서 체화된다.**\r\n- 지금까지 학습한 내용은 **실무 CSS의 거의 100%를 커버**한다.\r\n- 이제는 JS와의 결합을 통해 인터랙션 중심의 웹 개발로 확장해나갈 타이밍이다.\r\n\r\n🔥 CSS 공부는 얼추 끝난 것 같고 클론코딩(웹사이트) 제작하면서 복습 반복 > 그리고 숙지후에\r\n빠르게 자바스크립트를 넘어가야 할 것 같다.\r\n\r\n"
    },
    {
      "id": "2025-04-23-auto-generated",
      "title": "[HTML 기초 완전정복] 🧱",
      "date": "2025-04-23",
      "category": "daily",
      "tags": [
        "CSS",
        "HTML"
      ],
      "image": "https://images.unsplash.com/photo-1488590528505-98d2b5aba04b?w=400&h=200&fit=crop",
      "description": "2025-04-23의 학습 내용 정리",
      "excerpt": "<!DOCTYPE html>\r",
      "content": "# [HTML 기초 완전정복] 🧱\r\n\r\n## ✅ HTML 기본 5대 요소\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"ko\">\r\n  <head>\r\n    <meta charset=\"UTF-8\"> <!-- 한글 깨짐 방지 (UTF-8은 전 세계 문자 지원) -->\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <!-- 모바일 반응형 대응 -->\r\n    <title>브라우저 탭 제목</title> <!-- 브라우저 탭 타이틀 -->\r\n    <link rel=\"stylesheet\" href=\"style.css\"> <!-- CSS 파일 연결 -->\r\n    <link rel=\"icon\" href=\"favicon.ico\"> <!-- 파비콘 (즐겨찾기 아이콘) -->\r\n  </head>\r\nmeta: 문서 정보 제공\r\n\r\ncharset=\"UTF-8\": 한글 포함 전 세계 문자 지원\r\n\r\nviewport: 모바일에서 반응형 디자인 적용\r\n\r\ntitle: 브라우저 탭 제목\r\n\r\nlink: 외부 파일(css, favicon 등) 연결\r\n\r\n📦 시맨틱 구조 이해하기\r\nhtml\r\n복사\r\n편집\r\n<body>\r\n  <header>헤더</header>\r\n  <nav>메뉴</nav>\r\n  <main>\r\n    <section>내용 구역</section>\r\n    <article>독립 콘텐츠</article>\r\n  </main>\r\n  <aside>사이드바</aside>\r\n  <footer>하단 정보</footer>\r\n</body>\r\n\r\n태그\t역할\r\n<header>\t로고, 로그인, 네비 등 상단 요소\r\n<nav>\t메뉴 및 링크 묶음\r\n<main>\t페이지 핵심 콘텐츠\r\n<section>\t의미 있는 구역 분리\r\n<article>\t독립 가능한 콘텐츠 (ex. 뉴스, 게시물)\r\n<aside>\t광고, 추천글 등 부가 정보\r\n<footer>\t회사 정보, 저작권, 연락처 등 하단 정보\r\ndiv는 지양: 의미 없는 구조가 될 수 있음. 의미 있는 묶음은 section, article 사용.\r\n\r\n시맨틱 태그는 **SEO 및 접근성(스크린 리더 등)**에 큰 도움.\r\n\r\n📝 텍스트 관련 태그\r\n\r\n태그\t기능\t설명\r\n<h1> ~ <h6>\t제목\tSEO에 매우 중요\r\n<p>\t단락\t일반 텍스트 단위\r\n<span>\t인라인 텍스트 조각\t스타일 지정 용도로 주로 사용\r\n<strong>\t굵게 + 강조 의미\t검색엔진에서 중요한 단어로 인식\r\n<em>\t기울임 + 감정 강조\t강조 표현\r\n<br>\t줄바꿈\t텍스트 중간 줄바꿈 시 사용\r\n✅ 실무에서는 <div> 대신 의미 있는 태그(h1, p, strong) 사용 권장\r\n✅ 시각장애인을 위한 리더기에서도 강조 부분을 인식 가능\r\n\r\n📋 목록 관련 태그\r\nhtml\r\n복사\r\n편집\r\n<ul>\r\n  <li>항목1</li>\r\n  <li>항목2</li>\r\n</ul>\r\n\r\n<ol>\r\n  <li>1번 항목</li>\r\n  <li>2번 항목</li>\r\n</ol>\r\n\r\n태그\t기능\r\n<ul>\t순서 없는 리스트 (●)\r\n<ol>\t순서 있는 리스트 (1, 2, 3)\r\n<li>\t리스트 항목\r\n🔗 링크 및 이미지 태그\r\nhtml\r\n복사\r\n편집\r\n<a href=\"https://example.com\" target=\"_blank\">새 탭 링크</a>\r\n<img src=\"logo.png\" alt=\"회사 로고\">\r\ntarget=\"_blank\": 새 탭에서 열기\r\n\r\nalt: 이미지가 안 보일 때 설명 + SEO 접근성 필수\r\n\r\n✍️ 폼 요소 (로그인, 회원가입, 검색 등에 사용)\r\nhtml\r\n복사\r\n편집\r\n<form action=\"/login\" method=\"POST\">\r\n  <label for=\"id\">아이디</label>\r\n  <input type=\"text\" id=\"id\" name=\"id\">\r\n  \r\n  <label for=\"pw\">비밀번호</label>\r\n  <input type=\"password\" id=\"pw\" name=\"pw\">\r\n  \r\n  <button type=\"submit\">로그인</button>\r\n</form>\r\n\r\n태그\t설명\r\n<form>\t입력 데이터를 묶고 서버로 전송\r\n<label>\t입력 필드 설명 (접근성 향상)\r\n<input>\t사용자 입력 필드 (type으로 역할 구분)\r\n<button>\t폼 전송 (submit이면 자동 전송, button이면 JS로 처리)\r\nlabel for=id와 input id=\"id\"는 반드시 연결\r\ninput에는 반드시 name 속성이 있어야 서버에서 데이터를 받을 수 있음\r\n\r\n🛠️ 실무에서 자주 쓰이는 특수 태그\r\n\r\n태그\t기능\r\n<meta>\tSEO, 모바일 대응, 설명 등 정보 전달\r\n<link>\t외부 CSS, 파비콘 연결\r\n<script>\tJS 기능 구현\r\n<iframe>\t외부 콘텐츠 삽입 (지도, 유튜브 등)\r\n<table>\t표 형식 데이터 (관리자 페이지 등)\r\n<input type=\"checkbox\">\t체크박스 (다중 선택)\r\n<input type=\"radio\">\t라디오 버튼 (단일 선택)\r\n<input type=\"file\">\t파일 업로드 (이미지, 첨부파일 등)\r\n<input type=\"date\">\t날짜 선택 (생일, 예약 등)\r\n🔍 후기\r\nHTML은 구조를 의미 기반으로 짜는 것이 핵심이다.\r\n\r\n<div>는 무분별하게 쓰지 않도록 주의!\r\n\r\nSEO와 접근성을 고려한 구조 설계가 중요.\r\n\r\n실제 웹사이트를 만들면서 부딪혀본 것이 큰 도움이 되었고, 하나하나 체화하는 데 큰 어려움은 없었다.\r\n\r\n내일은 CSS를 완벽하게 정리해서 HTML + CSS를 마무리할 계획이다.\r\n\r\n"
    },
    {
      "id": "2025-04-22-auto-generated",
      "title": "2025-04-22 부트캠프 개인공부 및 실습 총정리",
      "date": "2025-04-22",
      "category": "daily",
      "tags": [
        "Git",
        "JavaScript",
        "CSS",
        "HTML",
        "Java",
        "연습",
        "학습",
        "프로젝트"
      ],
      "image": "https://images.unsplash.com/photo-1518432031352-d6fc5c10da5a?w=400&h=200&fit=crop",
      "description": "2025-04-22의 학습 내용 정리",
      "excerpt": "- `<!DOCTYPE html>`, `<html>`, `<head>`, `<body>` 구조 직접 세팅\r",
      "content": "# 2025-04-22 부트캠프 개인공부 및 실습 총정리\r\n\r\n## 오늘 공부한 전체 흐름 요약\r\n\r\n### 1. HTML 기본 골격 만들기\r\n- `<!DOCTYPE html>`, `<html>`, `<head>`, `<body>` 구조 직접 세팅\r\n- `<header>`, `<main>`, `<footer>` 구분해서 레이아웃 만들기\r\n- 기본적으로 헤더 안에 로고, 검색창, 메뉴 리스트 구성하는 방식 연습\r\n\r\n### 2. CSS 기초 적용 방법\r\n- `link rel=\"stylesheet\" href=\"style.css\"`로 외부 CSS 파일 연결\r\n- 폰트 크기, 색상, 굵기 조절 방법 학습\r\n- 박스 모델(Box Model) 개념 이해 (margin, padding, border)\r\n- 버튼, 입력창(input) 스타일링 직접 수정해보기\r\n\r\n### 3. 간단한 웹페이지 클론 연습\r\n- 네이버 클론 프로젝트 (GAVER) 시작\r\n- 로고 \"GAVER\" 표시\r\n- 검색창과 검색 버튼 추가 및 배치\r\n- 메뉴바(홈, 뉴스, 메일, 카페, 블로그, 쇼핑) 구성\r\n- 뉴스, 쇼핑, 블로그 각각 섹션별로 카드형 리스트 배치\r\n- 실제 네이버 느낌 살리기 위해 초록색 포인트 컬러 적용\r\n\r\n### 4. JavaScript 기초 맛보기\r\n- 버튼, 뉴스 아이템 등 클릭했을 때 `alert('구라지롱~')` 뜨는 기능 추가\r\n- `querySelectorAll`과 `forEach` 활용하여 여러 요소에 클릭 이벤트 달기\r\n\r\n### 5. Git 기본 명령어 사용 흐름 연습\r\n- `git init` 으로 로컬 저장소 초기화\r\n- `git add .` 로 전체 파일 스테이징\r\n- `git commit -m \"커밋메시지\"` 로 버전 저장\r\n- `git push -u origin main` 으로 GitHub 원격 저장소에 업로드\r\n\r\n### 6. GitHub & Vercel 배포까지 도전\r\n- GitHub 새 레포지토리 생성 및 연결\r\n- Vercel에서 GitHub 연동하여 바로 배포 시도\r\n- Vercel 설정에서 Output Directory 문제 발생 (html 단일 파일 배포 시 설정 주의 필요)\r\n- 최종적으로 배포 실패했지만 문제 원인 분석까지 경험\r\n\r\n---\r\n\r\n## 오늘 배운 키워드 요약\r\n\r\n- HTML 구조 (헤더, 메인, 푸터)\r\n- CSS 스타일링 기초 (폰트, 색상, 배치)\r\n- 간단한 네이버 스타일 페이지 클론\r\n- JavaScript 기초 이벤트 핸들링 (alert)\r\n- Git 기본 명령어 흐름 (add, commit, push)\r\n- GitHub 원격 저장소 관리\r\n- Vercel을 통한 웹사이트 배포 프로세스 이해.\r\n\r\n---\r\n\r\n## 내일/다음 목표\r\n\r\n- HTML/CSS 디테일 마무리 (반응형 연습 시작)\r\n- JavaScript 조금 더 깊게 다루기 (간단한 DOM 조작)\r\n- Git/GitHub 실수 없이 사용하기 연습 (에러 복구 방법까지)\r\n- Vercel 정식 배포 성공시키기 (public 폴더 직접 세팅) "
    },
    {
      "id": "2025-04-14-auto-generated",
      "title": "2025-04-14 학습 일지",
      "date": "2025-04-14",
      "category": "daily",
      "tags": [
        "학습"
      ],
      "image": "https://images.unsplash.com/photo-1504639725590-34d0984388bd?w=400&h=200&fit=crop",
      "description": "2025-04-14의 학습 내용 정리",
      "excerpt": "오늘은 부트캠프 신청을 하는김에 여러가지 정부지원을 알아보고 신청했다.\r",
      "content": "오늘은 부트캠프 신청을 하는김에 여러가지 정부지원을 알아보고 신청했다.\r\n솔직히 1일 1커밋을 하기로 마음을 먹었는데, 이렇게 일기식으로 쓰는게 맞나 싶기도하다.\r\n\r\n그래서 오늘은 간단한 회고만을 남기려고 한다.\r\n\r\n메모장으로만 메모를 했는데 조금 익숙해지려고 vs를 쓰기도하고 파이썬 강의도 들었는데 생각보다 어렵지않아서, 배우는데도 당황스러운 부분이 있었다.\r\n\r\n원래 파이썬은 그만큼 다루기 쉽다는데 장점이 있으니 입문으로 추천하는 것 같다.\r\n\r\n일단 정부지원도 어느정도 정리됐고, 좀더 빡세게 정진 해야할 것 같다.\r\n파이썬강의 듣다가 배운건 vs에서 필기하고, 챗지피티로 정리하고, 커밋 푸쉬 하는 과정이 아직도 매끄럽진 않다.\r\n\r\n모든게 익숙해지는 내일을 기대해보면 오늘은 여기서 마무리!!"
    },
    {
      "id": "2025-04-13-auto-generated",
      "title": "부트캠프 전 인풋 되는데로 채워보기 프로젝트 - 1일차 (나의 생각들)",
      "date": "2025-04-13",
      "category": "daily",
      "tags": [
        "Git",
        "Python",
        "학습",
        "프로젝트",
        "개발"
      ],
      "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=400&h=200&fit=crop",
      "description": "2025-04-13의 학습 내용 정리",
      "excerpt": "사실 황당한 프로젝트에 가깝지만, 인풋이 전혀없는 나로서는 모든 정보들을 머릿속에 끌어모으는 중이다.  \r",
      "content": "# 부트캠프 전 인풋 되는데로 채워보기 프로젝트 - 1일차 (나의 생각들)\r\n\r\n사실 황당한 프로젝트에 가깝지만, 인풋이 전혀없는 나로서는 모든 정보들을 머릿속에 끌어모으는 중이다.  \r\nVS를 다운받아보고 파이썬도 다운받아서 간단한 프로그램도 개발해보기도 하고 홈페이지도 만들어 보는 중이다.\r\n\r\n그 과정 중에 웹디자이너와 프론트엔드의 차이, 그리고 백엔드의 역할들에 자연스레 이해하게 되었으며,  \r\n어떤 프로그램을 써서 어떤 그림으로 진행이 되는지 이해하려고 최대한 노력하였다.\r\n\r\n지하철로 이동을 하거나, 자기 전에도 코딩에 관련된 강의와 전망 등을 닥치는 대로 보고 있는 중이다.  \r\n모르는 개념에 대해서는 챗지피티에게 여과 없이 물어보고 있고,  \r\n어느 정도 트렌디함이 떨어지거나, 오류가 있긴 하지만 최대한 활용하고 있는 중이다.\r\n\r\n개발자의 길을 걷기로 한 이상 대충이라는 건 머릿속에 없다.  \r\n부트캠프 전에 어떠한 인풋이라도 머릿속에 집어넣을 생각이다.  \r\n설령 그게, 활용도가 떨어지더라도 말이다.\r\n\r\n또한, 머릿속에 구상하고 있는 것들을 우선은 손대 보는 중이다.  \r\nPC와 연결된 블루투스 스피커가 있는데, 이게 소리를 출력하지 않으면 블루투스가 자동으로 절전 기능이 된다.  \r\n서칭을 통해서 절전모드를 해제하는 법에 대해 찾아봤지만 방법을 찾지 못했다.\r\n\r\n사실 구글링이나 서칭 능력은 어느 정도 있다고 생각했는데, 유독 안 돼서 스트레스가 되었던 부분이다.  \r\n그래서 그냥 내가 개발자를 지망하는 사람이지만  \r\n한번 만들어 보자 라는 생각이 들었고,  \r\n뭔가 미덥지 않은 챗지피티와 동행을 하기로 했다.\r\n\r\n파이썬을 코딩테스트 대비로 미리 공부를 하려던 차에,  \r\n파이썬을 이용해서 개발을 해보자고 챗지피티가 제안을 했고,  \r\n파이썬을 다운받고 VS를 다운받았다.\r\n\r\n사실 print(\"Hello\") 정도만 겨우 뗀 터라,  \r\n시간이 많이 소요될 거란 예상을 했다.\r\n\r\n---\r\n\r\n## 결과\r\n\r\n미리 결과를 말하자면,  \r\n장장 5시간이 걸려서 프로그램을 만들었다.  \r\n아주 만족스러웠고,  \r\n1일 1커밋을 당장 지금부터 할 목표를 잡은 나는 기술블로그처럼  \r\n아주 허접하지만 과정들을 기입했다.\r\n\r\n챗지피티가 생각보다 코딩을 못한다는 사실,  \r\n재차 질문할 것들이 너무 많아 스트레스를 받을 지경이었다.  \r\n하지만 이 과정조차 나를 단단하게 할 것이라 생각하고 마음을 다잡았다.\r\n\r\n사실, 이런 류의 작업은 나에게는 정말 재밌고 만족감을 주기 때문에  \r\n이 길을 들어선 이유도 있다.\r\n\r\n내 컴퓨터와 스피커 상호간의 문제는 사라졌고,  \r\n아주 만족하는 중이다.\r\n\r\n---\r\n\r\n## 오늘의 마무리\r\n\r\n밤을 새서 만들었지만,  \r\n아직까지도 열정이 사그라들지 않아 바로 파이썬 강의를 코딩테스트 대비 들으러 가려고 한다.  \r\n파이썬은 나처럼 아예 모르는 사람들이 코딩테스트 보기엔 적합한 언어라고 해서 시작을 했다.\r\n\r\n앞으로도 잠자기 전까지 머릿속이 코딩으로 가득할 것 같다.  \r\n어떤 일을 이루려면 1만 시간이 필요하다고 한다.\r\n\r\n내가 지금 몇 년을 굴러도 1만 시간이 채워지는 게 어려울 것이다.  \r\n하지만 어떻게든 해내고 싶은 새벽이다.\r\n\r\n---\r\n\r\n## 회고 요약 (내가 쓴 회고 내용을 챗지피티가 요약해준 것)\r\n\r\n- 완전 비전공 백지상태에서 첫 프로그램 제작\r\n- 블루투스 절전 방지 툴 직접 구현 완료\r\n- 파이썬 환경 세팅 및 간단한 문법 학습 시작\r\n- 매일 회고 + 1일 1커밋 결심\r\n- 개발자가 되겠다가 아니라, 이미 개발자로 살고 있는 중\r\n\r\n---\r\n\r\n## 🛠 기술 리뷰\r\n\r\n- [2025년 4월 13일 | Python TIL 기술 리뷰](https://github.com/Stylechoi/til-python/blob/main/2025-04-13.md)\r\n\r\n\r\n\r\n매일 쓰는 회고 - 1일차 끝,\r\n"
    }
  ],
  "tech": [
    {
      "id": "2025-05-28-login-system-implementation",
      "title": "HTML/CSS로 구현하는 모던 로그인 시스템",
      "date": "2025-05-28",
      "category": "tech",
      "tags": [
        "6366f1",
        "5855eb",
        "e0e7ff",
        "64748b",
        "1e293b",
        "64748b",
        "94a3b8",
        "ffffff",
        "f8fafc",
        "e2e8f0",
        "6366f1",
        "ef4444",
        "fef2f2",
        "10b981",
        "ea4335",
        "fef2f2",
        "24292e",
        "f6f8fa",
        "0f172a",
        "1e293b",
        "f1f5f9",
        "cbd5e1",
        "64748b",
        "334155",
        "1e293b",
        "0f172a"
      ],
      "image": "https://images.unsplash.com/photo-1542831371-29b0f74f9713?w=400&h=200&fit=crop",
      "description": "HTML/CSS로 구현하는 모던 로그인 시스템에 대한 기술 포스트",
      "excerpt": "오늘은 순수 HTML과 CSS만을 사용하여 현대적이고 사용자 친화적인 로그인 시스템을 구현해보았다. JavaScript 없이도 얼마나 완성도 높은 UI를 만들 수 있는지 실험해보는...",
      "content": "---\r\n# HTML/CSS로 구현하는 모던 로그인 시스템\r\n\r\n오늘은 순수 HTML과 CSS만을 사용하여 현대적이고 사용자 친화적인 로그인 시스템을 구현해보았다. JavaScript 없이도 얼마나 완성도 높은 UI를 만들 수 있는지 실험해보는 과정이었다.\r\n\r\n## 🎯 프로젝트 목표\r\n\r\n- **순수 HTML/CSS**: JavaScript 의존성 없는 기본 구조 구축\r\n- **반응형 디자인**: 모든 디바이스에서 최적화된 경험 제공\r\n- **접근성 고려**: 스크린 리더와 키보드 네비게이션 지원\r\n- **모던 UI/UX**: 최신 디자인 트렌드 반영\r\n\r\n## 🏗️ HTML 구조 설계\r\n\r\n### 시맨틱 마크업 활용\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"ko\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>로그인 - StyleChoi</title>\r\n    <link rel=\"stylesheet\" href=\"login.css\">\r\n</head>\r\n<body>\r\n    <main class=\"login-container\">\r\n        <div class=\"login-card\">\r\n            <header class=\"login-header\">\r\n                <h1>로그인</h1>\r\n                <p>계정에 로그인하여 서비스를 이용하세요</p>\r\n            </header>\r\n            \r\n            <form class=\"login-form\" action=\"/login\" method=\"POST\">\r\n                <div class=\"form-group\">\r\n                    <label for=\"email\">이메일</label>\r\n                    <input \r\n                        type=\"email\" \r\n                        id=\"email\" \r\n                        name=\"email\" \r\n                        required \r\n                        autocomplete=\"email\"\r\n                        placeholder=\"example@email.com\"\r\n                    >\r\n                    <span class=\"error-message\" id=\"email-error\"></span>\r\n                </div>\r\n                \r\n                <div class=\"form-group\">\r\n                    <label for=\"password\">비밀번호</label>\r\n                    <div class=\"password-input-wrapper\">\r\n                        <input \r\n                            type=\"password\" \r\n                            id=\"password\" \r\n                            name=\"password\" \r\n                            required \r\n                            autocomplete=\"current-password\"\r\n                            placeholder=\"비밀번호를 입력하세요\"\r\n                        >\r\n                        <button type=\"button\" class=\"password-toggle\" aria-label=\"비밀번호 보기/숨기기\">\r\n                            👁️\r\n                        </button>\r\n                    </div>\r\n                    <span class=\"error-message\" id=\"password-error\"></span>\r\n                </div>\r\n                \r\n                <div class=\"form-options\">\r\n                    <label class=\"checkbox-wrapper\">\r\n                        <input type=\"checkbox\" name=\"remember\" id=\"remember\">\r\n                        <span class=\"checkmark\"></span>\r\n                        로그인 상태 유지\r\n                    </label>\r\n                    \r\n                    <a href=\"/forgot-password\" class=\"forgot-link\">\r\n                        비밀번호를 잊으셨나요?\r\n                    </a>\r\n                </div>\r\n                \r\n                <button type=\"submit\" class=\"login-button\">\r\n                    로그인\r\n                </button>\r\n            </form>\r\n            \r\n            <footer class=\"login-footer\">\r\n                <p>계정이 없으신가요? \r\n                    <a href=\"/signup\" class=\"signup-link\">회원가입</a>\r\n                </p>\r\n                \r\n                <div class=\"social-login\">\r\n                    <p>또는</p>\r\n                    <div class=\"social-buttons\">\r\n                        <button class=\"social-btn google\">\r\n                            <svg class=\"social-icon\" viewBox=\"0 0 24 24\">\r\n                                <!-- Google 아이콘 SVG -->\r\n                            </svg>\r\n                            Google로 로그인\r\n                        </button>\r\n                        <button class=\"social-btn github\">\r\n                            <svg class=\"social-icon\" viewBox=\"0 0 24 24\">\r\n                                <!-- GitHub 아이콘 SVG -->\r\n                            </svg>\r\n                            GitHub로 로그인\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n            </footer>\r\n        </div>\r\n    </main>\r\n</body>\r\n</html>\r\n```\r\n\r\n### 접근성 고려사항\r\n\r\n1. **시맨틱 태그**: `main`, `header`, `footer` 등으로 구조 명확화\r\n2. **레이블 연결**: 모든 입력 필드에 적절한 `label` 연결\r\n3. **ARIA 속성**: 스크린 리더를 위한 추가 정보 제공\r\n4. **키보드 네비게이션**: Tab 순서와 포커스 관리\r\n\r\n## 🎨 CSS 스타일링 전략\r\n\r\n### CSS 변수를 활용한 디자인 시스템\r\n\r\n```css\r\n:root {\r\n    /* 컬러 팔레트 */\r\n    --primary-color: #6366f1;\r\n    --primary-hover: #5855eb;\r\n    --primary-light: #e0e7ff;\r\n    \r\n    --secondary-color: #64748b;\r\n    --text-primary: #1e293b;\r\n    --text-secondary: #64748b;\r\n    --text-muted: #94a3b8;\r\n    \r\n    --background: #ffffff;\r\n    --surface: #f8fafc;\r\n    --border: #e2e8f0;\r\n    --border-focus: #6366f1;\r\n    \r\n    --error: #ef4444;\r\n    --error-light: #fef2f2;\r\n    --success: #10b981;\r\n    \r\n    /* 타이포그래피 */\r\n    --font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;\r\n    --font-size-xs: 0.75rem;\r\n    --font-size-sm: 0.875rem;\r\n    --font-size-base: 1rem;\r\n    --font-size-lg: 1.125rem;\r\n    --font-size-xl: 1.25rem;\r\n    --font-size-2xl: 1.5rem;\r\n    \r\n    /* 간격 */\r\n    --spacing-1: 0.25rem;\r\n    --spacing-2: 0.5rem;\r\n    --spacing-3: 0.75rem;\r\n    --spacing-4: 1rem;\r\n    --spacing-6: 1.5rem;\r\n    --spacing-8: 2rem;\r\n    --spacing-12: 3rem;\r\n    \r\n    /* 그림자 */\r\n    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);\r\n    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);\r\n    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);\r\n    \r\n    /* 애니메이션 */\r\n    --transition-fast: 150ms ease-in-out;\r\n    --transition-normal: 250ms ease-in-out;\r\n    --transition-slow: 350ms ease-in-out;\r\n}\r\n```\r\n\r\n### 반응형 레이아웃 구현\r\n\r\n```css\r\n/* 기본 레이아웃 */\r\n.login-container {\r\n    min-height: 100vh;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    padding: var(--spacing-4);\r\n    background: linear-gradient(135deg, var(--primary-light) 0%, var(--surface) 100%);\r\n}\r\n\r\n.login-card {\r\n    width: 100%;\r\n    max-width: 400px;\r\n    background: var(--background);\r\n    border-radius: 12px;\r\n    box-shadow: var(--shadow-lg);\r\n    overflow: hidden;\r\n    transition: transform var(--transition-normal);\r\n}\r\n\r\n.login-card:hover {\r\n    transform: translateY(-2px);\r\n}\r\n\r\n/* 모바일 최적화 */\r\n@media (max-width: 480px) {\r\n    .login-container {\r\n        padding: var(--spacing-2);\r\n    }\r\n    \r\n    .login-card {\r\n        border-radius: 8px;\r\n        box-shadow: var(--shadow-md);\r\n    }\r\n    \r\n    .login-header h1 {\r\n        font-size: var(--font-size-xl);\r\n    }\r\n}\r\n\r\n/* 태블릿 */\r\n@media (min-width: 481px) and (max-width: 768px) {\r\n    .login-card {\r\n        max-width: 450px;\r\n    }\r\n}\r\n\r\n/* 데스크탑 */\r\n@media (min-width: 769px) {\r\n    .login-card {\r\n        max-width: 500px;\r\n    }\r\n    \r\n    .login-container {\r\n        padding: var(--spacing-8);\r\n    }\r\n}\r\n```\r\n\r\n### 폼 요소 스타일링\r\n\r\n```css\r\n/* 입력 필드 기본 스타일 */\r\n.form-group {\r\n    margin-bottom: var(--spacing-6);\r\n}\r\n\r\n.form-group label {\r\n    display: block;\r\n    margin-bottom: var(--spacing-2);\r\n    font-size: var(--font-size-sm);\r\n    font-weight: 500;\r\n    color: var(--text-primary);\r\n}\r\n\r\n.form-group input {\r\n    width: 100%;\r\n    padding: var(--spacing-3) var(--spacing-4);\r\n    border: 2px solid var(--border);\r\n    border-radius: 8px;\r\n    font-size: var(--font-size-base);\r\n    transition: all var(--transition-fast);\r\n    background: var(--background);\r\n}\r\n\r\n/* 포커스 상태 */\r\n.form-group input:focus {\r\n    outline: none;\r\n    border-color: var(--border-focus);\r\n    box-shadow: 0 0 0 3px rgb(99 102 241 / 0.1);\r\n}\r\n\r\n/* 에러 상태 */\r\n.form-group input:invalid:not(:placeholder-shown) {\r\n    border-color: var(--error);\r\n}\r\n\r\n.form-group input:invalid:not(:placeholder-shown) + .error-message {\r\n    display: block;\r\n    color: var(--error);\r\n    font-size: var(--font-size-xs);\r\n    margin-top: var(--spacing-1);\r\n}\r\n\r\n/* 비밀번호 입력 필드 */\r\n.password-input-wrapper {\r\n    position: relative;\r\n}\r\n\r\n.password-toggle {\r\n    position: absolute;\r\n    right: var(--spacing-3);\r\n    top: 50%;\r\n    transform: translateY(-50%);\r\n    background: none;\r\n    border: none;\r\n    cursor: pointer;\r\n    padding: var(--spacing-1);\r\n    border-radius: 4px;\r\n    transition: background-color var(--transition-fast);\r\n}\r\n\r\n.password-toggle:hover {\r\n    background-color: var(--surface);\r\n}\r\n```\r\n\r\n### 커스텀 체크박스 구현\r\n\r\n```css\r\n.checkbox-wrapper {\r\n    display: flex;\r\n    align-items: center;\r\n    cursor: pointer;\r\n    font-size: var(--font-size-sm);\r\n    color: var(--text-secondary);\r\n}\r\n\r\n.checkbox-wrapper input[type=\"checkbox\"] {\r\n    display: none;\r\n}\r\n\r\n.checkmark {\r\n    width: 18px;\r\n    height: 18px;\r\n    border: 2px solid var(--border);\r\n    border-radius: 4px;\r\n    margin-right: var(--spacing-2);\r\n    position: relative;\r\n    transition: all var(--transition-fast);\r\n}\r\n\r\n.checkbox-wrapper input[type=\"checkbox\"]:checked + .checkmark {\r\n    background-color: var(--primary-color);\r\n    border-color: var(--primary-color);\r\n}\r\n\r\n.checkbox-wrapper input[type=\"checkbox\"]:checked + .checkmark::after {\r\n    content: '✓';\r\n    position: absolute;\r\n    top: 50%;\r\n    left: 50%;\r\n    transform: translate(-50%, -50%);\r\n    color: white;\r\n    font-size: 12px;\r\n    font-weight: bold;\r\n}\r\n```\r\n\r\n### 버튼 디자인 시스템\r\n\r\n```css\r\n/* 기본 버튼 스타일 */\r\n.login-button {\r\n    width: 100%;\r\n    padding: var(--spacing-3) var(--spacing-4);\r\n    background: var(--primary-color);\r\n    color: white;\r\n    border: none;\r\n    border-radius: 8px;\r\n    font-size: var(--font-size-base);\r\n    font-weight: 500;\r\n    cursor: pointer;\r\n    transition: all var(--transition-fast);\r\n    margin-bottom: var(--spacing-6);\r\n}\r\n\r\n.login-button:hover {\r\n    background: var(--primary-hover);\r\n    transform: translateY(-1px);\r\n    box-shadow: var(--shadow-md);\r\n}\r\n\r\n.login-button:active {\r\n    transform: translateY(0);\r\n}\r\n\r\n.login-button:disabled {\r\n    background: var(--text-muted);\r\n    cursor: not-allowed;\r\n    transform: none;\r\n}\r\n\r\n/* 소셜 로그인 버튼 */\r\n.social-buttons {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: var(--spacing-3);\r\n}\r\n\r\n.social-btn {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    gap: var(--spacing-2);\r\n    padding: var(--spacing-3) var(--spacing-4);\r\n    border: 2px solid var(--border);\r\n    border-radius: 8px;\r\n    background: var(--background);\r\n    color: var(--text-primary);\r\n    font-size: var(--font-size-sm);\r\n    font-weight: 500;\r\n    cursor: pointer;\r\n    transition: all var(--transition-fast);\r\n}\r\n\r\n.social-btn:hover {\r\n    border-color: var(--primary-color);\r\n    background: var(--primary-light);\r\n}\r\n\r\n.social-btn.google:hover {\r\n    border-color: #ea4335;\r\n    background: #fef2f2;\r\n}\r\n\r\n.social-btn.github:hover {\r\n    border-color: #24292e;\r\n    background: #f6f8fa;\r\n}\r\n\r\n.social-icon {\r\n    width: 20px;\r\n    height: 20px;\r\n}\r\n```\r\n\r\n## 🔧 고급 CSS 기법 활용\r\n\r\n### CSS Grid를 활용한 폼 옵션 레이아웃\r\n\r\n```css\r\n.form-options {\r\n    display: grid;\r\n    grid-template-columns: 1fr auto;\r\n    align-items: center;\r\n    gap: var(--spacing-4);\r\n    margin-bottom: var(--spacing-6);\r\n}\r\n\r\n@media (max-width: 480px) {\r\n    .form-options {\r\n        grid-template-columns: 1fr;\r\n        gap: var(--spacing-3);\r\n    }\r\n    \r\n    .forgot-link {\r\n        justify-self: start;\r\n    }\r\n}\r\n```\r\n\r\n### CSS 애니메이션으로 로딩 상태 표현\r\n\r\n```css\r\n@keyframes pulse {\r\n    0%, 100% {\r\n        opacity: 1;\r\n    }\r\n    50% {\r\n        opacity: 0.5;\r\n    }\r\n}\r\n\r\n.login-button.loading {\r\n    position: relative;\r\n    color: transparent;\r\n}\r\n\r\n.login-button.loading::after {\r\n    content: '';\r\n    position: absolute;\r\n    top: 50%;\r\n    left: 50%;\r\n    transform: translate(-50%, -50%);\r\n    width: 20px;\r\n    height: 20px;\r\n    border: 2px solid transparent;\r\n    border-top: 2px solid white;\r\n    border-radius: 50%;\r\n    animation: spin 1s linear infinite;\r\n}\r\n\r\n@keyframes spin {\r\n    0% { transform: translate(-50%, -50%) rotate(0deg); }\r\n    100% { transform: translate(-50%, -50%) rotate(360deg); }\r\n}\r\n```\r\n\r\n### 다크 모드 지원\r\n\r\n```css\r\n@media (prefers-color-scheme: dark) {\r\n    :root {\r\n        --background: #0f172a;\r\n        --surface: #1e293b;\r\n        --text-primary: #f1f5f9;\r\n        --text-secondary: #cbd5e1;\r\n        --text-muted: #64748b;\r\n        --border: #334155;\r\n    }\r\n    \r\n    .login-container {\r\n        background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);\r\n    }\r\n    \r\n    .login-card {\r\n        border: 1px solid var(--border);\r\n    }\r\n}\r\n```\r\n\r\n## 📱 반응형 디자인 전략\r\n\r\n### 모바일 퍼스트 접근법\r\n\r\n1. **기본 스타일**: 모바일 화면을 기준으로 설계\r\n2. **점진적 향상**: 큰 화면에서 추가 기능과 스타일 적용\r\n3. **터치 친화적**: 버튼 크기와 간격을 터치에 최적화\r\n\r\n```css\r\n/* 터치 타겟 최소 크기 보장 */\r\n.login-button,\r\n.social-btn,\r\n.password-toggle {\r\n    min-height: 44px; /* iOS 권장 최소 터치 타겟 크기 */\r\n}\r\n\r\n/* 모바일에서 입력 필드 확대 방지 */\r\n@media (max-width: 768px) {\r\n    input[type=\"email\"],\r\n    input[type=\"password\"] {\r\n        font-size: 16px; /* iOS에서 확대 방지 */\r\n    }\r\n}\r\n```\r\n\r\n## 🔍 성능 최적화\r\n\r\n### CSS 최적화 기법\r\n\r\n1. **CSS 변수 활용**: 일관된 디자인 시스템과 유지보수성 향상\r\n2. **선택자 최적화**: 깊은 중첩 피하고 효율적인 선택자 사용\r\n3. **애니메이션 최적화**: `transform`과 `opacity`만 사용하여 GPU 가속 활용\r\n\r\n```css\r\n/* GPU 가속을 위한 transform 사용 */\r\n.login-card {\r\n    will-change: transform;\r\n    transform: translateZ(0); /* 하드웨어 가속 강제 */\r\n}\r\n\r\n/* 효율적인 선택자 사용 */\r\n.form-group input:focus {\r\n    /* 깊은 중첩 대신 직접 선택 */\r\n}\r\n```\r\n\r\n## 🎯 사용자 경험 개선\r\n\r\n### 마이크로 인터랙션\r\n\r\n```css\r\n/* 입력 필드 포커스 애니메이션 */\r\n.form-group {\r\n    position: relative;\r\n}\r\n\r\n.form-group label {\r\n    transition: all var(--transition-fast);\r\n}\r\n\r\n.form-group input:focus + label,\r\n.form-group input:not(:placeholder-shown) + label {\r\n    transform: translateY(-20px) scale(0.875);\r\n    color: var(--primary-color);\r\n}\r\n\r\n/* 버튼 호버 효과 */\r\n.login-button {\r\n    position: relative;\r\n    overflow: hidden;\r\n}\r\n\r\n.login-button::before {\r\n    content: '';\r\n    position: absolute;\r\n    top: 0;\r\n    left: -100%;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);\r\n    transition: left var(--transition-slow);\r\n}\r\n\r\n.login-button:hover::before {\r\n    left: 100%;\r\n}\r\n```\r\n\r\n## 🔒 보안 고려사항\r\n\r\n### HTML 보안 속성\r\n\r\n```html\r\n<!-- 자동완성 보안 -->\r\n<input \r\n    type=\"password\" \r\n    autocomplete=\"current-password\"\r\n    spellcheck=\"false\"\r\n    data-lpignore=\"true\"\r\n>\r\n\r\n<!-- CSRF 보호 -->\r\n<form method=\"POST\" action=\"/login\">\r\n    <input type=\"hidden\" name=\"_token\" value=\"{{ csrf_token() }}\">\r\n    <!-- 폼 필드들 -->\r\n</form>\r\n```\r\n\r\n## 📊 접근성 테스트 결과\r\n\r\n### WCAG 2.1 준수사항\r\n\r\n1. **색상 대비**: AA 등급 이상 (4.5:1 비율)\r\n2. **키보드 네비게이션**: 모든 요소 Tab으로 접근 가능\r\n3. **스크린 리더**: 적절한 레이블과 ARIA 속성\r\n4. **포커스 표시**: 명확한 포커스 인디케이터\r\n\r\n```css\r\n/* 고대비 포커스 인디케이터 */\r\n*:focus {\r\n    outline: 2px solid var(--primary-color);\r\n    outline-offset: 2px;\r\n}\r\n\r\n/* 스크린 리더 전용 텍스트 */\r\n.sr-only {\r\n    position: absolute;\r\n    width: 1px;\r\n    height: 1px;\r\n    padding: 0;\r\n    margin: -1px;\r\n    overflow: hidden;\r\n    clip: rect(0, 0, 0, 0);\r\n    white-space: nowrap;\r\n    border: 0;\r\n}\r\n```\r\n\r\n## 🚀 향후 개선 계획\r\n\r\n### 단기 목표 (1-2주)\r\n- [ ] JavaScript로 실시간 유효성 검사 추가\r\n- [ ] 비밀번호 강도 표시기 구현\r\n- [ ] 로딩 상태 애니메이션 개선\r\n\r\n### 중기 목표 (1개월)\r\n- [ ] 2단계 인증 UI 추가\r\n- [ ] 소셜 로그인 실제 연동\r\n- [ ] PWA 지원으로 오프라인 기능\r\n\r\n### 장기 목표 (3개월)\r\n- [ ] 생체 인증 지원 (WebAuthn)\r\n- [ ] 다국어 지원\r\n- [ ] 고급 보안 기능 (디바이스 인식 등)\r\n\r\n## 💡 배운 점과 인사이트\r\n\r\n### 기술적 성장\r\n1. **CSS 변수의 강력함**: 디자인 시스템 구축에 필수적\r\n2. **접근성의 중요성**: 처음부터 고려해야 하는 필수 요소\r\n3. **성능 최적화**: 작은 최적화가 큰 차이를 만듦\r\n\r\n### 디자인 철학\r\n1. **사용자 중심**: 기술보다 사용자 경험이 우선\r\n2. **점진적 향상**: 기본 기능부터 완벽하게\r\n3. **일관성**: 디자인 시스템의 중요성\r\n\r\n## 🔗 참고 자료\r\n\r\n- [WCAG 2.1 Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)\r\n- [CSS Grid Complete Guide](https://css-tricks.com/snippets/css/complete-guide-grid/)\r\n- [Modern CSS Reset](https://piccalil.li/blog/a-modern-css-reset/)\r\n- [Inclusive Components](https://inclusive-components.design/)\r\n\r\n---\r\n\r\n**다음 포스트 예고**: JavaScript를 활용한 동적 폼 유효성 검사와 사용자 피드백 시스템 구현 🔧✨ "
    },
    {
      "id": "2024-05-23-github-blog-system",
      "title": "GitHub Pages + Markdown 블로그 시스템 구축",
      "date": "2024-05-23",
      "category": "tech",
      "tags": [
        "Git",
        "JavaScript",
        "CSS",
        "HTML",
        "Java",
        "프로젝트"
      ],
      "image": "https://images.unsplash.com/photo-1518432031352-d6fc5c10da5a?w=400&h=200&fit=crop",
      "description": "GitHub Pages + Markdown 블로그 시스템 구축에 대한 기술 포스트",
      "excerpt": "title: GitHub Pages + Markdown 블로그 시스템 구축\r",
      "content": "---\r\ntitle: GitHub Pages + Markdown 블로그 시스템 구축\r\ndate: 2024-05-23\r\ncategory: tech\r\ndescription: VSCode에서 마크다운 파일을 작성하고 GitHub에 푸시하면 자동으로 블로그에 반영되는 시스템 구현 과정\r\n---\r\n\r\n# GitHub Pages + Markdown 블로그 시스템 구축\r\n\r\n안녕하세요! 오늘은 VSCode에서 마크다운으로 글을 작성하고, GitHub에 커밋하면 자동으로 블로그에 반영되는 시스템을 구축한 과정을 공유하려고 합니다.\r\n\r\n## 🎯 목표\r\n\r\n- **VSCode에서 마크다운 작성**: 익숙한 에디터에서 편리하게 글쓰기\r\n- **GitHub 자동 연동**: 커밋/푸시만으로 블로그 업데이트\r\n- **실시간 반영**: GitHub API를 통한 즉시 동기화\r\n- **잔디 채우기**: 꾸준한 포스팅으로 GitHub 활동 기록\r\n\r\n## 🔧 기술 스택\r\n\r\n- **Frontend**: HTML5, CSS3, JavaScript (ES6+)\r\n- **API**: GitHub REST API v3\r\n- **인증**: Personal Access Token\r\n- **스타일**: macOS 네이티브 디자인\r\n\r\n## 📁 프로젝트 구조\r\n\r\n```\r\nstylechoi.github.io/\r\n├── posts/\r\n│   ├── tech/           # 기술 블로그\r\n│   └── daily/          # 일상 블로그\r\n├── css/\r\n├── js/\r\n├── image/\r\n└── index.html\r\n```\r\n\r\n## 🚀 주요 기능\r\n\r\n### 1. GitHub API 연동\r\n\r\n```javascript\r\nasync fetchMarkdownFiles(path) {\r\n    const response = await fetch(`https://api.github.com/repos/${this.repoOwner}/${this.repoName}/contents/${path}`, {\r\n        headers: {\r\n            'Authorization': `token ${this.githubToken}`,\r\n            'Accept': 'application/vnd.github.v3+json'\r\n        }\r\n    });\r\n    // ...\r\n}\r\n```\r\n\r\n### 2. Front Matter 파싱\r\n\r\n```yaml\r\n---\r\ntitle: 포스트 제목\r\ndate: 2024-05-23\r\ncategory: tech\r\ndescription: 포스트 설명\r\n---\r\n```\r\n\r\n### 3. 실시간 에디터\r\n\r\n- **VSCode 스타일 인터페이스**\r\n- **마크다운 실시간 미리보기**\r\n- **자동 저장 및 커밋**\r\n\r\n## 💡 워크플로우\r\n\r\n1. **폴더 클릭** → 기술/일상 vlog 선택\r\n2. **새 포스트 작성** → VSCode 스타일 에디터 열림\r\n3. **마크다운 작성** → 실시간 미리보기 지원\r\n4. **저장 & 커밋** → 자동으로 GitHub에 푸시\r\n5. **즉시 반영** → 블로그 목록에 새 글 표시\r\n\r\n## 🎨 디자인 특징\r\n\r\n### macOS 네이티브 스타일\r\n- **Dock 애니메이션**: 호버 시 magnification 효과\r\n- **윈도우 시스템**: 드래그, 리사이즈 가능한 창\r\n- **메뉴바**: 실제 macOS와 동일한 디자인\r\n\r\n### 반응형 디자인\r\n- 데스크톱과 모바일 모두 최적화\r\n- 터치 친화적 인터페이스\r\n\r\n## 🔐 보안\r\n\r\n- **Personal Access Token**: 로컬 저장소에만 보관\r\n- **HTTPS 통신**: 모든 API 요청 암호화\r\n- **권한 최소화**: 필요한 repo 권한만 요청\r\n\r\n## 📈 향후 계획\r\n\r\n- [ ] **Webhook 연동**: 실시간 알림 시스템\r\n- [ ] **댓글 시스템**: GitHub Issues 기반\r\n- [ ] **검색 기능**: 포스트 내용 검색\r\n- [ ] **태그 시스템**: 카테고리별 분류\r\n- [ ] **RSS 피드**: 구독자를 위한 피드 제공\r\n\r\n## 🎉 마무리\r\n\r\n이제 VSCode에서 편리하게 블로그를 작성하고, GitHub 잔디도 채울 수 있게 되었습니다! \r\n\r\n마크다운의 강력함과 GitHub의 버전 관리 기능을 활용해서 더욱 체계적으로 블로그를 운영할 수 있을 것 같습니다.\r\n\r\n---\r\n\r\n**다음 포스트 예고**: macOS 스타일 웹 인터페이스 구현 상세 가이드 📱✨"
    }
  ]
}