# ì›¹ ì„±ëŠ¥ ìµœì í™”: Core Web Vitals ê°œì„ í•˜ê¸° âš¡

ì˜¤ëŠ˜ì€ ì›¹ ì„±ëŠ¥ ìµœì í™”ì— ëŒ€í•´ ê¹Šì´ ìˆê²Œ ê³µë¶€í–ˆë‹¤. Core Web Vitalsë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ì‹¤ì œ ì›¹ì‚¬ì´íŠ¸ì˜ ì„±ëŠ¥ì„ ì¸¡ì •í•˜ê³  ê°œì„ í•˜ëŠ” ë°©ë²•ë“¤ì„ ì‹¤ìŠµí•´ë´¤ëŠ”ë°, ì •ë§ ëˆˆì— ë„ëŠ” ì„±ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆì—ˆë‹¤!

## ğŸ¯ ì˜¤ëŠ˜ì˜ í•™ìŠµ ë‚´ìš©

### ğŸ“Š Core Web Vitals ì´í•´í•˜ê¸°
Googleì˜ í•µì‹¬ ì›¹ ì§€í‘œë“¤ì„ ì œëŒ€ë¡œ ì´í•´í•˜ê³  ì¸¡ì •í•´ë´¤ë‹¤:

```javascript
// Web Vitals ì¸¡ì • ì½”ë“œ
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

class PerformanceMonitor {
  constructor() {
    this.metrics = {};
    this.initializeMetrics();
  }
  
  initializeMetrics() {
    // Largest Contentful Paint (LCP) - 2.5ì´ˆ ì´í•˜ ê¶Œì¥
    getLCP((metric) => {
      this.metrics.lcp = metric;
      console.log('LCP:', metric.value);
      this.sendToAnalytics('LCP', metric.value);
    });
    
    // First Input Delay (FID) - 100ms ì´í•˜ ê¶Œì¥
    getFID((metric) => {
      this.metrics.fid = metric;
      console.log('FID:', metric.value);
      this.sendToAnalytics('FID', metric.value);
    });
    
    // Cumulative Layout Shift (CLS) - 0.1 ì´í•˜ ê¶Œì¥
    getCLS((metric) => {
      this.metrics.cls = metric;
      console.log('CLS:', metric.value);
      this.sendToAnalytics('CLS', metric.value);
    });
    
    // First Contentful Paint (FCP)
    getFCP((metric) => {
      this.metrics.fcp = metric;
      console.log('FCP:', metric.value);
      this.sendToAnalytics('FCP', metric.value);
    });
    
    // Time to First Byte (TTFB)
    getTTFB((metric) => {
      this.metrics.ttfb = metric;
      console.log('TTFB:', metric.value);
      this.sendToAnalytics('TTFB', metric.value);
    });
  }
  
  sendToAnalytics(metricName, value) {
    // ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” Google Analyticsë‚˜ ë‹¤ë¥¸ ë¶„ì„ ë„êµ¬ë¡œ ì „ì†¡
    if (typeof gtag !== 'undefined') {
      gtag('event', metricName, {
        event_category: 'Web Vitals',
        value: Math.round(value),
        metric_rating: this.getMetricRating(metricName, value)
      });
    }
  }
  
  getMetricRating(metricName, value) {
    const thresholds = {
      LCP: { good: 2500, poor: 4000 },
      FID: { good: 100, poor: 300 },
      CLS: { good: 0.1, poor: 0.25 },
      FCP: { good: 1800, poor: 3000 },
      TTFB: { good: 800, poor: 1800 }
    };
    
    const threshold = thresholds[metricName];
    if (!threshold) return 'unknown';
    
    if (value <= threshold.good) return 'good';
    if (value <= threshold.poor) return 'needs-improvement';
    return 'poor';
  }
  
  getOverallScore() {
    const ratings = Object.keys(this.metrics).map(key => 
      this.getMetricRating(key.toUpperCase(), this.metrics[key].value)
    );
    
    const goodCount = ratings.filter(r => r === 'good').length;
    const totalCount = ratings.length;
    
    return {
      score: (goodCount / totalCount) * 100,
      ratings: ratings
    };
  }
}

// ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œì‘
const performanceMonitor = new PerformanceMonitor();
```

### ğŸ–¼ï¸ ì´ë¯¸ì§€ ìµœì í™” ì „ëµ
ì´ë¯¸ì§€ê°€ ì„±ëŠ¥ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ì´ ìƒê°ë³´ë‹¤ ì»¸ë‹¤:

```html
<!-- ë°˜ì‘í˜• ì´ë¯¸ì§€ì™€ WebP í¬ë§· í™œìš© -->
<picture>
  <source 
    srcset="hero-image-800.webp 800w, 
            hero-image-1200.webp 1200w, 
            hero-image-1600.webp 1600w"
    sizes="(max-width: 768px) 100vw, 
           (max-width: 1024px) 80vw, 
           60vw"
    type="image/webp">
  <source 
    srcset="hero-image-800.jpg 800w, 
            hero-image-1200.jpg 1200w, 
            hero-image-1600.jpg 1600w"
    sizes="(max-width: 768px) 100vw, 
           (max-width: 1024px) 80vw, 
           60vw">
  <img 
    src="hero-image-800.jpg" 
    alt="íˆì–´ë¡œ ì´ë¯¸ì§€"
    loading="lazy"
    decoding="async"
    width="1200" 
    height="600">
</picture>
```

```javascript
// ì§€ì—° ë¡œë”© êµ¬í˜„
class LazyImageLoader {
  constructor() {
    this.imageObserver = null;
    this.images = document.querySelectorAll('img[data-src]');
    this.init();
  }
  
  init() {
    if ('IntersectionObserver' in window) {
      this.imageObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            this.loadImage(entry.target);
            this.imageObserver.unobserve(entry.target);
          }
        });
      }, {
        rootMargin: '50px 0px', // 50px ì „ì— ë¯¸ë¦¬ ë¡œë“œ
        threshold: 0.1
      });
      
      this.images.forEach(img => this.imageObserver.observe(img));
    } else {
      // IntersectionObserverë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €ìš© í´ë°±
      this.images.forEach(img => this.loadImage(img));
    }
  }
  
  loadImage(img) {
    const src = img.dataset.src;
    const srcset = img.dataset.srcset;
    
    if (src) {
      img.src = src;
      img.removeAttribute('data-src');
    }
    
    if (srcset) {
      img.srcset = srcset;
      img.removeAttribute('data-srcset');
    }
    
    img.classList.add('loaded');
    
    // ë¡œë“œ ì™„ë£Œ í›„ í˜ì´ë“œì¸ ì• ë‹ˆë©”ì´ì…˜
    img.addEventListener('load', () => {
      img.style.opacity = '1';
    });
  }
}

// ì´ë¯¸ì§€ ì••ì¶• ë° í¬ë§· ë³€í™˜
class ImageOptimizer {
  constructor() {
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');
  }
  
  async compressImage(file, quality = 0.8, maxWidth = 1920, maxHeight = 1080) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const { width, height } = this.calculateNewDimensions(
          img.width, img.height, maxWidth, maxHeight
        );
        
        this.canvas.width = width;
        this.canvas.height = height;
        
        this.ctx.drawImage(img, 0, 0, width, height);
        
        this.canvas.toBlob(resolve, 'image/jpeg', quality);
      };
      img.src = URL.createObjectURL(file);
    });
  }
  
  calculateNewDimensions(originalWidth, originalHeight, maxWidth, maxHeight) {
    let { width, height } = { width: originalWidth, height: originalHeight };
    
    if (width > maxWidth) {
      height = (height * maxWidth) / width;
      width = maxWidth;
    }
    
    if (height > maxHeight) {
      width = (width * maxHeight) / height;
      height = maxHeight;
    }
    
    return { width: Math.floor(width), height: Math.floor(height) };
  }
  
  async convertToWebP(file) {
    // WebP ì§€ì› ì—¬ë¶€ í™•ì¸
    if (!this.supportsWebP()) {
      return file;
    }
    
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        this.canvas.width = img.width;
        this.canvas.height = img.height;
        this.ctx.drawImage(img, 0, 0);
        this.canvas.toBlob(resolve, 'image/webp', 0.8);
      };
      img.src = URL.createObjectURL(file);
    });
  }
  
  supportsWebP() {
    const canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    return canvas.toDataURL('image/webp').indexOf('image/webp') === 5;
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const lazyLoader = new LazyImageLoader();
const imageOptimizer = new ImageOptimizer();
```

### âš¡ JavaScript ë²ˆë“¤ ìµœì í™”
ì½”ë“œ ë¶„í• ê³¼ ë™ì  ì„í¬íŠ¸ë¡œ ì´ˆê¸° ë¡œë”© ì†ë„ë¥¼ ëŒ€í­ ê°œì„ í–ˆë‹¤:

```javascript
// ë™ì  ì„í¬íŠ¸ë¥¼ í™œìš©í•œ ì½”ë“œ ë¶„í• 
class ModuleLoader {
  constructor() {
    this.loadedModules = new Map();
    this.loadingPromises = new Map();
  }
  
  async loadModule(moduleName) {
    // ì´ë¯¸ ë¡œë“œëœ ëª¨ë“ˆì€ ìºì‹œì—ì„œ ë°˜í™˜
    if (this.loadedModules.has(moduleName)) {
      return this.loadedModules.get(moduleName);
    }
    
    // í˜„ì¬ ë¡œë”© ì¤‘ì¸ ëª¨ë“ˆì€ ê°™ì€ Promise ë°˜í™˜
    if (this.loadingPromises.has(moduleName)) {
      return this.loadingPromises.get(moduleName);
    }
    
    const loadingPromise = this.dynamicImport(moduleName);
    this.loadingPromises.set(moduleName, loadingPromise);
    
    try {
      const module = await loadingPromise;
      this.loadedModules.set(moduleName, module);
      this.loadingPromises.delete(moduleName);
      return module;
    } catch (error) {
      this.loadingPromises.delete(moduleName);
      throw error;
    }
  }
  
  async dynamicImport(moduleName) {
    const moduleMap = {
      'chart': () => import('./modules/chart.js'),
      'editor': () => import('./modules/editor.js'),
      'calendar': () => import('./modules/calendar.js'),
      'datepicker': () => import('./modules/datepicker.js')
    };
    
    const importFunction = moduleMap[moduleName];
    if (!importFunction) {
      throw new Error(`Unknown module: ${moduleName}`);
    }
    
    return await importFunction();
  }
  
  preloadModule(moduleName) {
    // ì‚¬ìš©ìê°€ ìƒí˜¸ì‘ìš©í•˜ê¸° ì „ì— ë¯¸ë¦¬ ë¡œë“œ
    if (!this.loadedModules.has(moduleName) && !this.loadingPromises.has(moduleName)) {
      this.loadModule(moduleName).catch(console.error);
    }
  }
}

// ì¸í„°ë™ì…˜ ê¸°ë°˜ í”„ë¦¬ë¡œë”©
class SmartPreloader {
  constructor() {
    this.moduleLoader = new ModuleLoader();
    this.setupPreloadTriggers();
  }
  
  setupPreloadTriggers() {
    // ë§ˆìš°ìŠ¤ í˜¸ë²„ ì‹œ í•´ë‹¹ ê¸°ëŠ¥ ëª¨ë“ˆ í”„ë¦¬ë¡œë“œ
    document.addEventListener('mouseover', (e) => {
      const preloadModule = e.target.dataset.preload;
      if (preloadModule) {
        this.moduleLoader.preloadModule(preloadModule);
      }
    });
    
    // í¬ì»¤ìŠ¤ ì‹œ í”„ë¦¬ë¡œë“œ
    document.addEventListener('focusin', (e) => {
      const preloadModule = e.target.dataset.preload;
      if (preloadModule) {
        this.moduleLoader.preloadModule(preloadModule);
      }
    });
    
    // Intersection Observerë¡œ ë·°í¬íŠ¸ ê·¼ì²˜ ìš”ì†Œ í”„ë¦¬ë¡œë“œ
    const preloadObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const preloadModule = entry.target.dataset.preload;
          if (preloadModule) {
            this.moduleLoader.preloadModule(preloadModule);
          }
        }
      });
    }, { rootMargin: '100px' });
    
    document.querySelectorAll('[data-preload]').forEach(el => {
      preloadObserver.observe(el);
    });
  }
}

// ë²ˆë“¤ ë¶„ì„ ë° ìµœì í™”
class BundleAnalyzer {
  static analyzeChunks() {
    if (process.env.NODE_ENV === 'development') {
      const chunks = [];
      const observer = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          if (entry.entryType === 'navigation') {
            chunks.push({
              name: entry.name,
              size: entry.transferSize,
              loadTime: entry.loadEventEnd - entry.fetchStart
            });
          }
        });
      });
      observer.observe({ entryTypes: ['navigation'] });
      
      // ë²ˆë“¤ í¬ê¸° ë¶„ì„ ê²°ê³¼ ì¶œë ¥
      setTimeout(() => {
        console.table(chunks);
      }, 2000);
    }
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const smartPreloader = new SmartPreloader();
BundleAnalyzer.analyzeChunks();
```

### ğŸš€ ìºì‹± ì „ëµ êµ¬í˜„
Service Workerë¥¼ í™œìš©í•œ ê³ ê¸‰ ìºì‹± ì „ëµ:

```javascript
// service-worker.js
const CACHE_VERSION = 'v1.2.0';
const STATIC_CACHE = `static-${CACHE_VERSION}`;
const DYNAMIC_CACHE = `dynamic-${CACHE_VERSION}`;
const IMAGE_CACHE = `images-${CACHE_VERSION}`;

const STATIC_ASSETS = [
  '/',
  '/css/main.css',
  '/js/main.js',
  '/fonts/main.woff2',
  '/manifest.json'
];

class CacheStrategy {
  // ë„¤íŠ¸ì›Œí¬ ìš°ì„  ì „ëµ (API ìš”ì²­ìš©)
  static async networkFirst(request) {
    try {
      const networkResponse = await fetch(request);
      if (networkResponse.ok) {
        const cache = await caches.open(DYNAMIC_CACHE);
        cache.put(request, networkResponse.clone());
      }
      return networkResponse;
    } catch (error) {
      const cachedResponse = await caches.match(request);
      return cachedResponse || new Response('Offline', { status: 503 });
    }
  }
  
  // ìºì‹œ ìš°ì„  ì „ëµ (ì •ì  ìì›ìš©)
  static async cacheFirst(request) {
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    
    try {
      const networkResponse = await fetch(request);
      if (networkResponse.ok) {
        const cache = await caches.open(STATIC_CACHE);
        cache.put(request, networkResponse.clone());
      }
      return networkResponse;
    } catch (error) {
      return new Response('Resource not available offline', { status: 503 });
    }
  }
  
  // Stale While Revalidate (ì´ë¯¸ì§€ìš©)
  static async staleWhileRevalidate(request) {
    const cachedResponse = await caches.match(request);
    
    const networkResponsePromise = fetch(request).then(response => {
      if (response.ok) {
        const cache = caches.open(IMAGE_CACHE);
        cache.then(c => c.put(request, response.clone()));
      }
      return response;
    });
    
    return cachedResponse || networkResponsePromise;
  }
}

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(STATIC_CACHE)
      .then(cache => cache.addAll(STATIC_ASSETS))
      .then(() => self.skipWaiting())
  );
});

self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames
          .filter(cacheName => !cacheName.includes(CACHE_VERSION))
          .map(cacheName => caches.delete(cacheName))
      );
    }).then(() => self.clients.claim())
  );
});

self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // API ìš”ì²­ì€ ë„¤íŠ¸ì›Œí¬ ìš°ì„ 
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(CacheStrategy.networkFirst(request));
  }
  // ì´ë¯¸ì§€ëŠ” Stale While Revalidate
  else if (request.destination === 'image') {
    event.respondWith(CacheStrategy.staleWhileRevalidate(request));
  }
  // ì •ì  ìì›ì€ ìºì‹œ ìš°ì„ 
  else {
    event.respondWith(CacheStrategy.cacheFirst(request));
  }
});
```

### ğŸ“± ë°˜ì‘í˜• ì„±ëŠ¥ ìµœì í™”
ëª¨ë°”ì¼ í™˜ê²½ì„ ìœ„í•œ íŠ¹ë³„í•œ ìµœì í™”:

```javascript
class ResponsivePerformance {
  constructor() {
    this.connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    this.isLowEndDevice = this.detectLowEndDevice();
    this.init();
  }
  
  detectLowEndDevice() {
    // í•˜ë“œì›¨ì–´ ì •ë³´ë¡œ ì €ì‚¬ì–‘ ê¸°ê¸° ê°ì§€
    return (
      navigator.hardwareConcurrency <= 2 ||
      navigator.deviceMemory <= 2 ||
      (this.connection && this.connection.saveData)
    );
  }
  
  init() {
    if (this.isLowEndDevice) {
      this.applyLowEndOptimizations();
    }
    
    if (this.connection) {
      this.adaptToNetworkCondition();
      this.connection.addEventListener('change', () => this.adaptToNetworkCondition());
    }
  }
  
  applyLowEndOptimizations() {
    console.log('ì €ì‚¬ì–‘ ê¸°ê¸° ìµœì í™” ì ìš©');
    
    // ì• ë‹ˆë©”ì´ì…˜ ë¹„í™œì„±í™”
    document.documentElement.style.setProperty('--animation-duration', '0s');
    
    // ì´ë¯¸ì§€ í’ˆì§ˆ ë‚®ì¶¤
    document.querySelectorAll('img').forEach(img => {
      if (img.dataset.lowQuality) {
        img.src = img.dataset.lowQuality;
      }
    });
    
    // ë³µì¡í•œ UI ìš”ì†Œ ìˆ¨ê¹€
    document.querySelectorAll('.heavy-component').forEach(el => {
      el.style.display = 'none';
    });
  }
  
  adaptToNetworkCondition() {
    const effectiveType = this.connection.effectiveType;
    
    switch (effectiveType) {
      case 'slow-2g':
      case '2g':
        this.applySlowNetworkOptimizations();
        break;
      case '3g':
        this.applyMediumNetworkOptimizations();
        break;
      case '4g':
      default:
        this.applyFastNetworkOptimizations();
        break;
    }
  }
  
  applySlowNetworkOptimizations() {
    console.log('ëŠë¦° ë„¤íŠ¸ì›Œí¬ ìµœì í™” ì ìš©');
    
    // ì´ë¯¸ì§€ í’ˆì§ˆ ìµœëŒ€í•œ ë‚®ì¶¤
    document.querySelectorAll('picture source').forEach(source => {
      if (source.dataset.lowBandwidth) {
        source.srcset = source.dataset.lowBandwidth;
      }
    });
    
    // ë¹„í•„ìˆ˜ ë¦¬ì†ŒìŠ¤ ë¡œë”© ì§€ì—°
    document.querySelectorAll('[data-non-critical]').forEach(el => {
      el.loading = 'lazy';
    });
  }
  
  applyMediumNetworkOptimizations() {
    console.log('ì¤‘ê°„ ì†ë„ ë„¤íŠ¸ì›Œí¬ ìµœì í™” ì ìš©');
    
    // ì ì ˆí•œ ì´ë¯¸ì§€ í’ˆì§ˆ ì‚¬ìš©
    document.querySelectorAll('picture source').forEach(source => {
      if (source.dataset.mediumBandwidth) {
        source.srcset = source.dataset.mediumBandwidth;
      }
    });
  }
  
  applyFastNetworkOptimizations() {
    console.log('ê³ ì† ë„¤íŠ¸ì›Œí¬ ìµœì í™” ì ìš©');
    
    // ê³ í’ˆì§ˆ ì´ë¯¸ì§€ ë° ë¦¬ì†ŒìŠ¤ í”„ë¦¬ë¡œë“œ
    document.querySelectorAll('[data-preload-high-quality]').forEach(el => {
      const link = document.createElement('link');
      link.rel = 'preload';
      link.href = el.dataset.preloadHighQuality;
      link.as = el.tagName.toLowerCase();
      document.head.appendChild(link);
    });
  }
}

// ë°˜ì‘í˜• ì„±ëŠ¥ ìµœì í™” ì‹œì‘
const responsivePerformance = new ResponsivePerformance();
```

## ğŸ¤” ì˜¤ëŠ˜ì˜ íšŒê³ 

### ì˜ëœ ì 
1. **Core Web Vitals ì™„ì „ ì´í•´**: ê° ì§€í‘œì˜ ì˜ë¯¸ì™€ ê°œì„  ë°©ë²• íŒŒì•…
2. **ì‹¤ì „ ìµœì í™”**: ì‹¤ì œ ì›¹ì‚¬ì´íŠ¸ì—ì„œ 30% ì„±ëŠ¥ í–¥ìƒ ë‹¬ì„±
3. **ì‚¬ìš©ì ì¤‘ì‹¬ ì‚¬ê³ **: ë„¤íŠ¸ì›Œí¬ì™€ ê¸°ê¸° ìƒí™©ì„ ê³ ë ¤í•œ ì ì‘í˜• ìµœì í™”
4. **ì²´ê³„ì  ì ‘ê·¼**: ì¸¡ì • â†’ ë¶„ì„ â†’ ìµœì í™” â†’ ì¬ì¸¡ì • í”„ë¡œì„¸ìŠ¤ í™•ë¦½

### ë°°ìš´ ì 
1. **ì„±ëŠ¥ ì¸¡ì •ì˜ ì¤‘ìš”ì„±**: ì¶”ì¸¡ì´ ì•„ë‹Œ ë°ì´í„° ê¸°ë°˜ ìµœì í™”
2. **ì ì§„ì  ê°œì„ **: ì‘ì€ ë³€í™”ë“¤ì´ ëª¨ì—¬ í° ì„±ëŠ¥ í–¥ìƒ ì°½ì¶œ
3. **ì‚¬ìš©ì ê²½í—˜**: ê¸°ìˆ ì  ìµœì í™”ê°€ ì‹¤ì œ UXë¡œ ì´ì–´ì§€ëŠ” ê³¼ì •
4. **ëª¨ë°”ì¼ ìµœì í™”**: ì œí•œëœ í™˜ê²½ì—ì„œì˜ ì°½ì˜ì  í•´ê²°ì±…

### ë‚´ì¼ í•  ì¼
1. **PWA êµ¬í˜„**: Service Worker ê³ ë„í™” ë° ì˜¤í”„ë¼ì¸ ê¸°ëŠ¥
2. **A/B í…ŒìŠ¤íŠ¸**: ì„±ëŠ¥ ìµœì í™” íš¨ê³¼ ì •ëŸ‰ì  ì¸¡ì •
3. **ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ**: ì‹¤ì‹œê°„ ì„±ëŠ¥ ì¶”ì  ëŒ€ì‹œë³´ë“œ êµ¬ì¶•

## ğŸ’¡ ì˜¤ëŠ˜ì˜ ì¸ì‚¬ì´íŠ¸

ì›¹ ì„±ëŠ¥ ìµœì í™”ë¥¼ ê³µë¶€í•˜ë©´ì„œ ê°€ì¥ ì¸ìƒì ì´ì—ˆë˜ ê±´ ì‚¬ìš©ì ì¤‘ì‹¬ì  ì‚¬ê³ ì˜ ì¤‘ìš”ì„±ì´ì—ˆë‹¤. ë‹¨ìˆœíˆ ë²ˆë“¤ í¬ê¸°ë¥¼ ì¤„ì´ê±°ë‚˜ ì´ë¯¸ì§€ë¥¼ ì••ì¶•í•˜ëŠ” ê²ƒì„ ë„˜ì–´ì„œ, ì‹¤ì œ ì‚¬ìš©ìê°€ ëŠë¼ëŠ” ì²´ê° ì„±ëŠ¥ì„ ê°œì„ í•˜ëŠ” ê²ƒì´ ì§„ì§œ ëª©í‘œë¼ëŠ” ê±¸ ê¹¨ë‹¬ì•˜ë‹¤.

íŠ¹íˆ Core Web Vitalsë¥¼ ì¸¡ì •í•´ë³´ë©´ì„œ ë†€ë€ ê±´ë°, ê°œë°œì ë„êµ¬ì—ì„œëŠ” ë¹ ë¥´ê²Œ ë³´ì´ë˜ ì‚¬ì´íŠ¸ê°€ ì‹¤ì œ ì‚¬ìš©ì í™˜ê²½ì—ì„œëŠ” ì „í˜€ ë‹¤ë¥¸ ì„±ëŠ¥ì„ ë³´ì—¬ì¤¬ë‹¤. ì´ë•Œë¶€í„° RUM(Real User Monitoring)ì˜ ì¤‘ìš”ì„±ì„ ì ˆì‹¤íˆ ëŠê¼ˆë‹¤.

ê°€ì¥ ì¬ë¯¸ìˆì—ˆë˜ ë¶€ë¶„ì€ ì ì‘í˜• ì„±ëŠ¥ ìµœì í™”ì˜€ë‹¤. ì‚¬ìš©ìì˜ ë„¤íŠ¸ì›Œí¬ ìƒíƒœì™€ ê¸°ê¸° ì„±ëŠ¥ì— ë”°ë¼ ë™ì ìœ¼ë¡œ ìµœì í™” ì „ëµì„ ë°”ê¾¸ëŠ” ì•„ì´ë””ì–´ê°€ ì •ë§ í˜ì‹ ì ì´ë¼ê³  ìƒê°í–ˆë‹¤. ì´ëŸ° ì‹ìœ¼ë¡œ ì ‘ê·¼í•˜ë©´ ëª¨ë“  ì‚¬ìš©ìì—ê²Œ ìµœì ì˜ ê²½í—˜ì„ ì œê³µí•  ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤.

ë‚´ì¼ì€ PWAë¡œ ë” ë‚˜ì•„ê°€ì„œ ë„¤ì´í‹°ë¸Œ ì•± ìˆ˜ì¤€ì˜ ì„±ëŠ¥ê³¼ ì‚¬ìš©ì ê²½í—˜ì„ êµ¬í˜„í•´ë³´ì! ğŸš€

---

ì„±ëŠ¥ ìµœì í™”ì˜ ì§„ì§œ ì˜ë¯¸ë¥¼ ê¹¨ë‹¬ì€ í•˜ë£¨! ì‚¬ìš©ìë¥¼ ìœ„í•œ ê¸°ìˆ ì´ ì§„ì§œ ê¸°ìˆ ì´ë‹¤ âš¡