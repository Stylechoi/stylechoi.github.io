# Reactì™€ Context APIë¡œ ì „ì—­ ìƒíƒœ ê´€ë¦¬í•˜ê¸° ğŸ”„

ì˜¤ëŠ˜ì€ Reactì˜ Context APIë¥¼ ê¹Šì´ ìˆê²Œ ê³µë¶€í–ˆë‹¤. Redux ì—†ì´ë„ ê¹”ë”í•œ ì „ì—­ ìƒíƒœ ê´€ë¦¬ê°€ ê°€ëŠ¥í•˜ë‹¤ëŠ” ê±¸ ì§ì ‘ êµ¬í˜„í•´ë³´ë©´ì„œ ê¹¨ë‹¬ì•˜ë‹¤. íŠ¹íˆ ì—¬ëŸ¬ Contextë¥¼ ì¡°í•©í•´ì„œ ì‚¬ìš©í•˜ëŠ” íŒ¨í„´ì´ ì •ë§ ê°•ë ¥í–ˆë‹¤!

## ğŸ¯ ì˜¤ëŠ˜ì˜ í•™ìŠµ ë‚´ìš©

### ğŸ—‚ï¸ Context API ê¸°ë³¸ê¸° ì™„ì „ ì •ë³µ
React Contextì˜ ê¸°ë³¸ ê°œë…ë¶€í„° ê³ ê¸‰ íŒ¨í„´ê¹Œì§€:

```jsx
import React, { createContext, useContext, useReducer, useCallback, useEffect } from 'react';

// í…Œë§ˆ Context
const ThemeContext = createContext();

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};

export const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = React.useState(() => {
    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ í…Œë§ˆ ë³µì›
    const savedTheme = localStorage.getItem('theme');
    return savedTheme || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
  });
  
  const toggleTheme = useCallback(() => {
    setTheme(prevTheme => {
      const newTheme = prevTheme === 'light' ? 'dark' : 'light';
      localStorage.setItem('theme', newTheme);
      return newTheme;
    });
  }, []);
  
  const setSpecificTheme = useCallback((newTheme) => {
    setTheme(newTheme);
    localStorage.setItem('theme', newTheme);
  }, []);
  
  // ì‹œìŠ¤í…œ í…Œë§ˆ ë³€ê²½ ê°ì§€
  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    const handleChange = (e) => {
      if (!localStorage.getItem('theme')) {
        setTheme(e.matches ? 'dark' : 'light');
      }
    };
    
    mediaQuery.addListener(handleChange);
    return () => mediaQuery.removeListener(handleChange);
  }, []);
  
  const value = {
    theme,
    toggleTheme,
    setTheme: setSpecificTheme,
    isDark: theme === 'dark'
  };
  
  return (
    <ThemeContext.Provider value={value}>
      <div className={`app ${theme}-theme`}>
        {children}
      </div>
    </ThemeContext.Provider>
  );
};

// ì¸ì¦ Context
const AuthContext = createContext();

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

const authReducer = (state, action) => {
  switch (action.type) {
    case 'LOGIN_START':
      return { ...state, loading: true, error: null };
    case 'LOGIN_SUCCESS':
      return {
        ...state,
        loading: false,
        user: action.payload.user,
        token: action.payload.token,
        isAuthenticated: true,
        error: null
      };
    case 'LOGIN_FAILURE':
      return {
        ...state,
        loading: false,
        user: null,
        token: null,
        isAuthenticated: false,
        error: action.payload
      };
    case 'LOGOUT':
      return {
        ...state,
        user: null,
        token: null,
        isAuthenticated: false,
        error: null
      };
    case 'UPDATE_USER':
      return {
        ...state,
        user: { ...state.user, ...action.payload }
      };
    case 'CLEAR_ERROR':
      return { ...state, error: null };
    default:
      return state;
  }
};

export const AuthProvider = ({ children }) => {
  const [state, dispatch] = useReducer(authReducer, {
    user: null,
    token: localStorage.getItem('token'),
    isAuthenticated: false,
    loading: false,
    error: null
  });
  
  // í† í° ìœ íš¨ì„± ê²€ì¦
  useEffect(() => {
    if (state.token) {
      validateToken(state.token);
    }
  }, []);
  
  const validateToken = async (token) => {
    try {
      const response = await fetch('/api/auth/validate', {
        headers: { Authorization: `Bearer ${token}` }
      });
      
      if (response.ok) {
        const user = await response.json();
        dispatch({ 
          type: 'LOGIN_SUCCESS', 
          payload: { user: user.data, token } 
        });
      } else {
        localStorage.removeItem('token');
        dispatch({ type: 'LOGOUT' });
      }
    } catch (error) {
      localStorage.removeItem('token');
      dispatch({ type: 'LOGOUT' });
    }
  };
  
  const login = useCallback(async (credentials) => {
    dispatch({ type: 'LOGIN_START' });
    
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials)
      });
      
      const data = await response.json();
      
      if (response.ok) {
        localStorage.setItem('token', data.data.tokens.accessToken);
        dispatch({ 
          type: 'LOGIN_SUCCESS', 
          payload: { 
            user: data.data.user, 
            token: data.data.tokens.accessToken 
          } 
        });
        return { success: true };
      } else {
        dispatch({ type: 'LOGIN_FAILURE', payload: data.message });
        return { success: false, error: data.message };
      }
    } catch (error) {
      dispatch({ type: 'LOGIN_FAILURE', payload: 'Network error' });
      return { success: false, error: 'Network error' };
    }
  }, []);
  
  const logout = useCallback(() => {
    localStorage.removeItem('token');
    dispatch({ type: 'LOGOUT' });
  }, []);
  
  const updateUser = useCallback((userData) => {
    dispatch({ type: 'UPDATE_USER', payload: userData });
  }, []);
  
  const clearError = useCallback(() => {
    dispatch({ type: 'CLEAR_ERROR' });
  }, []);
  
  const value = {
    ...state,
    login,
    logout,
    updateUser,
    clearError
  };
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};
```

### ğŸ›’ ë³µì¡í•œ ìƒíƒœ ê´€ë¦¬: ì‡¼í•‘ì¹´íŠ¸ Context
ì‹¤ì œ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë³µì¡í•œ ìƒíƒœ ê´€ë¦¬ ì˜ˆì œ:

```jsx
// contexts/CartContext.js
import React, { createContext, useContext, useReducer, useCallback, useEffect } from 'react';

const CartContext = createContext();

export const useCart = () => {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error('useCart must be used within a CartProvider');
  }
  return context;
};

const cartReducer = (state, action) => {
  switch (action.type) {
    case 'LOAD_CART':
      return {
        ...state,
        items: action.payload,
        loading: false
      };
      
    case 'ADD_ITEM':
      const existingItemIndex = state.items.findIndex(
        item => item.id === action.payload.id && 
               JSON.stringify(item.options) === JSON.stringify(action.payload.options)
      );
      
      if (existingItemIndex > -1) {
        const updatedItems = [...state.items];
        updatedItems[existingItemIndex].quantity += action.payload.quantity || 1;
        return { ...state, items: updatedItems };
      } else {
        return {
          ...state,
          items: [...state.items, { ...action.payload, quantity: action.payload.quantity || 1 }]
        };
      }
      
    case 'REMOVE_ITEM':
      return {
        ...state,
        items: state.items.filter(item => 
          !(item.id === action.payload.id && 
            JSON.stringify(item.options) === JSON.stringify(action.payload.options))
        )
      };
      
    case 'UPDATE_QUANTITY':
      return {
        ...state,
        items: state.items.map(item =>
          item.id === action.payload.id && 
          JSON.stringify(item.options) === JSON.stringify(action.payload.options)
            ? { ...item, quantity: Math.max(0, action.payload.quantity) }
            : item
        ).filter(item => item.quantity > 0)
      };
      
    case 'CLEAR_CART':
      return { ...state, items: [] };
      
    case 'APPLY_DISCOUNT':
      return {
        ...state,
        discount: action.payload
      };
      
    case 'SET_SHIPPING':
      return {
        ...state,
        shipping: action.payload
      };
      
    default:
      return state;
  }
};

export const CartProvider = ({ children }) => {
  const [state, dispatch] = useReducer(cartReducer, {
    items: [],
    discount: null,
    shipping: null,
    loading: true
  });
  
  // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì™€ ë™ê¸°í™”
  useEffect(() => {
    const savedCart = localStorage.getItem('cart');
    if (savedCart) {
      try {
        const parsedCart = JSON.parse(savedCart);
        dispatch({ type: 'LOAD_CART', payload: parsedCart.items || [] });
      } catch (error) {
        console.error('Error parsing saved cart:', error);
        dispatch({ type: 'LOAD_CART', payload: [] });
      }
    } else {
      dispatch({ type: 'LOAD_CART', payload: [] });
    }
  }, []);
  
  useEffect(() => {
    if (!state.loading) {
      localStorage.setItem('cart', JSON.stringify({
        items: state.items,
        timestamp: Date.now()
      }));
    }
  }, [state.items, state.loading]);
  
  // ê³„ì‚°ëœ ê°’ë“¤
  const totalItems = state.items.reduce((sum, item) => sum + item.quantity, 0);
  
  const subtotal = state.items.reduce((sum, item) => 
    sum + (item.price * item.quantity), 0
  );
  
  const discountAmount = state.discount 
    ? (state.discount.type === 'percentage' 
        ? subtotal * (state.discount.value / 100)
        : state.discount.value)
    : 0;
  
  const shippingCost = state.shipping ? state.shipping.cost : 0;
  
  const total = subtotal - discountAmount + shippingCost;
  
  // ì•¡ì…˜ í•¨ìˆ˜ë“¤
  const addItem = useCallback((product, options = {}, quantity = 1) => {
    dispatch({
      type: 'ADD_ITEM',
      payload: {
        id: product.id,
        name: product.name,
        price: product.price,
        image: product.image,
        options,
        quantity
      }
    });
  }, []);
  
  const removeItem = useCallback((productId, options = {}) => {
    dispatch({
      type: 'REMOVE_ITEM',
      payload: { id: productId, options }
    });
  }, []);
  
  const updateQuantity = useCallback((productId, options = {}, quantity) => {
    dispatch({
      type: 'UPDATE_QUANTITY',
      payload: { id: productId, options, quantity }
    });
  }, []);
  
  const clearCart = useCallback(() => {
    dispatch({ type: 'CLEAR_CART' });
  }, []);
  
  const applyDiscount = useCallback((discount) => {
    dispatch({ type: 'APPLY_DISCOUNT', payload: discount });
  }, []);
  
  const setShipping = useCallback((shipping) => {
    dispatch({ type: 'SET_SHIPPING', payload: shipping });
  }, []);
  
  const getItemCount = useCallback((productId, options = {}) => {
    const item = state.items.find(item => 
      item.id === productId && 
      JSON.stringify(item.options) === JSON.stringify(options)
    );
    return item ? item.quantity : 0;
  }, [state.items]);
  
  const isInCart = useCallback((productId, options = {}) => {
    return getItemCount(productId, options) > 0;
  }, [getItemCount]);
  
  const value = {
    items: state.items,
    discount: state.discount,
    shipping: state.shipping,
    loading: state.loading,
    totalItems,
    subtotal,
    discountAmount,
    shippingCost,
    total,
    addItem,
    removeItem,
    updateQuantity,
    clearCart,
    applyDiscount,
    setShipping,
    getItemCount,
    isInCart
  };
  
  return (
    <CartContext.Provider value={value}>
      {children}
    </CartContext.Provider>
  );
};

// Cart ì»´í¬ë„ŒíŠ¸ ì‚¬ìš© ì˜ˆì‹œ
const CartSummary = () => {
  const { 
    items, 
    totalItems, 
    subtotal, 
    discountAmount, 
    shippingCost, 
    total, 
    updateQuantity, 
    removeItem 
  } = useCart();
  
  const { theme } = useTheme();
  
  if (items.length === 0) {
    return (
      <div className="cart-empty">
        <h3>ì¥ë°”êµ¬ë‹ˆê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤</h3>
        <p>ì‡¼í•‘ì„ ê³„ì†í•´ë³´ì„¸ìš”!</p>
      </div>
    );
  }
  
  return (
    <div className={`cart-summary ${theme}`}>
      <h2>ì¥ë°”êµ¬ë‹ˆ ({totalItems}ê°œ ìƒí’ˆ)</h2>
      
      <div className="cart-items">
        {items.map((item, index) => (
          <div key={`${item.id}-${index}`} className="cart-item">
            <img src={item.image} alt={item.name} />
            <div className="item-details">
              <h4>{item.name}</h4>
              {Object.keys(item.options).length > 0 && (
                <div className="item-options">
                  {Object.entries(item.options).map(([key, value]) => (
                    <span key={key}>{key}: {value}</span>
                  ))}
                </div>
              )}
              <div className="item-price">
                {item.price.toLocaleString()}ì›
              </div>
            </div>
            <div className="quantity-controls">
              <button 
                onClick={() => updateQuantity(item.id, item.options, item.quantity - 1)}
                disabled={item.quantity <= 1}
              >
                -
              </button>
              <span>{item.quantity}</span>
              <button 
                onClick={() => updateQuantity(item.id, item.options, item.quantity + 1)}
              >
                +
              </button>
            </div>
            <div className="item-total">
              {(item.price * item.quantity).toLocaleString()}ì›
            </div>
            <button 
              className="remove-item"
              onClick={() => removeItem(item.id, item.options)}
            >
              ì‚­ì œ
            </button>
          </div>
        ))}
      </div>
      
      <div className="cart-totals">
        <div className="subtotal">
          ì†Œê³„: {subtotal.toLocaleString()}ì›
        </div>
        {discountAmount > 0 && (
          <div className="discount">
            í• ì¸: -{discountAmount.toLocaleString()}ì›
          </div>
        )}
        {shippingCost > 0 && (
          <div className="shipping">
            ë°°ì†¡ë¹„: {shippingCost.toLocaleString()}ì›
          </div>
        )}
        <div className="total">
          ì´ ê²°ì œê¸ˆì•¡: {total.toLocaleString()}ì›
        </div>
      </div>
    </div>
  );
};
```

### ğŸ”„ Context ì¡°í•©ê³¼ ì„±ëŠ¥ ìµœì í™”
ì—¬ëŸ¬ Contextë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì¡°í•©í•˜ëŠ” íŒ¨í„´:

```jsx
// contexts/AppProviders.js
import React from 'react';
import { ThemeProvider } from './ThemeContext';
import { AuthProvider } from './AuthContext';
import { CartProvider } from './CartContext';
import { NotificationProvider } from './NotificationContext';

// ëª¨ë“  Providerë¥¼ ì¡°í•©í•˜ëŠ” ì»´í¬ë„ŒíŠ¸
export const AppProviders = ({ children }) => {
  return (
    <ThemeProvider>
      <AuthProvider>
        <NotificationProvider>
          <CartProvider>
            {children}
          </CartProvider>
        </NotificationProvider>
      </AuthProvider>
    </ThemeProvider>
  );
};

// ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•œ Context ë¶„ë¦¬
const UserPreferencesContext = createContext();
const UserActionsContext = createContext();

export const useUserPreferences = () => {
  const context = useContext(UserPreferencesContext);
  if (!context) {
    throw new Error('useUserPreferences must be used within UserProvider');
  }
  return context;
};

export const useUserActions = () => {
  const context = useContext(UserActionsContext);
  if (!context) {
    throw new Error('useUserActions must be used within UserProvider');
  }
  return context;
};

export const UserProvider = ({ children }) => {
  const [preferences, setPreferences] = useState({
    language: 'ko',
    currency: 'KRW',
    timezone: 'Asia/Seoul',
    notifications: {
      email: true,
      push: false,
      sms: false
    }
  });
  
  // ì•¡ì…˜ë“¤ì€ ë³„ë„ Contextë¡œ ë¶„ë¦¬í•˜ì—¬ ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ ë°©ì§€
  const actions = useMemo(() => ({
    updateLanguage: (language) => {
      setPreferences(prev => ({ ...prev, language }));
    },
    updateCurrency: (currency) => {
      setPreferences(prev => ({ ...prev, currency }));
    },
    updateNotificationSettings: (notifications) => {
      setPreferences(prev => ({ 
        ...prev, 
        notifications: { ...prev.notifications, ...notifications }
      }));
    }
  }), []);
  
  return (
    <UserPreferencesContext.Provider value={preferences}>
      <UserActionsContext.Provider value={actions}>
        {children}
      </UserActionsContext.Provider>
    </UserPreferencesContext.Provider>
  );
};

// ê³ ì°¨ ì»´í¬ë„ŒíŠ¸ë¡œ Context ì£¼ì…
export const withAuth = (WrappedComponent) => {
  return React.forwardRef((props, ref) => {
    const auth = useAuth();
    
    if (!auth.isAuthenticated) {
      return <LoginPage />;
    }
    
    return <WrappedComponent {...props} ref={ref} auth={auth} />;
  });
};

// ì»¤ìŠ¤í…€ í›…ìœ¼ë¡œ ì—¬ëŸ¬ Context ì¡°í•©
export const useAppState = () => {
  const theme = useTheme();
  const auth = useAuth();
  const cart = useCart();
  const preferences = useUserPreferences();
  
  return {
    theme,
    auth,
    cart,
    preferences,
    isLoggedIn: auth.isAuthenticated,
    cartItemCount: cart.totalItems,
    isDarkMode: theme.isDark
  };
};

// Context ê°’ ë©”ëª¨ì´ì œì´ì…˜ìœ¼ë¡œ ì„±ëŠ¥ ìµœì í™”
export const OptimizedProvider = ({ children }) => {
  const [state, setState] = useState(initialState);
  
  const contextValue = useMemo(() => ({
    state,
    updateState: (newState) => setState(prev => ({ ...prev, ...newState })),
    resetState: () => setState(initialState)
  }), [state]);
  
  return (
    <SomeContext.Provider value={contextValue}>
      {children}
    </SomeContext.Provider>
  );
};
```

### ğŸ§ª Context API í…ŒìŠ¤íŒ…
Contextë¥¼ ì‚¬ìš©í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ì˜ í…ŒìŠ¤íŠ¸ ë°©ë²•:

```jsx
// __tests__/CartContext.test.js
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { CartProvider, useCart } from '../contexts/CartContext';

// í…ŒìŠ¤íŠ¸ìš© ì»´í¬ë„ŒíŠ¸
const TestComponent = () => {
  const { items, addItem, removeItem, totalItems, total } = useCart();
  
  const testProduct = {
    id: '1',
    name: 'Test Product',
    price: 10000,
    image: 'test.jpg'
  };
  
  return (
    <div>
      <div data-testid="total-items">{totalItems}</div>
      <div data-testid="total-price">{total}</div>
      <button onClick={() => addItem(testProduct)}>Add Item</button>
      <button onClick={() => removeItem('1')}>Remove Item</button>
      <div data-testid="items">
        {items.map(item => (
          <div key={item.id} data-testid={`item-${item.id}`}>
            {item.name} - {item.quantity}
          </div>
        ))}
      </div>
    </div>
  );
};

const renderWithProvider = (ui) => {
  return render(
    <CartProvider>
      {ui}
    </CartProvider>
  );
};

describe('CartContext', () => {
  beforeEach(() => {
    localStorage.clear();
  });
  
  test('ì´ˆê¸° ìƒíƒœê°€ ì˜¬ë°”ë¥¸ì§€ í™•ì¸', () => {
    renderWithProvider(<TestComponent />);
    
    expect(screen.getByTestId('total-items')).toHaveTextContent('0');
    expect(screen.getByTestId('total-price')).toHaveTextContent('0');
  });
  
  test('ìƒí’ˆ ì¶”ê°€ê°€ ì˜¬ë°”ë¥´ê²Œ ë™ì‘í•˜ëŠ”ì§€ í™•ì¸', () => {
    renderWithProvider(<TestComponent />);
    
    fireEvent.click(screen.getByText('Add Item'));
    
    expect(screen.getByTestId('total-items')).toHaveTextContent('1');
    expect(screen.getByTestId('total-price')).toHaveTextContent('10000');
    expect(screen.getByTestId('item-1')).toHaveTextContent('Test Product - 1');
  });
  
  test('ìƒí’ˆ ì œê±°ê°€ ì˜¬ë°”ë¥´ê²Œ ë™ì‘í•˜ëŠ”ì§€ í™•ì¸', async () => {
    renderWithProvider(<TestComponent />);
    
    // ìƒí’ˆ ì¶”ê°€ í›„ ì œê±°
    fireEvent.click(screen.getByText('Add Item'));
    fireEvent.click(screen.getByText('Remove Item'));
    
    await waitFor(() => {
      expect(screen.getByTestId('total-items')).toHaveTextContent('0');
    });
    
    expect(screen.queryByTestId('item-1')).not.toBeInTheDocument();
  });
  
  test('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ë™ê¸°í™”ê°€ ë™ì‘í•˜ëŠ”ì§€ í™•ì¸', () => {
    renderWithProvider(<TestComponent />);
    
    fireEvent.click(screen.getByText('Add Item'));
    
    const savedCart = JSON.parse(localStorage.getItem('cart'));
    expect(savedCart.items).toHaveLength(1);
    expect(savedCart.items[0].name).toBe('Test Product');
  });
});
```

## ğŸ¤” ì˜¤ëŠ˜ì˜ íšŒê³ 

### ì˜ëœ ì 
1. **Context íŒ¨í„´ ë§ˆìŠ¤í„°**: ê¸°ë³¸ë¶€í„° ê³ ê¸‰ íŒ¨í„´ê¹Œì§€ ì™„ì „ ì´í•´
2. **ì‹¤ì „ ì ìš©**: ì‡¼í•‘ì¹´íŠ¸ ê°™ì€ ë³µì¡í•œ ìƒíƒœë„ ê¹”ë”í•˜ê²Œ ê´€ë¦¬
3. **ì„±ëŠ¥ ìµœì í™”**: Context ë¶„ë¦¬ì™€ ë©”ëª¨ì´ì œì´ì…˜ìœ¼ë¡œ ìµœì í™”
4. **í…ŒìŠ¤íŠ¸ ì‘ì„±**: Contextë¥¼ ì‚¬ìš©í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ í…ŒìŠ¤íŠ¸ ë°©ë²• í„°ë“

### ë°°ìš´ ì 
1. **ìƒíƒœ ì„¤ê³„**: ì–´ë–¤ ìƒíƒœë¥¼ ì „ì—­ìœ¼ë¡œ ê´€ë¦¬í• ì§€ íŒë‹¨í•˜ëŠ” ê¸°ì¤€
2. **Context ë¶„ë¦¬**: ì„±ëŠ¥ì„ ìœ„í•œ Context ë¶„í•  ì „ëµ
3. **ì—ëŸ¬ ê²½ê³„**: Context ì‚¬ìš© ì‹œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì—ëŸ¬ ì²˜ë¦¬
4. **íƒ€ì… ì•ˆì •ì„±**: TypeScriptì™€ í•¨ê»˜ ì‚¬ìš©í•  ë•Œì˜ ì´ì 

### ë‚´ì¼ í•  ì¼
1. **Redux Toolkit**: Context APIì™€ Redux ë¹„êµ ë¶„ì„
2. **Zustand**: ê²½ëŸ‰ ìƒíƒœ ê´€ë¦¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ í•™ìŠµ
3. **ì‹¤ìŠµ í”„ë¡œì íŠ¸**: Context APIë¡œ ì™„ì „í•œ ì‡¼í•‘ëª° ìƒíƒœ ê´€ë¦¬ êµ¬í˜„

## ğŸ’» ì½”ë“œ ì‹¤í—˜ì‹¤

### ì‹¤ì‹œê°„ ì•Œë¦¼ Context
```jsx
const NotificationContext = createContext();

export const NotificationProvider = ({ children }) => {
  const [notifications, setNotifications] = useState([]);
  
  const addNotification = useCallback((notification) => {
    const id = Date.now().toString();
    const newNotification = {
      id,
      timestamp: new Date(),
      ...notification
    };
    
    setNotifications(prev => [newNotification, ...prev]);
    
    // ìë™ ì œê±° (ì„ íƒì )
    if (notification.autoRemove !== false) {
      setTimeout(() => {
        removeNotification(id);
      }, notification.duration || 5000);
    }
  }, []);
  
  const removeNotification = useCallback((id) => {
    setNotifications(prev => prev.filter(n => n.id !== id));
  }, []);
  
  const clearAllNotifications = useCallback(() => {
    setNotifications([]);
  }, []);
  
  const value = {
    notifications,
    addNotification,
    removeNotification,
    clearAllNotifications
  };
  
  return (
    <NotificationContext.Provider value={value}>
      {children}
      <NotificationContainer />
    </NotificationContext.Provider>
  );
};

const NotificationContainer = () => {
  const { notifications, removeNotification } = useContext(NotificationContext);
  
  return (
    <div className="notification-container">
      {notifications.map(notification => (
        <div 
          key={notification.id}
          className={`notification ${notification.type || 'info'}`}
        >
          <div className="notification-content">
            <h4>{notification.title}</h4>
            <p>{notification.message}</p>
          </div>
          <button 
            onClick={() => removeNotification(notification.id)}
            className="notification-close"
          >
            Ã—
          </button>
        </div>
      ))}
    </div>
  );
};
```

## ğŸ’¡ ì˜¤ëŠ˜ì˜ ì¸ì‚¬ì´íŠ¸

Context APIë¥¼ ê¹Šì´ ìˆê²Œ ê³µë¶€í•˜ë©´ì„œ Reactì˜ ì§„ì •í•œ ì² í•™ì„ ì´í•´í•˜ê²Œ ë˜ì—ˆë‹¤. ë‹¨ìˆœíˆ props drillingì„ í•´ê²°í•˜ëŠ” ë„êµ¬ê°€ ì•„ë‹ˆë¼, ì»´í¬ë„ŒíŠ¸ ê°„ ì˜ì¡´ì„±ì„ ëª…í™•í•˜ê²Œ ê´€ë¦¬í•˜ê³  ê´€ì‹¬ì‚¬ë¥¼ ë¶„ë¦¬í•˜ëŠ” ê°•ë ¥í•œ íŒ¨í„´ì´ë¼ëŠ” ê±¸ ê¹¨ë‹¬ì•˜ë‹¤.

íŠ¹íˆ ì—¬ëŸ¬ Contextë¥¼ ì¡°í•©í•˜ëŠ” ê³¼ì •ì—ì„œ ëŠë‚€ ê±´ë°, ê° Contextê°€ ë‹¨ì¼ ì±…ì„ì„ ê°€ì§€ë„ë¡ ì„¤ê³„í•˜ëŠ” ê²ƒì´ ì •ë§ ì¤‘ìš”í•˜ë‹¤ëŠ” ì ì´ì—ˆë‹¤. í…Œë§ˆ, ì¸ì¦, ì¥ë°”êµ¬ë‹ˆ ë“±ì„ ë³„ë„ë¡œ ê´€ë¦¬í•˜ë‹ˆ ì½”ë“œê°€ í›¨ì”¬ ëª…í™•í•´ì¡Œë‹¤.

ê°€ì¥ ì¸ìƒì ì´ì—ˆë˜ ë¶€ë¶„ì€ ì„±ëŠ¥ ìµœì í™”ì˜€ë‹¤. ë‹¨ìˆœíˆ Contextì— ëª¨ë“  ê±¸ ë„£ëŠ” ê²Œ ì•„ë‹ˆë¼, ìƒíƒœì™€ ì•¡ì…˜ì„ ë¶„ë¦¬í•˜ê³  ì ì ˆíˆ ë©”ëª¨ì´ì œì´ì…˜ì„ ì ìš©í•˜ë‹ˆ ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ì„ í¬ê²Œ ì¤„ì¼ ìˆ˜ ìˆì—ˆë‹¤.

Context APIë§Œìœ¼ë¡œë„ ì¶©ë¶„íˆ ë³µì¡í•œ ìƒíƒœ ê´€ë¦¬ê°€ ê°€ëŠ¥í•˜ë‹¤ëŠ” ê±¸ í™•ì¸í–ˆì§€ë§Œ, ë‚´ì¼ì€ Reduxì™€ ë¹„êµí•´ë³´ë©´ì„œ ê°ê°ì˜ ì¥ë‹¨ì ì„ ëª…í™•íˆ íŒŒì•…í•´ë³´ì! ğŸš€

---

Context APIì˜ ì§„ì •í•œ í˜ì„ ê¹¨ë‹¬ì€ í•˜ë£¨! ì´ì œ ì „ì—­ ìƒíƒœ ê´€ë¦¬ê°€ ë‘ë µì§€ ì•Šë‹¤ ğŸ”„